本書に記載された内容は、情報の提供のみを目的としています。したがって、本書の記述に従った運用
は、必ずお客様自身の責任と判断によって行ってください。これらの情報の運用の結果について、技術
評論社および著者はいかなる責任も負いません。
本書記載の情報は 2024 年 1 月時点のものですので、ご利用時には変更されている場合もあります。
本書に記載されているサンプルプログラムや操作による実行結果や画面図などは、特定の設定に基づい
た環境で再現される一例です。
ソフトウェアに関する記述は、本文に記載してあるバージョンをもとにしています。ソフトウェアはバ
ージョンアップされる場合があり、本書での説明とは機能内容や画面図などが異なってしまうこともあ
り得ます。本書ご購入の前に、必ずバージョン番号をご確認ください。
以上の注意事項をご承諾いただいたうえで、本書をご利用願います。注意事項をお読みいただかずにお
問い合わせいただいても、技術評論社および著者は対処しかねます。あらかじめ、ご承知おきください。
本書に登場する製品名などは、一般に各社の商標または登録商標です。なお、本書中に TM、Ⓒ、Ⓡなど
のマークは記載しておりません。

はじめに

本書のコンセプトは「プロフェッショナルな Flutter エンジニアになるため
の近道」
です。すでに他のプログラミング言語やフレームワークを習得してい
る方に向けて、Flutter にチャレンジする際に手にとっていただく一冊として
執筆しました。
クライアントワークを生業としている筆者は、これまで Flutter 開発現場を
いくつか目にしてきました。その経験を元に、多くの開発現場で求められる
知識や、重要だけれど独学で学びにくいトピックを取り上げ、コンセプトで
ある「プロフェッショナルな Flutter エンジニアになるための近道」を検討しま
した。Flutter フレームワークについては、基本から実際のプロジェクトで活
用されるテクニックまで、焦点を絞って紹介しています。一方、Flutter の開
発言語である Dart の言語仕様についてはできるだけ網羅的に解説しています。
これは「新しいフレームワークに触れるときは、使用言語を頭にたたき込んで
から」
という筆者のスタイルを反映しています。

Flutter はマルチプラットフォーム対応ということもあり、スタートアップ
から大企業まで採用事例が増えています。開発者体験がよく、要件を満たし
たアプリが作りやすいのは Flutter の特徴の一つです。しかし、中長期的に運
用できる高い保守性をもったアプリにするためには、他のフレームワークと
同様に相応の知識と経験が必要です。Flutter が多くのプロジェクトで採用さ
れているいま、コンセプトである「プロフェッショナルな Flutter エンジニア」
が市場で強く求められています。

2024 年 1 月
渡部陽太

iii

検証環境
・macOS Sonoma 14.3
・Flutter 3.16.9
・Dart 3.2.6
・Android Studio Hedgehog | 2023.1.1 Patch 2
・Xcode 15.2

本書では iOS と Android を対象としたモバイルアプリ開発についてのみ取り
扱います。iOS を開発対象にすることもあり、本書では macOS 環境について
のみ取り扱います。シェルは最新の macOS に合わせて zsh とします。

対象読者
何らかのプログラミング言語やフレームワークを習得している方を対象に
しています。静的型付け言語や UI フレームワークの前提知識があると読み進
めやすいでしょう。iOS エンジニアまたは Android エンジニアで、これから

Flutter を学びたい方には特にマッチするでしょう。

本書の特徴
Flutter の環境構築にはじまり、フレームワークの基礎から実践的なテクニ
ックまで解説します。Flutter にはフレームワークの中心となるウィジェット
というクラスがあります。本書ではウィジェットを使った小さなプログラム
を実装しながら基礎を学びます。重要なクラスであるため後半では内部のし
くみにも踏み込んで解説し、パフォーマンスを意識した実装のコツについて
も紹介します。
ただ、このウィジェットはたくさんのバリエーションがあり、本書ではリ
ファレンスのように広く紹介はしません。ウィジェットの理解を深めるのが
本書の位置付けです。多くのウィジェットを知りたくなったら Flutter 公式

Web サイトの「Widget catalog」のページや、YouTube のプレイリスト「Flutter
Widget of the Week」がお勧めです。
https://docs.flutter.dev/ui/widgets
iv

また、サンプルコードに掲載されたウィジェットや関連クラスについて、
詳しく知りたい場合は公式のリファレンスを参照してください。
https://api.flutter.dev/flutter/widgets/widgets-library.html
本書は Dart 公式 Web サイト注 1、および Flutter 公式 Web サイト注 2 の内容を一
部引用しています。Dart 公式 Web サイトは CC BY 4.0 注 3 と BSD-3-Clause 注 4 のも
とでライセンスされています。Flutter 公式 Web サイトは CC BY 4.0 注 5 と BSD
のもとでライセンスされています。

本書の構成
第 1 章では環境構築を行います。ご自身の Mac を操作しながら読み進めて
ください。
第 2 章では開発言語の Dart を学びます。必要に応じて読み飛ばしていただ
いてもかまいません。気になった要素を後から確認しても良いでしょう。
第 3 章から第 8 章までは Flutter の基礎から応用まで、ハンズオンを交えな
がら理解を深めます。第 3 章はコードを写経しながら読み進めてください。以
降は第 4〜5 章を読んで第 6 章で手を動かすハンズオン、第 7 章を読んで第 8
章で再びハンズオンといった具合に進行します。

のぞ

第 9 章と第 10 章ではフレームワークの内部を覗き、パフォーマンスについ
て学びます。
最後に第 11 章では iOS／Android のネイティブ開発についての解説をしま
す。
なお、本書は技術評論社の『WEB+DB PRESS Vol.130』の特集として掲載さ
れた「いまはじめる Flutter」の内容をベースに、詳細な説明の加筆や最新の状
況を踏まえたトピックの変更を行っています。

注1

https://dart.dev/

注2

https://docs.flutter.dev/

注3

https://creativecommons.org/licenses/by/4.0/

注4

https://opensource.org/license/bsd-3-clause/

注5

https://creativecommons.org/licenses/by/4.0/

v

本書のサンプルプログラムについて
本書のサンプルプログラムは、下記の GitHub にて公開しています。
https://github.com/watanavex/flutter-dev-book

本書の正誤情報や追加情報について
本書の正誤情報や追加情報は、下記のサポートサイトにて公開しています。
https://gihyo.jp/book/2024/978-4-297-13993-3

謝辞
Flutter をキャッチアップし始めた頃からアドバイスをくださり、この書籍
のベースとなった特集記事のレビューにも携わってくれた mono さん。mono
さんから頂いた助言の数々が、この書籍のゴールを照らしてくれました。
執筆にあたり、Flutter の興味深い開発経験をさせてくださった su- さん、

maemae さんに感謝を伝えたい。みなさんから頂いた経験が執筆の勇気をく
れました。
レビューに関わってくれた株式会社ゆめみの同僚たち。おかやまん、json、
いせりゅうさん、田畑さん、りずさん、しまもんさん、でんでんさん、やま
ぱんさん。この分量の書籍を、細やかに丁寧にレビューしてくださり感激し
ました。みなさんのおかげで、私の書いたコンテンツが書籍として大きく前
進しました。ありがとう。
編集者の菊池さん。菊池さんの「この書籍を少しでも良いものにしよう」
と
いう姿勢が、折れそうな私の心を何度蘇らせたことでしょう。
初めから最後まで並走してくださり感謝です。
最後に、常にそばで支えてくれた妻に感謝を伝えたい。締切恐怖症である
私をよく理解したあなたの放つ「大丈夫」の言葉にどれだけ励まされたことか。
そして、心の支えである 2 人の息子たち。休日返上での執筆作業が続き、寂
しい思いをさせたよね。日向、日彩、今度の休日は水族館に行こう！

vi

目次

Flutter実践開発
目次

iPhone／Android両対応アプリ開発のテクニック

はじめに....................................................................................................... iii
本書について................................................................................................ iv

第

1

章

環境構築とアプリの実行

Flutter SDK、Android Studio、Xcode......................................................... 1

1.1

なぜFlutterが注目を集めているのか

2

マルチプラットフォーム.. ................................................................................ 2
高速な実行速度............................................................................................ 3
優れた開発者体験........................................................................................ 3

1.2

Flutterの環境構築

3

Flutterのインストール. . ................................................................................ 4
プラットフォームごとの環境のインストール. . .................................................. 5
Androidの開発環境をインストールする.. ................................................ 6
iOSの開発環境をインストールする........................................................ 9
Tips

Xcodeのバージョンを使い分けるインストールのしかた.......................... 10

Tips

CocoaPodsがインストールできない場合........................................... 10

Android Studioの設定 Flutterと親和性の高いIDE. . ..................................... 12

1.3

fvmによるFlutterのバージョン管理

13

fvmのインストール...................................................................................... 13
fvmを利用したFlutterのインストール.. ....................................................... 13

1.4

プロジェクトの作成

15

Android Studioでの作成手順................................................................... 15
テンプレートプロジェクトをのぞいてみよう. . ................................................. 16
fvmの設定.................................................................................................. 17

1.5

Flutterアプリの実行

18

iOS Simulatorでの実行. . ........................................................................... 19
Android Emulatorでの実行..................................................................... 20
Android Emulatorを作成する. . ........................................................... 20

vii

Android Emulatorを起動し、
アプリを実行する..................................... 21

1.6
第

まとめ

2

22

章

Dartの言語仕様..................................................................................... 23
2.1

変数宣言

24

変数と型推論.............................................................................................. 24
定数 finalとconst........................................................................................ 24
いろいろな初期値の与え方. . ....................................................................... 25
遅延初期化....................................................................................... 26

2.2

組み込み型

27

数値型.. ....................................................................................................... 27
int 整数型........................................................................................ 27
double 浮動小数型............................................................................ 27
String 文字列型.. ........................................................................................ 27
bool 論理型.. .............................................................................................. 29
List 配列. . .................................................................................................. 29
Set 集合.................................................................................................... 30
Map 連想配列............................................................................................ 30
Record タプル............................................................................................ 31
Objectクラス すべてのクラスのスーパークラス................................................ 33

2.3

ジェネリクス

34

ジェネリッククラス. . ..................................................................................... 34
ジェネリック関数......................................................................................... 35

2.4

演算子

35

算術演算子................................................................................................. 35
比較演算子................................................................................................. 36
三項演算子.................................................................................................. 37
カスケード記法.. ........................................................................................... 37
コレクションのオペレータ. . .......................................................................... 38
Spread演算子.. ................................................................................. 38
制御構文演算子................................................................................ 38

viii

目次

2.5

制御構文

39

分岐............................................................................................................ 39
if文.................................................................................................. 39
if-case文.. ........................................................................................ 39
switch文.......................................................................................... 40
式としてのswitch. . ............................................................................. 41
ループ. . ....................................................................................................... 42
for文................................................................................................ 42
while文............................................................................................ 43
breakとcontinue.............................................................................. 43

2.6

パターン

44

マッチング機能しか持たないパターン......................................................... 44
論理演算子、比較演算子.. ................................................................... 44
一致判定.......................................................................................... 45
マッチングと分解宣言の2つの機能を持つパターン. . .................................. 46
List.................................................................................................. 46
Map................................................................................................. 46
Record............................................................................................. 46
Object.. ............................................................................................ 47
Tips

for-in文での分解宣言.................................................................. 48

パターンを補助する構文............................................................................. 49
キャスト.. ........................................................................................... 49
nullチェック. . ..................................................................................... 49
nullアサーション.. .............................................................................. 49
ワイルドカード................................................................................... 50

2.7

例外処理

50

例外の型 ErrorとException........................................................................... 51
例外の捕捉.................................................................................................. 51
例外の再スロー. . ......................................................................................... 52
finally句.. ................................................................................................... 52
アサーション. . .............................................................................................. 52
Flutterの例外処理. . ................................................................................... 53

2.8

コメント

54

2.9

null安全

55

null許容演算子.......................................................................................... 55
null認識演算子.......................................................................................... 55
nullアサーション演算子.. ............................................................................ 55
ix

タイププロモーション.................................................................................. 56
そのほかの便利なnull関連演算子............................................................. 56

2.10 ライブラリと可視性

57

2.11 関数

57

引数............................................................................................................. 57
省略可能引数. . .................................................................................. 58
名前付き引数.................................................................................... 58
関数の省略記法. . ........................................................................................ 59
第一級関数と匿名関数............................................................................... 59

2.12 クラス

61

ゲッタとセッタ............................................................................................. 62
いろいろなコンストラクタ............................................................................ 62
constantコンストラクタ. . .................................................................... 63
名前付きコンストラクタ.. ..................................................................... 64
factoryコンストラクタ........................................................................ 64
クラス継承.................................................................................................. 65
スーパークラスのコンストラクタ.. ......................................................... 66
暗黙のインタフェース................................................................................... 67
拡張メソッド. . .............................................................................................. 68
mixin クラスに機能を追加する....................................................................... 69
Enum......................................................................................................... 70
Enumの宣言. . ................................................................................... 70
Enumの利用. . ................................................................................... 71
クラス修飾子. . ............................................................................................. 72
abstract........................................................................................... 73
base................................................................................................ 73
interface.......................................................................................... 75
abstractとinterfaceの組み合わせ.. .................................................... 76
final................................................................................................. 76
mixin............................................................................................... 77
sealed.. ............................................................................................ 77

2.13 非同期処理

78

Future型. . .................................................................................................. 78
エラーハンドリング.. ........................................................................... 79
Stream型.. .................................................................................................. 81
Streamの購読をキャンセル、一時停止する. . ......................................... 81
Stream型を生成する関数.................................................................. 82

x

目次

Streamの終わり.. .............................................................................. 83
エラーハンドリング.. ........................................................................... 84
StreamController............................................................................. 85
ブロードキャスト................................................................................ 87
Streamを変更する............................................................................ 88

Zone 非同期処理のコンテキスト管理............................................................... 88
アイソレート. . ............................................................................................... 90
Flutterアプリとアイソレート................................................................ 90

2.14 まとめ
第

3

92

章

フレームワークの中心となる
Widgetの実装体験

StatelessWidget、StatefulWidget............................................................. 93

3.1

DartPadでアプリ開発を体験しよう

94

3.2

状態を持たないWidget StatelessWidget

96

独自のStatelessWidgetを定義する.. ........................................................ 98

3.3

状態を持つWidget StatefulWidget

100

Widgetのタップ操作を検知する............................................................... 101
StatefulWidgetを継承する...................................................................... 102
Widgetの状態を変化させる...................................................................... 104

3.4
第

まとめ

4

105

章

アプリの日本語化対応、
アセット管理、
環境変数................................................................... 107
4.1

パッケージやツールを導入する

108

パッケージの導入方法............................................................................... 109
パッケージバージョンの指定方法.............................................................. 110
パッケージバージョンの更新方法.............................................................. 111
xi

Tips

4.2

セマンティックバージョニングについて............................................. 111

アプリを日本語に対応させる

113

意図せず英語表示されるケース. . ............................................................... 114
フレームワークが提供する表示文字列.. ............................................... 114
日付フォーマット.............................................................................. 115
アプリを日本にローカライズする................................................................ 117
フレームワークが提供する表示文字列を日本語化する.......................... 117
日付フォーマットを日本語化する....................................................... 119
iOSアプリの対応言語を設定する...................................................... 121
メッセージをローカライズする.................................................................... 121
コードジェネレータを設定する. . ......................................................... 121
arbファイルを作成する..................................................................... 122
ローカライズされたメッセージを表示する........................................... 123
arbファイルの扱い方................................................................................. 125
プレースホルダ.. .............................................................................. 125
単数形と複数形の対応. . ................................................................... 126
複数の言語への対応. . ...................................................................... 128

4.3

プロジェクトにアセットを追加する

129

アプリに画像を追加する............................................................................ 129
端末の解像度に応じて画像を切り替える................................................... 131
flutter_gen 型安全にアセットを扱うパッケージ............................................... 133
flutter_genを導入する. . ................................................................... 133
SVG画像の利用.............................................................................. 134
その他のアセット............................................................................. 137

4.4

dart-define-from-file 環境変数を扱う

137

環境変数をJSON形式で記述する............................................................. 137
環境変数をコードから参照する.................................................................. 138

4.5
第

まとめ

5

139

章

テーマとルーティング........................................................................ 141
5.1

テーマ アプリ全体のヴィジュアルを管理

142

フレームワークによるテーマの自動計算機能............................................. 142
ダークモード対応............................................................................. 146

xii

目次

アプリ独自のテーマ管理............................................................................ 147
Theme Extensionを利用したアプリのサンプル.................................. 150
Tips

5.2

デザイン.................................................... 152
Cupertino（クパチーノ）

ナビゲーションとルーティング

画面遷移を実現する3つの手法

152

NavigatorウィジェットとRouteクラスによる画面遷移 Navigator 1.0. . ....... 154
画面間でのデータの受け渡し............................................................ 158
名前付きルートによる画面遷移 Navigator 1.0（非推奨）................................ 161
名前付きルートの制限事項............................................................... 166
Routerウィジェットによる画面遷移 Navigator 2.0...................................... 167
go_routerによる画面スタックの書き換えを体験する.. ........................... 167
GoRouteで入れ子構造を作る. . ......................................................... 170
goとpushの違い............................................................................. 175

5.3
第

まとめ

6

章

実践ハンズオン❶
6.1

180

画像編集アプリを開発.. ............................ 181

開発するアプリの概要

182

スタート画面.............................................................................................. 182
画像選択画面............................................................................................ 183
画像編集画面............................................................................................ 184
開発の土台づくり....................................................................................... 185
テーマと画面遷移の方針........................................................................... 185

6.2

プロジェクトを作成する

185

開発の土台づくり....................................................................................... 186

6.3

アプリ起動後のスタート画面を作成する

186

レイアウトを作成する................................................................................. 188

6.4

テーマをアレンジする

190

6.5

アプリを日本語化する

190

パッケージを導入する................................................................................ 190
ローカライズの構成ファイルを作成する..................................................... 191
arbファイルを作成する.............................................................................. 191
ローカライズされたメッセージを適用する.................................................. 192
xiii

App Storeでの表示言語を設定する......................................................... 194

6.6

画像選択画面を作成する

195

メッセージを追加する. . ............................................................................... 195
レイアウトを作成する................................................................................. 196
画像ライブラリから画像を取得する.. .......................................................... 198
パッケージを導入する...................................................................... 198
iOSネイティブの設定を行う.............................................................. 199
画像を取得する処理を実装する.. ....................................................... 199
画像取得処理をWidgetに組み込む. . ................................................. 201

6.7

画像編集画面を作成する

203

メッセージを追加する. . ............................................................................... 203
レイアウトを作成する................................................................................. 204
画像編集画面への遷移を実装する............................................................ 205
アイコンを追加する flutter_genによるアセット管理......................................... 207
画像を編集する処理を実装する................................................................. 210

6.8

まとめ

212
Tips

第

7

WidgetとStateのライフサイクルについて........................................ 213

章

状態管理とRiverpod....................................................................... 215
7.1

Flutterアプリにおける状態管理

216

7.2

Riverpodとはどのようなパッケージか

217

Tips

宣言的UIとしてのFlutter.. ............................................................ 217

Riverpodの主要なクラス.......................................................................... 218
実装サンプル............................................................................................. 218

7.3

Riverpodの関連パッケージ

221

基本機能を提供するパッケージ................................................................. 221
Providerのコードを生成するパッケージ................................................... 222
静的解析を行うパッケージ. . ....................................................................... 223
関連パッケージまとめ................................................................................ 223

7.4
xiv

Riverpodの使い方

224

目次

Providerの種類........................................................................................ 224
関数ベースのProvider..................................................................... 224
クラスベースのProvider................................................................... 225
非同期処理を行うProvider....................................................................... 227
非同期なProviderとRaw型.............................................................. 229
Providerから値を取得する....................................................................... 230
Providerの値をフィルタする............................................................. 231
Providerのライフサイクル. . ....................................................................... 231
Providerにパラメータを渡す.................................................................... 232

7.5
第

まとめ

8

章

実践ハンズオン❷
8.1

234

ひらがな変換アプリを開発..................... 235

開発するアプリの概要

236

入力状態. . .................................................................................................. 237
レスポンス待ち状態................................................................................... 237
変換完了状態............................................................................................ 238
開発の土台づくり....................................................................................... 239
テーマと画面遷移の方針........................................................................... 239

8.2

プロジェクトを作成する

239

8.3

アプリで使用するパッケージを導入する

240

riverpod_lintを設定する.......................................................................... 241

8.4

入力状態のウィジェットを実装する

241

レイアウトを作成する................................................................................. 241
レイアウトを表示する................................................................................. 243
入力値のバリデーションを行う................................................................... 244

8.5

入力文字を取得する

246

8.6

ひらがな化するWeb APIを呼び出す実装をする

248

リクエスト、
レスポンスオブジェクトを定義する........................................... 249
アプリケーションIDを設定する.. ................................................................. 251
Web APIを呼び出す................................................................................. 251

xv

8.7

アプリの状態を管理する

254

状態を表現するクラスを作成する.............................................................. 254

8.8

状態に応じて表示を切り替える

256

レスポンス待ち状態のウィジェットを実装する............................................ 256
変換完了状態のウィジェットを実装する.. .................................................... 257
画面の切り替えを行う................................................................................ 258
ひらがな変換処理の呼び出しを修正する. . ................................................. 259

8.9
第

まとめ

9

262

章

フレームワークによる
パフォーマンスの最適化

BuildContext、
Key........................................................................................... 263

9.1

BuildContextは何者なのか Element

264

祖先の情報にアクセスできるBuildContext. . ............................................ 264
Elementがツリーを構成していく工程.. ............................................... 265
StatefulWidgetの状態を保持する役割.. .................................................. 268
Tips

9.2

宣言的UIとElementの再利用. . ..................................................... 273

Elementの再利用とパフォーマンス RenderObject

273

RenderObjectは高コストな計算を行う.................................................... 274
RenderObjectは状態を持つ. . .................................................................. 274
Elementの再利用はパフォーマンスに影響する........................................ 275

9.3

Keyは何に使うのか

275

Elementが再利用される条件................................................................... 276
Elementが再利用される様子を見てみよう............................................... 276
Keyを利用したElementの再利用..................................................... 279
Keyの種類................................................................................................ 281

xvi

9.4

局所的にWidgetを更新するしくみ InheritedWidget

282

9.5

まとめ

284

目次

第

10

章

高速で保守性の高いアプリを
開発するためのコツ........................................................................... 285
10.1 パフォーマンスと保守性、どちらを優先すべきか

286

高速でないアプリとは................................................................................ 286
高速だが保守性が低い実装...................................................................... 286

10.2 高速で保守性の高い実装

287

buildメソッドで高コストな計算をしない.................................................... 287
buildメソッドで大きなウィジェットツリーを構築しない. . ............................. 289
ウィジェットツリーの階層が浅くなるようウィジェットの選択を見なおす. . . 289
const修飾子を付与する. . .......................................................................... 291
const修飾子が使えるようウィジェットの選択を見なおす...................... 292
独自のウィジェットクラスにconstantコンストラクタを実装する............. 292
状態を末端のウィジェットに移す................................................................ 297
Riverpodの状態監視は末端のウィジェットで行う..................................... 300
Tips

アプリのパフォーマンスを計測する. . ................................................ 303

10.3 まとめ
第

11

304

章

Flutterアプリ開発に必要な
ネイティブの知識................................................................................... 305
11.1 ネイティブAPIのバージョンと最低サポートOSのバージョン

306

最低サポートOSのバージョン.................................................................... 306
iOSの最低サポートOSバージョンを設定する. . .................................... 308
Tips

XcodeのBuild Settings............................................................. 308

Androidの最低サポートOSバージョンを設定する................................ 310

ビルドSDKバージョン................................................................................ 310
iOSのビルドSDKバージョンの設定.................................................... 310
AndroidのビルドSDKバージョンの設定.. ............................................ 310
ターゲットSDKバージョン. . ........................................................................ 311

11.2 アプリの設定変更

312

アプリ名..................................................................................................... 312
xvii

iOSのアプリ名を変更する................................................................ 312
Androidのアプリ名を変更する.......................................................... 312

アプリアイコン............................................................................................ 313
iOSのアプリアイコンを変更する........................................................ 313
Androidのアプリアイコンを変更する.................................................. 314
アプリアイコンを手軽に生成するパッケージ. . ...................................... 315
スプラッシュ画面.. ...................................................................................... 316
iOSとAndroidで異なるスプラッシュ画面の位置付け............................ 316
iOSのスプラッシュ画面..................................................................... 316
Androidのスプラッシュ画面.. ............................................................. 317
スプラッシュ画面を手軽に実現するパッケージ. . ................................... 317
アプリのID................................................................................................. 319
iOSのアプリIDを設定する................................................................ 319
AndroidのアプリIDを設定する......................................................... 320

11.3 アプリの配布とコード署名

320

iOSのコード署名....................................................................................... 321
管理の難しい秘密鍵........................................................................ 321
アプリに署名する. . ........................................................................... 322
Androidのコード署名.. .............................................................................. 326
apkファイルとaabファイル........................................................................ 327
アプリに署名する. . ........................................................................... 327
aabファイルをアップロードする......................................................... 330

11.4 まとめ

334

参考Web情報. . .......................................................................................... 335
著者プロフィール.. ...................................................................................... 335
索引........................................................................................................... 336

xviii

第

1

章

環境構築とアプリの実行
Flutter SDK、
Android Studio、Xcode

1

第

1 環境構築とアプリの実行
章

Flutter SDK、Android Studio、Xcode

本章では、Flutter の特徴を簡単に紹介したのち、環境構築の手順を解説し
ます。Flutter 公式がアナウンスしている環境構築の手順に加え、筆者が普段
から利用しているツールなども紹介します。最後には、テンプレートの Flutter
アプリを起動するところまでを実践します。

1.1
なぜFlutterが注目を集めているのか
Flutter は Google を中心としたオープンソースコミュニティによって開発さ
れているマルチプラットフォームフレームワークです注 1。これまでのマルチプ
ラットフォーム技術とは一線を画した実現方式を持ち、高速な実行速度と優
れた開発者体験が特徴です。この Flutter がスマートフォンアプリの開発にお
いて、シェアを伸ばしています。

マルチプラットフォーム
Flutter は 1 つのコードベースからさまざまなプラットフォームへアプリケ
ーションを提供することができます。そのサポート環境は、公式発表でモバ
、
イル（iOS および Android）、デスクトップ（Windows、macOS および Linux）

Web フロントエンドと多岐にわたります。
また、複数のプラットフォームで安定した動作を実現する構成になってい
る点も特徴です。マルチプラットフォーム技術の中には Xamarin 注 2 のように
ネイティブ UI（User Interface）をラップした形式のものがあります。こうした
フレームワークでは、複数プラットフォームの API をラップする過程で、吸
収しきれない差異が発生するケースがあります。一方で Flutter はネイティブ
の UI を使わない、独自のレンダリングのしくみを持っています。そのため
「iOS でデバッグしたあと、Android でデバッグすると想定した UI になってい
ない」といった動作差異が限りなく小さくなります。
なお、本書では iOS と Android を対象としたモバイル開発についてのみ取り
扱います。

2

注1

https://flutter.dev/

注2

https://docs.microsoft.com/ja-jp/xamarin/

Flutterの環境構築

1.2

高速な実行速度
Flutter で開発したアプリケーションはネイティブコードにコンパイルされ
ます。Cordova 注 3 などのように WebView 上で動作するマルチプラットフォー
ムフレームワークよりも、高速に動作することが期待できます。開発元の

Google は、前項でも触れた独自のレンダリングのしくみによる高いパフォー
マンスをアピールしています。筆者の体感としても、他のいくつかのマルチ
プラットフォームフレームワークと比較して、Flutter は安定して高いパフォ
ーマンスを発揮しているように感じます。

優れた開発者体験
フレームワークの浸透、発展において優れた開発者体験は重要であり、

Flutter はその要素を十分に持っています。筆頭に挙げられるのはホットリロ
ードで、ソースコードの変更を実行中のアプリに即座に反映するしくみです。
プログラムで UI を微調整したらすぐにアプリの画面に反映されるため、トラ
イ＆エラーをすばやく繰り返すことが可能です。また、コードラボ（チュート
注5
（実装例）
が充実しています。パッケージ管理ツー
リアル）注 4 やクックブック

ルやコードの静的解析ツールなどが統合されている点も開発者にとってうれ
しいポイントの一つです。

1.2
Flutterの環境構築
それでは Flutter の開発環境を構築しましょう。Flutter の環境構築は大きく

2 つの段階があります。
1 つ目は Flutter SDK（Software Development Kit）のインストール、2 つ目は実行
するプラットフォームである iOS と Android の開発環境のインストールです。
なお、iOS を開発対象にすることもあり、本書では macOS 環境についての

注3

https://cordova.apache.org

注4

https://docs.flutter.dev/codelabs

注5

https://docs.flutter.dev/cookbook

3

第

1 環境構築とアプリの実行
章

Flutter SDK、Android Studio、Xcode

み取り扱います。執筆時の環境は以下です。
・macOS Sonoma 14.3
・Flutter 3.16.9

Flutterのインストール
本項のいくつかの手順は、後述の「1.3 fvm による Flutter のバージョン管理」
の節で解説する fvm というツールを導入することで省略できます。しかし、
はじめての環境構築は内容を理解するためにも、手順を踏んでインストール
してみることをお勧めします。
まずは、Flutter の公式 Web サイトから Flutter SDK の ZIP ファイルをダウン
ロードします。URL の参照先は iOS の環境構築に関するページですが、Flutter

SDK の ZIP ファイルは他のプラットフォームと共通です。
・https://docs.flutter.dev/get-started/install/macos/mobile-ios?tab=down
load#install-the-flutter-sdk

ZIP ファイルは Intel CPU 向けと Apple Silicon 向けが用意されていますので、
お使いの環境に合わせてダウンロードしてください。

Apple Silicon 搭載の Mac をお使いの場合は、加えて Rosetta 2 をインストー
ルしましょう。SDK に含まれる一部の実行ファイルが x64 アーキテクチャで
提供されており、これらを Apple Silicon 搭載の Mac で動作させるために Rosetta

2 が必要になります。Rosetta 2 は以下のコマンドでインストールします。
# Rosetta 2をインストール
$ sudo softwareupdate --install-rosetta --agree-to-license

ダウンロードした ZIP ファイルを解凍し、任意のディレクトリに配置しま
す。今回は公式 Web サイトで紹介されているディレクトリ（~/development）
で進めます。
~/development
└── flutter
├── bin
├── dev
├── examples
├── packages
└── ...（省略）

次に、配置した Flutter SDK にパスを通します。以下のコマンドを実行し、
4

Flutterの環境構築

1.2

どうこん

SDK に同梱されている実行ファイルをどのディレクトリからでも実行できる
ようにします。
# flutterのコマンドラインツールにパスを通す

$ echo "export PATH=\"\$PATH:$HOME/development/flutter/bin\"" >> ~/.zshenv
# 実行中のシェルにパスを適用
$ . ~/.zshenv

これで Flutter のインストールは完了です。確認のため、Flutter のバージョ
ンをターミナルに出力してみましょう。
# flutterのバージョンを出力
$ flutter --version

環境に git がインストールされていない場合は、デベロッパツールのインス
トールを促すダイアログが表示されます（図 1.1）
。これは Flutter のコマンド
ラインツールが、内部で git コマンドを呼び出しているためです。インストー
ルしておきましょう。
図 1.1

デベロッパツールのインストールダイアログ

筆者の環境では flutter --version の結果は以下のように出力されました。
Flutter 3.16.9 • channel stable • https://github.com/flutter/flutter.git
Framework • revision 41456452f2 (32 hours ago) • 2024-01-25 10:06:23 -0800
Engine • revision f40e976bed
Tools • Dart 3.2.6 • DevTools 2.28.5

プラットフォームごとの環境のインストール
Flutter で開発したプロジェクトを iOS や Android へビルドするために、各プ
ラットフォームの開発環境を構築する必要があります。開発環境の情報を出
力するコマンド
（flutter doctor）
を活用しながら各プラットフォームの開発
環境をインストールしていきましょう。
5

第

1 環境構築とアプリの実行
章

Flutter SDK、Android Studio、Xcode

# flutterの開発環境の情報を出力
$ flutter doctor
図 1.2

flutter doctor の出力結果

[✓] Flutter (Channel stable, 3.16.9, on macOS 14.3 23D56 darwin-arm64, locale ja-JP)

❶

[✗] Android toolchain - develop for Android devices
✗ Unable to locate Android SDK.

Install Android Studio from: https://developer.android.com/studio/index.html
On first launch it will assist you in installing the Android SDK components.

(or visit https://flutter.dev/docs/get-started/install/macos#android-setup for

detailed instructions).

If the Android SDK has been installed to a custom location, please use
`flutter config --android-sdk` to update to that location.

[✗] Xcode - develop for iOS and macOS

❷

✗ Xcode installation is incomplete; a full installation is necessary for iOS and

macOS development.

Download at: https://developer.apple.com/xcode/
Or install Xcode via the App Store.
Once installed, run:

sudo xcode-select --switch /Applications/Xcode.app/Contents/Developer
sudo xcodebuild -runFirstLaunch

✗ CocoaPods not installed.

CocoaPods is used to retrieve the iOS and macOS platform side's plugin code

that responds to your

plugin usage on the Dart side.

Without CocoaPods, plugins will not work on iOS or macOS.
For more info, see https://flutter.dev/platform-plugins

To install see https://guides.cocoapods.org/using/getting-started.html#install

ation for instructions.

[✗] Chrome - develop for the web (Cannot find Chrome executable at /Applications/Google
Chrome.app/Contents/MacOS/Google Chrome)

! Cannot find Chrome. Try setting CHROME_EXECUTABLE to a Chrome executable.

[!] Android Studio (not installed)

[✗] Connected device (1 available)

❸

[✗] Network resources

コマンドの出力結果（図 1.2）の❶と❸が Android の開発環境、❷が iOS の開
発環境に関わる項目です。
Androidの開発環境をインストールする

あらためて flutter doctor の出力結果から、Android の開発環境に関わる
項目を確認します。Android の開発環境がまだ構築されていない場合は、以下
6

Flutterの環境構築

1.2

の出力結果のように 2 項目に Android toolchain のエラー、5 項目に Android

Studio の警告が表示されます。
[✗] Android toolchain - develop for Android devices

✗ Unable to locate Android SDK.
Install Android Studio from: https://developer.android.com/studio/index.html

On first launch it will assist you in installing the Android SDK components.

(or visit https://flutter.dev/docs/get-started/install/macos#android-setup
for detailed instructions).
If the Android SDK has been installed to a custom location, please use
`flutter config --android-sdk` to update to that location.
[!] Android Studio (not installed)

こ の 場 合 は 最 初 に Android ア プ リ 開 発 用 の IDE（Integrated Development
Environment、統合開発環境）である Android Studio をインストールするのが簡
単です。Android の開発者向け Web サイトからダウンロードし、セットアッ
プウィザードの手順どおりに進めてください
・https://developer.android.com/studio/index.html

完了したら、あらためて flutter doctor を実行します。Android Studio の
項にチェックが付けば OK です。
[✓] Android Studio (version 2023.1)

続いて、Android toolchain をインストールします。Android Studio を起動し、
アプリケーションメニューから「Settings」を選択します。Settings ウィンドウ
「Android SDK」
を選択し
の検索窓に「Android SDK」と入力し、ツリーの中から
ます
（図 1.3）
。「SDK Tools」タブを選択し、「Android SDK Command-line Tools

(latest)」にチェックを入れ、OK ボタンを押します。

7

第

1 環境構築とアプリの実行
章

Flutter SDK、Android Studio、Xcode

図 1.3

Settings ウィンドウ

再び flutter doctor を実行します。以下のようにライセンスの同意に関す
る内容が表示された場合は、メッセージ内のコマンドを実行します。
[!] Android toolchain - develop for Android devices (Android SDK version 34.0.0)
! Some Android licenses not accepted. To resolve this, run: flutter doctor
--android-licenses
# Android toolchainのライセンスに同意する
$ flutter doctor --android-licenses

すると、対話形式でライセンスの同意操作を進められます。All SDK package
licenses accepted と表示されたら完了です。
（ライセンス条文）
----------------------------Accept? (y/N): y
All SDK package licenses accepted

再び flutter doctor を実行します。以下のようにチェックが付けば Android
の開発環境のインストールは完了です。
[✓] Android toolchain - develop for Android devices (Android SDK version 34.0.0)

8

Flutterの環境構築

1.2

iOSの開発環境をインストールする

flutter doctor の出力結果から、Xcode の情報を確認しましょう。Xcode
は Apple のプラットフォーム向けの IDE
（統合開発環境）です。iOS の開発環境
がまだ構築されていない場合は、以下のように Xcode installation is
incomplete とメッセージが表示される可能性があります。
[✗] Xcode - develop for iOS and macOS

✗ Xcode installation is incomplete; a full installation is necessary for iOS
and macOS development.
Download at: https://developer.apple.com/xcode/
Or install Xcode via the App Store.

この場合は最初に Xcode をインストールします。最も簡単な方法は Mac App

Store から Xcode をインストールする方法です（Tips 参照）。Mac App Store に
というキーワードで検索すると簡単に見つけられます。
て、
「Xcode」

Xcode をインストールしたら、以下のコマンドを実行します。
# Xcodeコマンドラインツールのディレクトリを指定
$ sudo xcode-select --switch /Applications/Xcode.app/Contents/Developer
# Xcodeの関連パッケージをインストール
$ sudo xcodebuild -runFirstLaunch
# XcodeとSDKのライセンスに同意
$ sudo xcodebuild -license

途中、何度か Xcode のライセンスに同意を求められることがあります。内
容を確認し、同意する場合は「agree」と入力します。
By typing 'agree' you are agreeing to the terms of the software license agreement
s. Any other response will cancel. [agree, cancel]
agree

再び flutter doctor を実行し、状況を確認します。iOS Simulator のランタ
イムがインストールされていない場合は、以下のように Unable to get list of
installed Simulator runtimes.とメッセージが表示される可能性があります。
[!] Xcode - develop for iOS and macOS (Xcode 15.2)
✗ Unable to get list of installed Simulator runtimes.

この場合は以下のコマンドを実行して iOS Simulator のランタイムをインス
トールします。
# iOS Simulatorのランタイムをインストール
$ xcodebuild -downloadPlatform iOS

再び flutter doctor を実行し、状況を確認します。以下のように CocoaPods
9

第

1 環境構築とアプリの実行
章

Flutter SDK、Android Studio、Xcode

がインストールされていない旨のメッセージが表示された場合は、CocoaPods
のインストールを実行します。
[!] Xcode - develop for iOS and macOS (Xcode 15.2)
✗ CocoaPods not installed.

CocoaPods は iOS アプリ開発で用いられる Ruby 製のパッケージ管理ツールで
す。macOS 標準の Ruby を用いる場合は以下のコマンドでインストールします
。
（Tips 参照）
# CocoaPodsをインストール

$ sudo gem install cocoapods

CocoaPods のインストールが完了したら、flutter doctor で状況を確認し
ます。以下のようにチェックが付けば iOS の開発環境のインストールは完了
です。
[✓] Xcode - develop for iOS and macOS (Xcode 15.2)

Tips Xcodeのバージョンを使い分けるインストールのしかた
Mac App Store から Xcode をインストールした場合は、新しいバージョンの
Xcode がリリースされると上書きアップデートされます。実際のアプリ開発では
複数バージョンの Xcode の使い分けが必要なこともあり、上書きアップデートが
問題になるケースもあります。このようなケースに対応するため、筆者は Apple
の開発者向けサイト注 a から Xcode をダウンロードする方法を取っています。
ダウンロードした Xcode は /Applications 配下に配置しておきましょう。
注a

https://developer.apple.com/download/applications/

Tips CocoaPodsがインストールできない場合
macOS 標準の Ruby のバージョンでは CocoaPods がインストールできない場
合があります。そのようなときの対処法の一例を紹介します。
Ruby のバージョン管理ツールである rbenv を使って Ruby のバージョンを上
げます。まず、rbenv をインストールするためのパッケージマネージャである
Homebrew を用いてインストールします。Homebrew のインストールに関する
詳細は公式 Web サイト注 a に記載があります。

注a

10

https://docs.brew.sh/Installation

Flutterの環境構築

1.2

# Homebrewをインストール

$ /bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/ins
tall/HEAD/install.sh)"
# Homebrewにパスを通す

$ echo "export PATH=\"\$PATH:/opt/homebrew/bin\"" >> ~/.zshenv
# 実行中のシェルにパスを適用
$ . ~/.zshenv

続いて、rbenv をインストールします。
# rbenvをインストール

$ brew install rbenv ruby-build
# rbenvにパスを通す

$ echo "eval \"\$(rbenv init - zsh)\"" >> ~/.zshrc
# 実行中のシェルにパスを適用
$ . ~/.zshrc

rbenv を使って Ruby をインストールします。今回は 2.7.5 をインストールし
ます。
# バージョン2.7.5のRubyをインストール
$ rbenv install 2.7.5
# グローバルのRubyのバージョンを2.7.5に設定
$ rbenv global 2.7.5

以下のコマンドで Ruby のバージョンを確認しましょう。
# Rubyのバージョンを出力
$ ruby --version

バージョン 2.7.5 が適用されていない場合はターミナルを再起動してください。
続いて、CocoaPods をインストールします。
# CocoaPodsをインストール
$ gem install cocoapods

以下のコマンドで CocoaPods のバージョンを確認しましょう。
# CocoaPodsのバージョンを出力
$ pod --version

無事にバージョンが表示されれば完了です。

11

第

1 環境構築とアプリの実行
章

Flutter SDK、Android Studio、Xcode

Android Studioの設定 ── Flutterと親和性の高いIDE
Flutter アプリの開発には Android Studio、IntelliJ IDEA や Visual Studio Code
（以降、VS Code）がよく用いられます。これらの IDE にはプラグインが提供さ
れており、コード補完やデバッグ、ステップ実行などの機能が利用できます。
本書では環境構築の過程で Android Studio をインストールしているので、

Android Studio を中心に解説していきます（VS Code も軽量で扱いやすく筆者
は気に入っています）
。

Android Studio でプラグインをインストールするには、アプリケーションメ
ニューから「Settings」を選択します。Settings ウィンドウの検索窓に「Plugins」
。
「Marketplace」
タ
と入力し、ツリーの中から「Plugins」を選択します（図 1.4）
ブを開いたら、
「Flutter」というキーワードでプラグインを検索します。Flutter
プラグインが見つかったらインストールボタンを押します。Flutter プラグイ
ンと併せて Dart プラグインも同時にインストールされます。
インストールが完了したら Android Studio を再起動しましょう。
図 1.4

12

Settings ウィンドウ

fvmによるFlutterのバージョン管理

1.3

1.3
fvmによるFlutterのバージョン管理
プロジェクトごとに Flutter のバージョンを切り替えることができる fvm と
いうツールを紹介します。fvm を利用することで、Flutter のバージョンを切
り替えるために Flutter SDK を再インストールする手間を省くことができま
す。
「過去に開発した Flutter アプリをメンテナンスするために、古いバージ
ョンの Flutter を入れなおす……」といった面倒ごとから解放されます。

fvmのインストール
まず fvm をインストールするために、macOS 向けのパッケージ管理ツール

Homebrew をインストールします。CocoaPods のインストール時に Homebrew
を導入した場合はこの手順は不要です。
# Homebrewをインストール
$ /bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/H
EAD/install.sh)"
# Homebrewにパスを通す
$ echo "export PATH=\"\$PATH:/opt/homebrew/bin\"" >> ~/.zshenv
# 実行中のシェルにパスを適用
$ . ~/.zshenv

次に Homebrew を利用して fvm をインストールします。
# fvmのGitHubリポジトリをHomebrewに追加
$ brew tap leoafarias/fvm
# fvmをインストール
$ brew install fvm

これで fvm のインストールは完了です。

fvmを利用したFlutterのインストール
続いて、fvm を利用して最新安定版の Flutter およびそれに対応した Dart の
環境をインストールしましょう。インストール可能な Flutter バージョンをタ
ーミナルから確認します。

13

第

1 環境構築とアプリの実行
章

Flutter SDK、Android Studio、Xcode

# インストール可能なFlutterバージョンを出力
$ fvm releases

stable と書かれたバージョンが最新の安定版となります。執筆時点のコマ
ンド実行結果を以下に示します。最新の安定版は 3.16.9 でした。
.
.
.

（省略）

Nov 30 23
Dec 5 23

│ 3.16.2
│ 3.18.0-0.1.pre

Dec 13 23
Dec 14 23

│ 3.16.4
│ 3.18.0-0.2.pre

Dec 6 23

Dec 20 23
Jan 10 24
Jan 10 24

│ 3.16.3

│ 3.16.5
│ 3.16.6

│ 3.19.0-0.1.pre

Jan 11 24 │ 3.16.7
Jan 17 24 │ 3.16.8
Jan 18 24 │ 3.19.0-0.2.pre
-------------------------------------Jan 25 24 │ 3.16.9
stable
--------------------------------------------------------------------------Jan 26 24 │ 3.19.0-0.3.pre
beta
--------------------------------------

それではバージョン 3.16.9 の Flutter をインストールします。
# バージョン3.16.9のFlutterをインストール
$ fvm install 3.16.9

これで Flutter のインストールは完了です。
後述の「1.4 プロジェクトの作成」の節で、プロジェクトで利用する fvm の

Flutter のバージョンを指定する方法を解説します。その設定が完了すると、
プロジェクトのディレクトリ配下で fvm コマンドを介して Flutter を使用する
ことができます。たとえば、Flutter のバージョン番号を確認するには以下の
ように実行します。
# fvmを経由してFlutterのバージョンを出力
$ fvm flutter --version
# fvmを経由してDartのバージョンを出力
$ fvm dart --version

「1.2 Flutter の環境構築」の節でインストールした Flutter はそのまま残って
14

プロジェクトの作成

1.4

おり、fvm コマンドを使わなければそのまま利用可能です。ちなみに、筆者
は shell のエイリアスを利用して fvm の入力を省略しています。
~/.zshrc

alias flutter="fvm flutter"

なお、第 2 章以降では fvm コマンドを省略して flutter コマンド、dart コマ
ンドを扱います。ご自身の環境、コマンドを実行するディレクトリにあわせ
て読み替えてください。

1.4
プロジェクトの作成
Flutter プロジェクトは Android Studio から GUI（Graphical User Interface）で作
成します。

Android Studioでの作成手順
Android Studio のアプリケーションメニューから「File」➡「New」➡「New
Flutter Project」の順で選択すると、ウィンドウが表示されます（図 1.5）。
図 1.5

新規プロジェクトウィンドウ

15

第

1 環境構築とアプリの実行
章

Flutter SDK、Android Studio、Xcode

ウィンドウ左のリストで「Flutter」が選択されていることを確認します。
は図 1.5 のように fvm でインストールした Flutter SDK を選
「Flutter SDK path」
をクリックすると、プロジェクトの詳細を選択する画面に
択します。
「Next」
切り替わります
（図 1.6）。
図 1.6

新規プロジェクトの詳細ウィンドウ

「Project name」は任意の名前でけっこうです。プロジェクトを作成するデ
ィレクトリを変更したい場合は「Project location」を任意に編集してください。
今回は iOS と Android で動作するアプリのプロジェクトを作成するので「Project

type」が Application になっていること、「Platforms」では Android と iOS にチ
ェックが入っていることを確認してください。
「Create」をクリックすると、Android Studio で作成した Flutter のテンプレ
ートプロジェクトが開きます。

テンプレートプロジェクトをのぞいてみよう
作成されたプロジェクトのファイル、ディレクトリは表 1.1 のような構成
になっています。.（ドット）から始まるファイル、ディレクトリや Android

Studio のモジュールファイルなどを直接操作することは少ないかと思います。
16

プロジェクトの作成

表 1.1

1.4

プロジェクトのファイル、ディレクトリ構成

ファイル名、ディレクトリ名 説明
.dart_tool

Dart 言語のツールが配置されるディレクトリ

.idea

Android Studio のプロジェクト設定ファイルが配置されるディレク
トリ

.metadata

Flutter ツールが利用するファイル

analysis_options.yaml コード静的解析のオプションファイル。lint ルールを変更する場合
に編集する
android

Android Studio のプロジェクト。Android ネイティブのコード、し
くみを利用する場合に閲覧、編集する

ios

Xcode のプロジェクト。iOS ネイティブのコード、しくみを利用す
る場合に閲覧、編集する

lib

Flutter の実装ファイルを配置するディレクトリ。Dart の実装ファ
イルはここに配置する

my_app.iml

Android Studio のモジュールファイル

pubspec.lock

パッケージ（ライブラリなど）のバージョンを解決するファイル

pubspec.yaml

Flutter プロジェクトの設定、依存関係を記述するファイル。パッ
ケージ（ライブラリなど）やアセット類はこのファイルに記述する

test

Flutter のテストコードを配置するディレクトリ

fvmの設定
作成したプロジェクトに対して fvm の設定を行います。今回は Flutter のバ
ージョンを 3.16.9 に設定します。プロジェクトのルートディレクトリで以下
のコマンドを実行します。
# プロジェクトで利用するfvmのバージョンを設定
$ fvm use 3.16.9

すると、プロジェクトのルートディレクトリに.fvmというディレクトリが作成さ
れ、その中に Flutter SDK へのシンボリックリンクが配置されます。もし、git でバ
ージョン管理する場合は除外するように.gitignoreを編集しておきましょう。
.gitignore

# 省略
.fvm/flutter_sdk # この行を追加

続いて、Android Studio が参照する Flutter SDK のパスを変更します。Android

Studio を起動し、アプリケーションメニューから「Settings」を選択します。
Settings ウィンドウの検索窓に「Flutter」と入力し、ツリーの中から「Flutter」
を選択します（図 1.7）。「Flutter SDK Path」へ .fvm/flutter_sdk のシンボリッ
クリンクが示している先のパスを入力し、OK ボタンを押します。
17

第

1 環境構築とアプリの実行
章

Flutter SDK、Android Studio、Xcode

図 1.7

Settings ダイアログで Flutter SDK Path を設定

1.5
Flutterアプリの実行
それではさっそくアプリを実行してみましょう。まずは図 1.8 に示す
「Flutter

Device Selection」ボタンから実行デバイスを選択します。

18

Flutterアプリの実行

図 1.8

1.5

A
 ndroid Studio の Flutter Device Selection ボタン
（拡大左）
と実行ボタン
（拡大右）

iOS Simulatorでの実行
「Flutter Device Selection」のボタンをクリックすると「Open iOS Simulator」
という項目があります。これを選択すると iOS Simulator が起動します。

iOS Simulator が起動したら、Android Studio の Navigation Bar にある実行ボ
。
タンをクリックします（図 1.8 の右側）
（図1.9）
。
すると iOS Simulator 上でテンプレートの Flutter アプリが起動します
図 1.9

iOS Simulator で動作する Flutter アプリ

19

第

1 環境構築とアプリの実行
章

Flutter SDK、Android Studio、Xcode

今まで一度も iOS Simulator を起動したことがない環境では、エラーが発生
することがあります。筆者の環境では、Xcode から一度だけ iOS Simulator を
起動すると解決しました。

Xcode から iOS Simulator を起動するには、Xcode のアプリケーションメニ
➡
「Open Developer Tool」➡「Simulator」
の順で選択します。
ューから
「Xcode」

Android Emulatorでの実行
作成済みの Android Emulator を探します。Android Studio のバージョンによ
って、初期状態で Android Emulator が作成されている場合と作成されていな
い場合があります。Android Studio のアプリケーションメニューから「Tools」
を選択します。Device Manager の画面に Emulator が表示
➡
「Device Manager」
されなければ、以下の手順で作成します。
Android Emulatorを作成する

Device Manager の画面で「Create virtual device...」ボタンをクリックします
（図 1.10）
。
図 1.10

Device Manager 画面の Create device ボタン

すると、Android Emulator を作成するウィンドウが表示されます（図 1.11）
。
ボタ
まず、Emulator の画面解像度や仮想ディスプレイサイズを選択し「Next」
20

Flutterアプリの実行

1.5

ンをクリックします。
図 1.11

Android Emulator を作成するウィンドウ

続いて Emulator の API レベルを選択します。本書では API Level 34 を選択
しました。なお、Flutter がサポートしている API レベルは公式ドキュメント
の
「Supported deployment platforms」注 6 で確認できます。
選択した API レベルのシステムイメージをダウンロード、選択し「Next」ボ
タンをクリックします。
最後に Emulator の名前やその他の設定を行う画面に遷移します。特に必要
なければ初期値のまま「Finish」ボタンをクリックします。これで Android

Emulator の作成が完了しました。
Android Emulatorを起動し、
アプリを実行する

iOS のときと同様に「Flutter Device Selection」のボタンをクリックして、作
「Refresh」
を
成した Android Emulator を選択します。リストに現れない場合は
選択してみましょう。

Android Emulator のウィンドウが表示されない場合は、Android Studio のメ
を選択すると起動中
ニューから
「View」➡「Tool Windows」➡「Running Devices」
の Android Emulator が表示されます。
注6

https://docs.flutter.dev/development/tools/sdk/release-notes/supported-platforms

21

第

1 環境構築とアプリの実行
章

Flutter SDK、Android Studio、Xcode

Android Emulator が起動したら実行ボタン（図 1.8）をクリックします。
（図
すると Android Emulator 上でテンプレートの Flutter アプリが起動します
1.12）。
図 1.12

Android Emulator で動作する Flutter アプリ

1.6
まとめ
Flutter の開発環境をインストールし、iOS Simulator と Android Emulator で
アプリが実行できるところまでを体験しました。
マルチプラットフォームであるため環境を整える作業は多くの手順が必要
となりますが、flutter doctor コマンドのようなサポートツールが用意され
ていました。アプリの実行もエディタのプラグインによってスムーズだった
かと思います。これらの優れた開発者体験も Flutter の魅力の一つですね。

22

第

2

章

Dartの言語仕様

23

第

2 Dartの言語仕様
章

Flutter の開発には Dart 注 1 というプログラミング言語を用います。Swift や
Kotlin、Java と同じように静的型付け言語、クラスベースのオブジェクト指
向言語です。2023 年にメジャーアップデートされた Dart 3 ではすべてのコー
ドが null 安全になったほか、Record やパターンマッチングなどの新機能が追
加されました。これらの新機能も解説します。
本章はできるだけ Dart の言語仕様を広く網羅することを目指しましたので
分量が多くなっています。これは「新しいフレームワークに触れるときは、使
用言語を頭にたたき込んでから」
という筆者のスタイルを反映しています。と
はいえ、勉強スタイルは人それぞれですので、本章は必要に応じて読み飛ば
していただいてもかまいません。

2.1
変数宣言
Dart の変数宣言の記述方法はいくつかあります。一つずつ見ていきましょう。

変数と型推論
int age = 0;

この例では int 型の age という変数を整数リテラル 0 で初期化しました。こ
こ で の int の よ う に 変 数 の 型 を 宣 言 す る 部 分 を Dart で は 型 注 釈（Type
Annotation）と呼びます。

Dart は型推論の機能があります。型注釈を省略し代わりに var と記述する
ことで、変数の型を推論させることができます。
var age = 0;

定数 ── finalとconst
変更する予定のない変数は、定数を利用することが推奨されています。定
注1

24

https://dart.dev/

変数宣言

2.1

数として宣言するには final 修飾子を付けます。するとその変数への再代入
はコンパイルエラーとなります。
final int age = 37;

age = 38;
// => Error: Can't assign to the final variable 'num'.注2

また、この場合も型注釈を省略して型推論させることができます。
final age = 37;

final のほか、const という修飾子でも定数を宣言できます。
const int age = 37;

const age = 37; // constも型推論可能

こちらはコンパイル時定数として扱われます。そのため、クラス変数など
は const 宣言することはできません（静的なクラス変数であれば可能）
。
また、final で宣言されたクラスのフィールドは変更可能ですが、const で
宣言されたクラスのフィールドは変更不可です。クラスについては「2.12 ク
ラス」で詳しく解説します。

いろいろな初期値の与え方
変数は必ずしも宣言時に初期化される必要はありません。利用時までに初
期化されていれば OK です。初期化済みかどうかは Dart コンパイラが判断し
てくれます。
final flag = DateTime.now().hour.isEven;
final int number; // 宣言時に初期化しない（この場合もfinalで宣言可能）
if (flag) {
number = 0;
} else {
number = 255;
}
print(number); // 必ず初期化されているのでOK

以下のように利用時までに初期化が保証されていないコードはコンパイル
エラーとなります。

注2

本書では、コードやコマンドのコンパイル結果や実行結果などを「// =>」というコメント表記で示
しています。

25

第

2 Dartの言語仕様
章

final userName = 'steve';
int number; // 宣言時に初期化しない
if (userName == 'joe') {

number = 0;
} else if (userName == 'john') {
number = 255;

} // else ケースがない
print(number);
// => Error: Non-nullable variable 'num' must be assigned before it can be used.

遅延初期化

変数の初期化を Dart コンパイラが必ずしも正しく判断できない場合もあり
ます。たとえば、グローバル変数の初期化などがそれにあたります。
そのようなときは late 修飾子を付与することでコンパイラのチェックを回
避できます。
late String globalVariable; // 宣言時に初期化しない
void main() {
globalVariable = 'initialized';
print(globalVariable);
// => initialized
}

final late のように late 修飾子と final 修飾子を併用し、一度初期化され
たら変更不可にすることもできます。
また late 修飾子は、宣言時に初期化処理を記述すると、変数にアクセスさ
れるまで初期化処理を遅延することができます。以下の例では変数 variable
にアクセスするまで、初期値を計算する highCostFunction は実行されません。
late String variable = highCostFunction();

使用されるかどうかわからない変数や、初期化処理の実行コストが高い場
合に用いると効果的です。
late 修飾子を使う場合は、未初期化の変数にアクセスすると実行時エラー
となりますので利用には注意が必要です。

26

組み込み型

2.2

2.2
組み込み型
Dart の代表的な組み込み型を紹介します。

数値型
数値型を表現する型は整数型として int クラス、浮動小数型として double
クラス、以上の 2 つが用意されています。どちらも共通のスーパークラス num
を継承しています。
int ── 整数型

符号付整数型として int クラスが提供されています。bit サイズはプラット
フォームごとに異なります。昨今の iOS と Android を対象とするなら 64bit の
みと考えて差し支えないでしょう。
以下は int クラスとして推論される整数リテラルです。
final x = 1;
final hex = 0xFF; // 16進数リテラル
final exponent = 1e5; // 指数リテラル

double ── 浮動小数型

64bit 浮動小数型として double クラスが提供されています。
以下は double クラスとして推論される小数リテラルです。
final y = 1.1;
final exponents = 1.42e5; // 指数表記も可

String ── 文字列型
文字列型として String クラスが提供されています（その他、本書では詳し
く解説しませんが、UTF-16 コードポイントのコレクションとして Runes クラ
ス、（書記素クラスタによる）
部分文字のコレクションとして Characters クラ
スがあります）。
String クラスとして推論される文字列リテラルは、ダブルクオートとシン
27

第

2 Dartの言語仕様
章

グルクオートどちらも対応しています。
final str1 = 'Hello, Dart!';
final str2 = "Hello, Dart!";

文字列リテラルに変数の値を挿入することもできます。変数名の前に $ を
置きます。式の結果を挿入する場合は ${} で式を囲います。
final name = 'dart';
final str1 = 'Hello, $name!';
print(str1);

// => Hello, dart!
final str2 = 'Hello, ${name.toUpperCase()}!';
print(str2);
// => Hello, DART!

隣接する文字列リテラルは自動的に連結されます。+ 演算子で連結を明示
することもできます。
final message1 = 'Hello, ' 'Dart!';
print(message1);
// => Hello, Dart!
final message2 = 'Hello, ' // 改行してもOK
'Dart!';
print(message2);
// => Hello, Dart!
final message3 = 'Hello, ' +
'Dart!';
print(message3);
// => Hello, Dart!

複数行の文字列を定義するには三重のダブルクオート、または三重のシン
グルクオートが便利です。
final message1 = "<div>\n <p>Hello, Dart!</p>\n</div>";
final message2 = """
<div>
<p>Hello, Dart!</p>
</div>
""";
final message3 = '''
<div>

28

組み込み型

2.2

<p>Hello, Dart!</p>

</div>
''';

文字列リテラルの前に r を置くことで、改行文字などの特殊文字の解釈が
無効にできます。
final message1 = 'Hello,\nDart!';
print(message1);
// => Hello,
// => Dart!

final message2 = r'Hello,\nDart!';
print(message2);
// => Hello,\nDart!

bool ── 論理型
論理型として bool クラスが提供されます。

bool 型のリテラルとして true と false があります。
final flag1 = true;
final flag2 = false;

List ── 配列
配列に相当する順序付きコレクションには、Dart では List クラスが用意さ
れています。リテラル表現は以下です。各要素をカンマ（,）
で区切り、大括弧
（[ ]）で囲います。
final list1 = [0, 1, 2, 3];
final list2 = [0, 1, 2, 3,]; // 末尾にカンマを付与してもOK

List の要素の型は推論され、型の異なる要素を追加しようとするとコンパ
イル時にエラーとなります。
final intList = [0, 1, 2, 3];
intList.add(4); // OK
intList.add('abc'); // => Error: The argument type 'String' can't be assigned to
the parameter type 'int'.

List の要素の型を明示するには以下のように型注釈を記述します。

29

第

2 Dartの言語仕様
章

final list = <int>[0, 1, 2, 3];

なお、List には可変長と固定長の 2 種類が存在します。リテラルで作られ
るのは可変長 List になります。List の名前付きコンストラクタ unmodifiable
を使うと、その List は固定長となります（名前付きコンストラクタは「2.12 ク
ラス」で解説します）。固定長 List の要素数を変更しようとすると実行時エラ
ーとなります。
final baseList = [0, 1, 2, 3,];

final fixedLengthList = List.unmodifiable(baseList); // baseListを元に固定長の新
しいインスタンスを生成
fixedLengthList.add(4); // 実行時エラー

Set ── 集合
順序が保持されない、要素が重複しないコレクションとして Set クラスが
用意されています。リテラル表現は以下です。各要素をカンマ（,）
で区切り、
中括弧（{ }）で囲います。
final map1 = { 'Apple', 'Orange', 'Grape' };
final map2 = { 'Apple', 'Orange', 'Grape', }; // 末尾にカンマを付与してもOK

Set の要素の型は推論され、型の異なる要素を追加しようとするとコンパイ
ル時にエラーとなります。
final fruits = { 'Apple', 'Orange', 'Grape' };
fruits.add('Cherry'); // OK
fruits.add(123); // => Error: The argument type 'int' can't be assigned to the pa
rameter type 'String'.

Set の要素の型を明示するには以下のように型注釈を記述します。
final fruits = <String>{ 'Apple', 'Orange', 'Grape' };

Map ── 連想配列
連想配列や辞書に相当する key-value ペアとして Map クラスが用意されてい
ます。他の多くの言語と同様にキーは重複しません。キーとバリューの型に
制限はありません。リテラル表現は以下です。キーとバリューはコロン（:）
、
30

組み込み型

2.2

要素はカンマ（,）
で区切り、全体を中括弧
（{ }）で囲います。
final map1 = {

200: 'OK',
403: 'access forbidden',
404: 'not found'

};
final map2 = {
200: 'OK',

403: 'access forbidden',
404: 'not found', // 末尾にカンマを付与してもOK

};

List や Set と同様にキーやバリューの型は推論され、型の異なる要素を追加
しようとするとコンパイル時にエラーとなります。
final statusCodes = {

200: 'OK',
403: 'access forbidden',
404: 'not found'

};

statusCodes[204] = 'No Content'; // OK
statusCodes['204'] = 'No Content'; // => Error: A value of type 'String' can't be
assigned to a variable of type 'int'.

Map の要素の型を明示するには以下のように型注釈を記述します。
final statusCodes = <int, String>{
200: 'OK',
403: 'access forbidden',
404: 'not found'
};

Set と Map はリテラルが似ていますが、以下は Map として推論されます。
final setOrMap = {};
print(setOrMap is Map); // is演算子で型を確認
// => true

Record ── タプル
Record は複数の値を集約した不変の匿名型を表現します。他の多くの言語
にあるタプル型によく似ています。
Record の初期化はカンマ
（,）区切りでフィールドを記述し括弧
（( )）
で囲い
ます。
31

第

2 Dartの言語仕様
章

final record1 = (300, 'cake');

Record の型注釈はカンマ（,）区切りでフィールドの型注釈を記述し括弧（(
)）
で囲います。
final (int, String) record2 = record1;

フィールドに名前を付与することもできます。名前を付けたフィールドを
「名前付きフィールド」
、名前を付けないフィールドを「位置フィールド」
と呼
びます。型注釈では名前付きフィールドを中括弧
（{ }）で囲います。
final record1 = (price: 300, name: 'cake');

// 型注釈では名前付きフィールドを中括弧で囲う
final ({int price, String name}) record2 = (price: 300, name: 'cake');

名前付きフィールドの記述順は等値性に影響を与えません。
final record1 = (price: 300, name: 'cake');
final record2 = (name: 'cake', price: 300);
print(record1 == record2);
// => true

型注釈の中では位置フィールドに名前を付与することができます。その名
前はフィールドの等値性に影響を与えません。
// 左辺、Recordの型注釈でフィールドに名前を付与している
// 中括弧で囲っていないので名前付きフィールドではない
final (int price, String name) record1 = (300, 'cake');
final (int x, String y) record2 = (300, 'cake');
print(record1 == record2);
// => true

名前付きフィールドと位置フィールドを混在させることが可能です。その
場合、型注釈では位置フィールドが常に先頭に配置されます。
// 99のみが位置フィールド
final record1 = (price: 300, name: 'cake', 99);
// 型注釈では位置フィールドが先頭
final (int count, {String name, int price}) record2 = record1;

名前付きフィールドは、同名のゲッタから読み取りが可能です。位置フィ
ールドは $ に続けて引数の順序のゲッタが作られます。なお、Record は不変
なためセッタはありません（ゲッタ、セッタについては「2.12 クラス」で解説
します）
。
32

組み込み型

2.2

final record = (price: 300, name: 'cake', 99);
print(record.price);
// => 300

print(record.name);
// => cake
print(record.$1);
// => 99

Objectクラス ── すべてのクラスのスーパークラス
Object クラスは Dart のすべてのクラスのスーパークラスです（スーパーク
。代表的な用途は、型の
ラスや継承については「2.12 クラス」で解説します）
異なる要素を持ったコレクションを扱う場合です。この例では、変数 list は
List<Object> 型に推論されます。
final list = [
0,
'abc',
true,
];

近い表現に dynamic という型があるので紹介します。
final List<dynamic> list = [
0,
'abc',
true,
];

dynamic は特殊な型で、コンパイル時に型のチェックが行われません。存
在しないメソッドを呼び出すようなコードであってもコンパイルエラーにな
りませんし、null かどうかの判断もされません（null については「2.9 null 安全」
で解説します）。よって、実行時エラーのリスクが高まります。明確な理由が
ない限り、dynamic の利用は避け Object または Object?（この ? の文法は「2.9

null 安全」で解説します）を利用すべきです。

33

第

2 Dartの言語仕様
章

2.3
ジェネリクス
他の多くの言語と同じように、Dart にもジェネリクスの機能があります。
型をパラメータ化し、特定の型に依存しない汎用的な実装を行うことができ
ます。すでに紹介した List や Map は、要素の型をパラメータとして受け取る
ジェネリック型です。
final List<int> intList = [0, 1, 2]; // intのリスト

final stringList = <String>['a', 'b', 'c']; // Stringのリスト

ジェネリッククラス
型名のあとに括弧（< >）で型のパラメータ名を与えます。慣習的に T など 1
文字で表現します。クラス内で型のパラメータ名を実際の型名のように扱う
ことができます。
// Tが型のパラメータ名
class Foo<T> {
// フィールド `_value`の型をパラメータ名Tで宣言
T _value;
Foo(this._value);

}

// 戻り値の型をパラメータ名Tで宣言
T getValue() {
return _value;
}

final intFoo = Foo(3);
print(intFoo.getValue());
// => 3
final stringFoo = Foo('hoge');
print(stringFoo.getValue());
// => hoge

34

演算子

2.4

ジェネリック関数
ジェネリクスな関数は関数名のあとに型パラメータ名を記述します。型パ
ラメータは戻り値、引数、またローカル変数で使用可能です。
// `T?`はT型またはnullを表す

T? firstOrNull<T>(List<T> list) {
if (list.isEmpty) {
return null;

}

}
return list[0];

final list1 = [1, 2, 3];

print(firstOrNull(list1));
// => 1
final list2 = <String>[];
print(firstOrNull(list2));
// => null

2.4
演算子
他の多くの言語と同じように扱えるものを中心に、Dart のオペレータの一部
を紹介します。他の言語機能と併せて解説すべきものは別の項で紹介します。

算術演算子
和算や乗算などの四則演算を行う演算子は他の多くの言語と同じように扱
うことができます。
print(2 + 3);
// => 5
print(2 - 3);
// => -1
print(2 * 3);
// => 6
print(5 / 2);

35

第

2 Dartの言語仕様
章

// => 2.5

print(5 % 2);
// => 1

インクリメント、デクリメントについても他の多くの言語と同じように扱
うことができます。
int a;
int b;
a = 0;

b = ++a;
print("$a, $b");
// => 1, 1
a = 0;

b = a++;

print("$a, $b");
// => 1, 0
a = 0;
b = --a;
print("$a, $b");
// => -1, -1
a = 0;
b = a--;
print("$a, $b");
// => -1, 0

比較演算子
比較演算についても、他の多くの言語と同じように扱うことができます。
print(2 == 2);
// => true
print(2 != 1);
// => true
print(10 > 2);
// => true
print(2 < 10);
// => true
print(5 >= 5);
// => true
print(5 <= 5);
// => true

36

演算子

2.4

== オペレータはデフォルトの動作は参照の比較です。オーバーライドして
同値性を指定することも可能です。また、両方が null の場合は true、一方の
みが null の場合は false となります。

三項演算子
Dart は以下の三項演算子が利用できます。
条件式 ? 式1 : 式2
条件式が true なら式 1 が評価され戻り値となり、false なら式 2 が評価され
戻り値となります。
int a = 128;

int b = 256;
final max = a > b ? a : b;
print(max);
// => 256

カスケード記法
カスケード記法は同じオブジェクトに対して、繰り返し操作を行うときに
（..）
便利な記述方法です。オブジェクトのメソッドやプロパティへドット 2 つ
でアクセスすると、そのオブジェクトそのものが戻り値となります。
final sb = StringBuffer()
..write('Hello');
print(sb.toString());
// => Hello

上の例では StringBuffer のインスタンスを生成し write メソッドを呼び出
しました。write メソッドの戻り値は void 型ですが、カスケード記法で呼び
出しているため、変数 sb には StringBuffer のインスタンスが代入されます。
以下のように、同じインスタンスに繰り返しアクセスする場合に便利です。
final sb = StringBuffer()
..write('Hello')
..write(', ')
..write('Dart!!');
print(sb.toString());
// => Hello, Dart!!

37

第

2 Dartの言語仕様
章

コレクションのオペレータ
List、Set、Map のリテラルでのみ利用できるオペレータです。
Spread演算子

複数のコレクションを結合する際に便利なオペレータです。コレクション
リテラル内で ... を記述すると、そのコレクションの要素が展開されます。
final list1 = [0, 1, 2, 3];

// list1はその要素が展開され、list2の要素となる
final list2 = [-1, ...list1];
print(list2);

// => [-1, 0, 1, 2, 3]

制御構文演算子

コレクションのリテラル内で if や for が記述できます。要素を追加する条
件を記述したり、他のコレクションを追加したりする際に前処理を行うこと
ができます。
// flagがtrueのときのみ、3を追加
final list = [0, 1, 2, if (flag) 3];
final list1 = [1, 2, 3];
// list1の要素を2倍したものを追加
final list2 = [0, for (var i in list1) i * 2];
print(list2);
// => [0, 2, 4, 6]

38

制御構文

2.5

2.5
制御構文
分岐やループなどの制御構文です。

分岐
if文

他の多くの言語と同じように、Dart では if 文が利用できます。else および
else if は必須ではありません。中括弧（{ }）は実行処理が 1 文の場合に省略
可能です。
final now = DateTime.now();
if (now.hour >= 6 && now.hour < 13) {
print('Good morning');
} else if (now.hour >= 13 && now.hour < 18) {
print('Good afternoon');
} else {
print('Good evening');
}

条件式は bool 型以外を if などの条件分岐に利用することはできません。
final number = 0;
if (number > 0) { // OK
print('number is greater than 0');
}
if (number) { // => Error: A value of type 'int' can't be assigned to a variable
of type 'bool'.
print('number is true');
}

if-case文

if-case 文はパターンのマッチングと併せて変数へ分解する文法です（パタ
。以下の例は
ーンと分解宣言については
「2.6 パターン」で詳しく解説します）
Record の フ ィ ー ル ド が null で な い こ と を 判 定 し、変 数 message と 変 数
statusCode に分解しています。いずれかが null の場合には else 節が実行され
ます。
39

第

2 Dartの言語仕様
章

final (String?, int?) response = ('OK', 200);

if (response case (String message, int statusCode)) {
print('Response: message = $message, statusCode = $statusCode');
} else {
}

print('No response received.');

// => Response: message = OK, statusCode = 200

さらに、when キーワードに続けて条件式を記述することもできます。
final (String?, int?) response = ('OK', 200);

if (response case (String message, int statusCode) when statusCode == 200) {
// messageが非nullかつ、statusCodeが200のときのみ、メッセージを出力
print('Response: message = $message, statusCode = $statusCode');

} else {
print('No response received.');
}

// => Response: message = OK, statusCode = 200

switch文

Dart の switch 文では、ケースに一致すると処理が実行され switch 文から
抜けます。途中で switch 文を抜けるには break が使え、switch 文のあとの処
理を続けて実行します。または、switch 文が記述されたスコープから抜ける
効果として return や throw を使うこともできます（throw と例外処理について
は「2.11 例外処理」で解説します）。ケースの処理が空の場合は次のケースに
抜けます（フォールスルーと言います）。どのケースにも一致しない場合は
default が実行されます。
final String color = // 省略
switch (color) {
case 'red':
doSomethingIfRed();
case 'blue':
doSomethingIfBlue();
case 'black':
break; // switch文を抜ける
case 'green':
case 'yellow':
doSomethingIfGreenOrYellow(); // greenとyellowのときに実行される
default:
throw 'Unexpected color';
}

continue 文とラベルを使い、ケースの順に関係なくフォールスルーするこ
40

制御構文

2.5

とが可能です。
final String color = // 省略
switch (color) {
case 'red':

doSomethingIfRed();

continue other;
case 'blue':

doSomethingIfBlue();
other:
case 'black':
}

throw 'Unexpected color'; // redとblackのときに実行される

switch 文も when キーワードに続けて条件式を追加することができます。
final int? statusCode = null;

switch (statusCode) {
case (int statusCode) when 100 <= statusCode && statusCode < 200:
print('informational');
case (int statusCode) when 200 <= statusCode && statusCode < 300:
print('successful');
case (int statusCode) when 300 <= statusCode && statusCode < 400:
print('redirection');
case (int statusCode) when 400 <= statusCode && statusCode < 500:
print('client error');
case (int statusCode) when 500 <= statusCode && statusCode < 600:
print('server error');
case (null):
print('no response received.');
default:
print('unknown status code');
}
// => no response received.

式としてのswitch

switch を式として扱うことができます。以下の例は数値 statusCode の値に
応じて、メッセージ文字列を生成しています。
final int statusCode = // 省略
final message = switch (statusCode) {
>= 100 && < 200 => 'informational',
>= 200 && < 300 => 'successful',
>= 300 && < 400 => 'redirection',
>= 400 && < 500 => 'client error',
>= 500 && < 600 => 'server error',

41

第

2 Dartの言語仕様
章

_ => 'unknown status code',

};
print(message);

式としての switch は次のような文法となります。
・ケースは case キーワードではじまらない
・ケースの処理は単一の式
・空のケースは記述できない
・ケースのパターンと処理の区切りは : ではなく =>
・ケースは , で区切る
・デフォルトのケースは _（ワイルドカード表記）
で記述する

ループ
for文

他の多くの言語と同じように、Dart では for 文が利用できます。
for (int i = 0; i < 3; ++i) {
print('index = $i');
}
// => index = 0
// => index = 1
// => index = 2

順番にアクセスできるコレクションの Iterable クラスがあります。List や
Set のスーパークラスです。この Iterable は for-in の形式や、
final list = [0, 1, 2];
for (final element in list) {
print('element = $element');
}
// => element = 0
// => element = 1
// => element = 2

forEach メソッドが利用できます。
final list = [0, 1, 2];
list.forEach((element) {
print('element = $element');
});

42

制御構文

2.5

// => element = 0
// => element = 1
// => element = 2

while文

Dart はループの前に条件式を評価する while 文、ループのあとに条件式を
評価する do-while 文の両方が利用できます。
final flag = // 省略
while (flag) {
}

doSomething();

do {

doSomething();
} while (flag);

breakとcontinue

for や while 文は break キーワードでループから抜けます。また、continue
キーワードで次のループへスキップします。
for (int i = 0; i < 10; ++i) {
if (i % 2 == 0) {
continue;
}
if (i > 6) {
break;
}
print('index = $i');
}
// => index = 1
// => index = 3
// => index = 5

43

第

2 Dartの言語仕様
章

2.6
パターン
Dart にパターンという構文があります。パターン構文にはオブジェクトの
マッチングと分解宣言の 2 つの機能があります。
マッチングはオブジェクトが特定の形式であるかを判断する機能です。以
下は値がリテラルと一致するかを判定するパターンです。
final name = // 省略

switch (name) {
case 'john': // nameが'john'と一致するか判定
}

doSomething();

分解宣言はオブジェクトをいくつかの変数に分解する機能です。以下は
Record のフィールドをそれぞれ変数に分解します。
final record = ('cake', 300);
final (name, price) = record; // recordをnameとpriceに分解
print('This $name is $price yen.');
// => This cake is 300 yen.

パターンはいくつか種類があり、使える場所も異なります。そこで、本書
ではパターンを以下のように分類し、それぞれを解説します。
❶マッチング機能しか持たないパターン
❷マッチングと分解宣言の 2 つの機能を持つパターン
❸パターンを補助する構文

マッチング機能しか持たないパターン
マッチング機能しか持たないパターンは switch 文、または式としての
switch、if-case 文で利用できます。変数の宣言には利用できません。
論理演算子、比較演算子

and（&&）、or（||）、== などの演算子を使ってパターンを記述できます。こ
れらのパターンはマッチング機能しか持たないため変数の宣言には利用でき
ません。
44

パターン

2.6

final int statusCode = // 省略

final message = switch (statusCode) {
>= 100 && < 200 => 'informational',
>= 200 && < 300 => 'successful',

>= 300 && < 400 => 'redirection',
>= 400 && < 500 => 'client error',
>= 500 && < 600 => 'server error',
_ => 'unknown status code',

};

print(message);

一致判定

リテラルや定数との一致判定をパターンとして記述できます。このパター
ンはマッチング機能しか持たないため変数の宣言には利用できません。
リテラルであれば、数値、bool、文字列リテラルが利用可能です。
switch (variable) {
case 123:
print('123');
case 'str':
print('str');
case false:
print('false');
}

コレクションの一致判定ではリテラルに const 修飾子を付与する必要があ
ります。
switch (variable) {
case const [0, 1, 2]:
print('list');
case const {0, 1, 2}:
print('set');
case const {'key': 0}:
print('map');
}

const や static を付与した定数も利用できます。
switch (variable) {
case double.maxFinite:
print('maxFinite');
case const SomeClass():
print('SomeClass');
}

45

第

2 Dartの言語仕様
章

マッチングと分解宣言の2つの機能を持つパターン
マッチングと分解宣言の 2 つの機能を持ち、マッチした際に変数にバイン
ドするパターンです。前項の「マッチング機能しか持たないパターン」
と同様
に switch 文、または式としての switch、if-case 文で利用できます。さらに、
変数の宣言や for 文や for-in 文でも利用できます。
List

List のパターンは var または final からはじまり、List リテラルのように大
括弧
（[ ]）で囲い、中に分解宣言する変数を記述します。

List 型を分解宣言する場合は要素数が一致している必要があります。ただ
し、... を記述すると任意の長さをマッチさせることができます。
final [a, b, ..., c] = [0, 1, 2, 3, 4, 5];
print('a = $a, b = $b, c = $c');
// => a = 0, b = 1, c = 5

ちなみに、Set はパターンが利用できません。
Map

Map のパターンは var または final からはじまり、Map リテラルのように中
括弧
（{ }）で囲い、キーとバリューを : で区切ります。キーが一致するとバリ
ューが変数にバインドされます。

Map を分解宣言する場合はマップ全体と一致する必要はありません。パタ
ーンに存在しないキーは無視されます。
final { 200: successful, 404: notFound } = {
200 : 'OK',
404 : 'Not Found',
500 : 'Internal Server Error',
};
print('200 -> $successful, 404 -> $notFound');
// => 200 -> OK, 404 -> Not Found

Record

Record はすべての構造が一致する必要があります。名前付きフィールドは
パターンにもフィールド名を含める必要があります。
final record = (name: 'cake', price: 300);
// パターンにもフィールド名を含めているのでマッチする

46

パターン

2.6

final (name: n, price: p) = record;
print('This $n is $p yen.');
// => This cake is 300 yen.

// フィールド名がないのでマッチしない
final (String name, int price) = record;

フィールド名を変数名で推論させる記法もあります。
final record = (name: 'cake', price: 300);

// `:`に続けてフィールド名と同じ名前の変数を宣言
final (:name, :price) = record;
print('This $name is $price yen.');
// => This cake is 300 yen.

Object

その他のクラスをマッチさせることも可能です。クラスのゲッタから分解
宣言できます。
class SomeClass {
const SomeClass(this.x);
final int x;
}
final someInstance = SomeClass(123);
final SomeClass(x: number) = someInstance;
print('x = $number');
// => x = 123

こちらもゲッタ名を変数名で推論させることができます。
class SomeClass {
const SomeClass(this.x);
final int x;
}
final someInstance = SomeClass(123);
final SomeClass(:x) = someInstance;
print('x = $x');
// => x = 123

このパターンはオブジェクト全体と一致する必要はありません。変数への
バインドを省略すれば、クラスの一致だけでマッチさせることも可能です。
final variable = // 省略
switch (variable) {
case SomeClass():

47

第

2 Dartの言語仕様
章

print('SomeClass');

}

case String():
print('String');

Tips for-in文での分解宣言
for-in 文で分解宣言を利用する例をここで紹介します。Record のリストを

for-in 文で処理するときに、Record のフィールドを変数にバインドしてみまし

ょう。

final sweets = [

(name: 'cake', price: 300),
(name: 'dango', price: 250),

];

for (final (:name, :price) in sweets) {
print('name = $name, price = $price');
}
// => name = cake, price = 300
// => name = dango, price = 250

このように、in の前に分解宣言を使って変数にバインドすることができます。
Map の場合はというと、Iterable のサブクラスではないため for-in 文でルー

プを回すことができません。ただし、Map の entries プロパティを使えば、キー

とバリューのペアを変数にバインドしてループを回すことができます。
final map = {
200 : 'OK',
404 : 'Not Found',
500 : 'Internal Server Error',
};
/* ◆ MapEntry
キーとバリューを持ったMapの要素 */
// entriesプロパティでIterable<MapEntry>を取得できる
for (var MapEntry(key: key, value: value) in map.entries) {
print('code: $key, $value');
}
// => code: 200, OK
// => code: 404, Not Found
// => code: 500, Internal Server Error

これは「Map の分解宣言」というより、MapEntry を Object として分解宣言して
いることになります。少しややこしいので、Tips として紹介しました。

48

パターン

2.6

パターンを補助する構文
ここまで紹介したパターンと組み合わせ使うことで効果を発揮する記述方
法を紹介します注 3。
キャスト

分解宣言で変数に渡す際に、as 演算子を使い値をキャストします。キャス
トに失敗すると実行時エラーとなります。
final List<Object> list = [0, 'one'];

final [number as int, str as String] = list;

nullチェック

値が非 null かどうかをチェックするパターンです。変数名の後ろに ? を付
与します。when キーワードと組み合わせて非 null の場合にさらに条件を加え
るような書き方ができます。
int? code = // 省略
switch (code) {
case final i? when i >= 0:
doSomething();
default:
print('code is null or negative');
}

nullアサーション

null アサーションパターンは値が null だった場合に実行時エラーとなりま
す。変数名の後ろに ! を付与します。
int? code = // 省略
switch (code) {
case final i! when i >= 0:
doSomething();
default:
print('code is negative');
}

注3

本書ではパターンを補助する構文として紹介していますが、Dart の公式ドキュメントではパター
ンの一種として扱われています。

49

第

2 Dartの言語仕様
章

ワイルドカード

_ と記述するとワイルドカードパターンとなります。変数にバインドさせ
ることなく、プレースホルダとして機能します。
final record = ('cake', 300);
final (name, _) = record;
print('name = $name');
// => name = cake

ワイルドカードパターンに型注釈を付与すると、クラスの一致だけでマッ
チさせることも可能です。
final variable = // 省略
switch (variable) {
case SomeClass _:

print('SomeClass');

}

case String _:
print('String');

2.7
例外処理
Dart の例外処理です。他の多くの言語と同様に throw キーワードで例外を
スローし、try-catch 構文で例外を捕捉します。例外が捕捉されなければプ
ログラムは中断します。ただし、Flutter はフレームワークが例外を捕捉する
機構を持っているため、例外がスローされてもアプリは終了しません（意図的
に終了させることはできます）。
void doSomething() {
throw MyException();
}
try {
doSomething();
} catch (e) {
print(e);
}

50

例外処理

2.7

例外の型 ── ErrorとException
Dart には Error 型と Exception 型があり、それぞれ throw キーワードで例外
としてスローすることができます。
Error 型はプログラムの失敗によりスローされるものとされています。間
違った関数の使い方や、無効な引数が渡された場合など、プログラム上の問
題に使用されます。呼び出し元で捕捉する必要のないものです。
一方、Exception 型は捕捉されることを目的にしたクラスで、エラーに関
する情報を持たせるべきとされています。

Dart は以上 2 つのタイプのほかに任意のオブジェクトを例外としてスロー
することも可能ですが、製品レベルのコードでは推奨されていません。

例外の捕捉
捕捉する例外の型を指定する場合は on キーワードを使用します。
try {
doSomething();
} on MyException {
print('catch MyException');
}

例外オブジェクトを受け取りたい場合は catch キーワードを使用します。
catch の第一引数は例外オブジェクト、第二引数はスタックトレースです。第
二引数は省略可能です。
try {
doSomething();
} catch(e, st) {
print('catch $e');
print('stackTrace $st');
}

捕捉する型を指定しつつ、例外オブジェクトを受け取る場合は on と catch
を併用します。
try {
doSomething();
} on MyException catch(e) {
print('catch $e');
}

51

第

2 Dartの言語仕様
章

例外の再スロー
例外処理の中で、呼び出し元へ例外を再スローする場合は rethrow キーワ
ードを使用します。
try {

doSomething();
} on MyException catch(e) {
print('catch $e');

}

rethrow; // 呼び出し元へ例外を再スロー

finally句
例外がスローされるかどうかにかかわらず、最後に実行したい処理を finally
句に記述できます。
try {
doSomething();
} on MyException catch(e) {
print('catch $e');
} finally {
doClean();
}

例外に一致する catch 句がない場合は finally 句が実行されたあとに例外が
でん ぱ

呼び出し元に伝播します。

アサーション
プログラムの開発中に思わぬバグが潜んでいないかチェックする機能です。
assert の第一引数へ bool 型の条件を渡します。条件が false の場合にプログ
ラムの実行を中断します。
final variable = nonNullObject();
assert(variable != null); // オブジェクトがnullでないことをチェック
assert(variable != null, 'variables should not be null'); // メッセージを付与する
こともできる

Flutter では debug ビルドのときにだけ assert 文が処理されます。その特徴
を利用し、debug ビルドのときだけ実行したい処理を以下のように記述する
52

例外処理

2.7

ことも可能です。
assert(() {

print('debug mode');
return true;

}());

Flutterの例外処理
Flutter アプリはフレームワークが例外を捕捉する機構を持っており、例外
がスローされてもプログラムが終了するとは限りません。
フレームワークは 2 つの例外ハンドラを提供しています。

Flutter のフレームワーク自身がトリガするコールバック（レンダリング処
理やウィジェットの build メソッドなど）で発生した例外は FlutterError.
onError にルーティングされます。デフォルトではログをコンソールに出力
する動作ですが、コールバックを上書きして独自に処理することも可能です。
void main() {
FlutterError.onError = (details) {
// do something
};
runApp(const MyApp());
}

それ以外の Flutter 内で発生した例外（ボタンのタップイベントハンドラな
ど）は PlatformDispatcher でハンドリングします。
void main() {
PlatformDispatcher.instance.onError = (error, stack) {
print(error);
return true; // 例外を処理した場合はtrueを返す
};
runApp(const MyApp());
}

53

第

2 Dartの言語仕様
章

2.8
コメント
Dart のコメント、およびドキュメントコメントについて解説します。
単一行のコメントは //、複数行のコメントは /* で開始し */ で終了します。
// 引数を2倍にする

int doubleValue(int value) {
return value * 2;
}

/*

以下のように書くこともできる

int doubleValue(int value) => value * 2;

*/

ドキュメントコメントもサポートしています。/// または /** で開始するコ
メントはドキュメントコメントとして扱われます
（/// を採用することが推奨
されています）
。クラスや関数、引数名などを [ ] で囲うとその定義へジャン
プできるようになります。
///
/// 引数の値を2倍にして返す
///
/// この関数は、引数の値を2倍にして返す関数です。
/// 引数を半分にする仮数を返す関数として[half]関数があります。
int doubleValue(int value) {
return value * 2;
}
/**
* 引数の値を半分にして返す
*
* この関数は、引数の値を半分にして返す関数です。
* 引数を2倍にする関数として[doubleValue]関数があります。
*/
double half(double value) {
return value / 2;
}

54

null安全

2.9

2.9
null安全
null許容演算子
Dart ではデフォルトが非 null 許容型です。変数を null 許容型で宣言すると
きは、型注釈の末尾に ? を付与します。null 許容型の変数は初期値を省略する
と null で初期化されます。
int? num; // nullで初期化される

非 null 許容型の変数を null で初期化したり、null を代入することはコンパイ
ルエラーとなります。
int nonnullNumber;
nonnullNumber = null; // => A value of type 'Null' can't be assigned to a variabl
e of type 'int'.
int? nullableNumber;
nullableNumber = null; // OK

null 許容型の変数を扱うには、大きく 3 つのアプローチがあります。

null認識演算子
?. に続けてプロパティやメソッドを呼び出します。変数が null の場合は null
が返却されます。
String? str;
print(str?.length);
// => null

nullアサーション演算子
変数の最後に ! を付与することで、非 null 許容型にキャストできます。た
だし、変数が null の場合は実行時エラーとなります。
String? str = // 省略
print(str!.length);

55

第

2 Dartの言語仕様
章

タイププロモーション
if 文などで null チェックを行い、変数が必ず null でないことが明らかな場合
は自動的に非 null 許容型として扱うことができます。
String? str;

if (str == null) {
return;
}

print(str.length);

そのほかの便利なnull関連演算子
?? オペレータは評価結果が null だった場合に右辺の値を返します。
String? str1 = 'some string';
String? str2 = null;
print(str1 ?? 'null');
// => some string
print(str2 ?? 'null');
// => variable is null.

??= オペレータは変数が null の場合にだけ代入が実行されます。
String? str1 = 'some string';
String? str2 = null;
str1 ??= 'new string';
str2 ??= 'new string';
print(str1);
// => some string
print(str2);
// => new string

56

関数

2.11

2.10
ライブラリと可視性
Dart では 1 つの Dart ファイルをライブラリと呼びます（part 命令文により
。外部のライ
複数のファイルを 1 つのライブラリとして扱う場合もあります）
ブラリの名前空間にアクセスするには import 命令を使用します。
// Dartの組み込みライブラリは dart: スキームを指定します
import 'dart:math';
// それ以外は package: スキームを指定するのが一般的です
import 'package:path/to/file.dart';

Dart には private や public といった可視性をコントロールするキーワード
はありません。デフォルトの振る舞いが public に相当し、クラスや関数は
import 命令によってライブラリの外からもアクセスできます。クラス名や関
数名を _（アンダーバー）ではじめると private として扱われ、外部からアクセ
スできなくなります。

2.11
関数
Dart の関数はトップレベルに定義することができ、Java などとは違い必ず
しもクラスに属している必要はありません。

Dart の関数を見ていきましょう。
String greet(String name) {
return 'Hello, $name';
}

他の多くの言語と記述方法は似ています。この例では、関数 greet() は
String 型を引数にとり、戻り値が String 型の関数です。

引数
引数の宣言方法には、省略可能引数と名前付き引数という 2 つのユニーク
な仕様があります。
57

第

2 Dartの言語仕様
章

省略可能引数

[ ] で囲った引数は省略して呼び出せるようになります。省略可能引数は
省略されると null が渡ります。
void makeColor(int red, int green, int blue, [int? alpha]) {
}

// 省略

makeColor(0xFF, 0x00, 0x33); // 引数alphaを省略して呼び出し
makeColor(0xFF, 0x00, 0x33, 0xFF); // 引数alphaを与えて呼び出し

省略可能引数はデフォルト値を与えることができます。デフォルト値を与
えると、省略可能引数も非 null 許容型とすることができます。
void makeColor(int red, int green, int blue, [int alpha = 0xFF]) {
}

// 省略

makeColor(0xFF, 0x00, 0x33); // 引数alphaを省略して呼び出し
makeColor(0xFF, 0x00, 0x33, 0x88); // 引数alphaを与えて呼び出し

なお、省略可能引数のリストは引数リストの末尾に置く必要があります。
名前付き引数

名前付き引数とは、関数呼び出し時に引数の名前を指定させるしくみです。
名前付き引数は引数リストを中括弧
（{ }）で囲います。
void makeColor({int? red, int? green, int? blue}) {
// 省略
}
// 引数の名前を指定する
makeColor(red: 0xFF, green: 0x00, blue: 0x12);

名前付き引数はデフォルトでは省略可能として扱われます。必須にする場
合は required キーワードを与えます。また、デフォルト値を与えることもで
きます。
void makeColor({required int red, required int green, required int blue, int alph
a = 0xFF}) {
// 省略
}
makeColor(red: 0x78, green: 0x30, blue: 0xBF);

名前付き引数は、引数の順番を変えて呼び出すこともできます。
58

関数

2.11

void makeColor({required int red, required int green, required int blue, int alph
a = 0xFF}) {
// 省略
}

makeColor(blue: 0xBF, green: 0x30, red: 0x78);

なお、名前付き引数のリストは引数リストの末尾に置く必要がありますが、
呼び出し時は位置引数を後方に置いても問題ありません。
// 名前付き引数のリストを末尾に置く

void makeColor(String colorName, {required int red, required int green, required
int blue}) {
}

// 省略

// 呼び出し時は名前付き引数が先頭でも可

makeColor(red: 0x78, green: 0x30, blue: 0xBF, 'purple');

関数の省略記法
関数が 1 つの式からなる場合はアロー演算子を使用した省略記法が利用で
きます。
// 引数を2倍にして返す関数
int doubleValue(int x) {
return x * 2;
}
// 上の関数を省略記法で宣言
int doubleValue(int x) => x * 2;

第一級関数と匿名関数
Dart は第一級関数をサポートした言語です。関数を変数に代入したり、引
数に受け取ったりできます。
// 引数を2倍にして返す関数
int doubleValue(int x) {
return x * 2;
}
// 関数doubleValueを変数fに代入
final int Function(int) f = doubleValue;

59

第

2 Dartの言語仕様
章

final result = f(8);

print("num: $result");
// => num: 16

関数オブジェクトの型は、

戻り値の型 Function(引数リストの型)
と宣言します。もちろん型推論も利用可能です。
また、Dart は名前を持たない匿名関数の機能も利用できます。構文は、

(引数リスト) { 関数の本体 }
のようになります。
先ほどの引数を 2 倍にして返す関数を匿名関数で記述してみましょう。
final int Function(int) f = (x) {
return x * 2;
};
final result = f(8);
print("num: $result");
// => num: 16

Dart の匿名関数はクロージャの性質を持ちます。以下のサンプルは multiple
関数で、引数をキャプチャしたクロージャを生成しています。
Function multiple(int i) {
return (x) => x * i;
}
final f1 = multiple(3);
final f2 = multiple(7);
print(f1(2));
// => 6
print(f2(6));
// => 42

60

クラス

2.12

2.12
クラス
Dart はクラスベースのオブジェクト指向言語です。すべてのオブジェクト
はクラスのインスタンスであり、null 以外のすべてのクラスは Object クラス
のサブクラスです。
クラスの定義は class キーワードに続けてクラス名を記述します。
class Point {

}

int x = 0;
int y = 0;

Point という二次元座標を表すクラスを宣言しました。x と y の初期値をコ
ンストラクタから与える方法を見てみましょう。
class Point {
Point(int xPosition, int yPosition) : x = xPosition, y = yPosition;

}

int x;
int y;

コンストラクタの後ろ、: に続けて初期化リストを記述します。上の例の
ように、コンストラクタ引数を直接初期値として与える記述には糖衣構文が
用意されています。
class Point {
Point(this.x, this.y);

}

int x;
int y;

また、コンストラクタに本体を持たせることも可能ですが、本体が実行さ
れる前に非 null 許容型のクラス変数は初期化済みである必要があります。下
記の Point クラスではコンパイルエラーになります。
class Point {
Point(int xPosition, int yPosition) {
// => Non-nullable instance field 'x' must be initialized.
// => Non-nullable instance field 'y' must be initialized.

61

第

2 Dartの言語仕様
章

x = xPosition;
}

}

y = yPosition;

int x;
int y;

初期化リストでパラメータのアサーションを記述することができます。
class Point {

Point(this.x, this.y) : assert(x >= 0), assert(y >= 0);
final int x;

}

final int y;

ゲッタとセッタ
すべてのインスタンス変数は暗黙的にゲッタを持ちます。final 修飾子の
ないインスタンス変数は暗黙的にセッタを持ちます。
また、プロパティのカスタムゲッタ、セッタを提供する機能があります。
get および set キーワードを利用します。
class User {
User(this.id, this._password);
final int id;
String _password;
// カスタムゲッタ
// パスワードを伏せ字にして返す
String get password => '*******';

}

// カスタムセッタ
// パスワードをハッシュ化して保存する
set password(String newPassword) {
_password = hash(newPassword);
}

いろいろなコンストラクタ
Dart のクラスのコンストラクタを 3 つ紹介します。
62

クラス

2.12

・constant コンストラクタ
・名前付きコンストラクタ
・factory コンストラクタ

なお、コンストラクタを記述しなければ引数なしのデフォルトコンストラク
タが提供されます。
constantコンストラクタ

クラスインスタンスをコンパイル時定数として扱うためには constant コン
ストラクタが必要です。コンストラクタに const キーワードを付与します。イ
ンスタンス変数はすべて再代入不可な final である必要があります。
class Point {

const Point(this.x, this.y);

}

final int x;
final int y;

const point = Point(1, 2);

constant コンストラクタは常にコンパイル時定数を生成するとは限りませ
ん。constant コンストラクタの前に const キーワードを付与する、または const
変数に代入した場合に、常に同じインスタンスが使われます。無駄なインス
タンス生成を避けることができるため、Flutter のパフォーマンス向上に役立
ちます。
class Point {
const Point(this.x, this.y);

}

final int x;
final int y;

final point1 = const Point(1, 2); // constantコンストラクタの前に`const`キーワー
ドを付与
const point2 = Point(1, 2); // `const`変数に代入
final point3 = Point(1, 2);
print('${point1 == point2}'); // point1とpoint2は同じインスタンス
// => true
print('${point1 == point3}');
// => false

63

第

2 Dartの言語仕様
章

名前付きコンストラクタ

コンストラクタに識別子を追加して、名前付きコンストラクタを宣言する
ことができます。クラスに複数のコンストラクタを宣言する場合、特別な意
味を持ったインスタンスを生成する場合などに有効です。
通常のコンストラクタはクラス名で宣言しますが、名前付きコンストラク
タはクラス名 . 識別子の形で宣言します。
class Point {

const Point(this.x, this.y);
const Point.zero() : x = 0, y = 0; // 名前付きコンストラクタ
final int x;

}

final int y;

また、コンストラクタから自クラスの別のコンストラクタを呼び出すこと
も可能です。
class Point {
const Point(this.x, this.y);
const Point.zero() : this(0, 0); // 名前のないコンストラクタを呼び出し
final int x;
final int y;
}

factoryコンストラクタ

必ずしも新しいインスタンスを生成しない場合（キャッシュの利用）
や、初
期化リストに記述できないロジックがある場合は factory コンストラクタを利
用します。コンストラクタに factory キーワードを付与し、コンストラクタ
本体でインスタンスを返す return 文を記述する必要があります。
class UserData {
static final Map<int, UserData> _cache = {};
factory UserData.fromCache(int userId) {
// キャッシュを探す
final cache = _cache[userId];
if (cache != null) {
// キャッシュがあったので返す
return cache;
}
// キャッシュがなかったので新しいインスタンスを生成して返す
final newInstance = UserData();

64

クラス

2.12

_cache[userId] = newInstance;
}

}

return newInstance;

// 省略

クラス継承
Dart の公式ドキュメントではクラス継承のことを「拡張」
（Extend a class）と
呼んでいますが、本書では「継承」と呼ぶこととします。のちほど紹介します
「拡張メソッド」
（Extension methods）と区別するためです。
サブクラスの宣言は extends キーワードに続けてスーパークラスの名前を
記述します。
class Animal {
String greet() => 'hello';
}
class Dog extends Animal {
}
final dog = Dog();
print(dog.greet());
// => hello

スーパークラスを参照するには super キーワードを用います。
class Animal {
String greet() => 'hello';
}
class Dog extends Animal {
String sayHello() => super.greet();
}
Dog dog = Dog();

print(dog.sayHello());
// => hello

スーパークラスのメソッドをオーバーライドする際は、@override アノテ
ーションを付与することが推奨されています。
65

第

2 Dartの言語仕様
章

class Animal {
}

String greet() => 'hello';

class Dog extends Animal {
@override
}

String greet() => 'bowwow';

Animal animal = Dog();
print(animal.greet());
// => bowwow

メソッドのオーバーライドにはいくつかの条件があります。
・戻り値の型がスーパークラスのメソッドの戻り値の型と同じ、またはそのサブ
タイプである
・引数の型がスーパークラスのメソッドの引数の型と同じ、またはそのスーパー
クラスである
・位置パラメータの数が同じである
・ジェネリックメソッドを非ジェネリックメソッドでオーバーライドできない、ま
た非ジェネリックメソッドをジェネリックメソッドでオーバーライドできない

また、戻り値の型が null 許容型のメソッドを非 null 許容型のメソッドでオ
ーバーライドすることもできます。
class Animal {
String? greet() => null; // 戻り値はnull許容型
}
class Dog extends Animal {
@override
String greet() => 'bowwow'; // 戻り値を非null許容型でオーバーライド
}

スーパークラスのコンストラクタ

サブクラスのコンストラクタでは、スーパークラスの引数のないコンスト
ラクタが自動的に呼び出されます。スーパークラスに引数なしコンストラク
タがない場合は、明示的にスーパークラスのコンストラクタを呼び出す必要
があります。
class Animal {
Animal(this.name);
final String name;

66

クラス

2.12

}
class Dog extends Animal {
}

Dog(String name) : super(name);

コンストラクタの後ろ、super キーワードに続けてスーパークラスのコンス
トラクタを呼び出します。上の例のように、コンストラクタ引数をそのままス
ーパークラスのコンストラクタに渡す記述は糖衣構文が用意されています。
class Animal {

}

Animal(this.name);
final String name;

class Dog extends Animal {
}

Dog(super.name);

暗黙のインタフェース
Dart ではすべてのクラスは暗黙的にインタフェースが定義されています。そ
のクラスのすべての関数とインスタンスメンバを持ったインタフェースです。
implements キーワードに続けてインタフェースとして実装する型名を記述
します。
class Animal {
String greet() => 'hello';
}
class Dog implements Animal {
@override
String greet() => 'bowwow';
}
Animal animal = Dog();
print(animal.greet());
// => bowwow

すべてのインスタンスメンバ、メソッドをオーバーライドしなければなら
ない点が、extends キーワードで継承するときとの違いです。

67

第

2 Dartの言語仕様
章

拡張メソッド
既存のクラスへメソッドやゲッタ、セッタを追加することができます。拡
張メソッドは以下のような文法で宣言します。
extension <拡張名> on <拡張対象の型> {
}

...

List 型に要素を入れ替える swap 関数を拡張する例を示します。
extension SwapList<T> on List<T> {

// 引数のインデックスの要素を入れ替える拡張メソッド
void swap(int index1, int index2) {
final tmp = this[index1];

}

}

this[index1] = this[index2];
this[index2] = tmp;

final list = [1, 2, 3];
list.swap(0, 2); // インデックス0と2の要素を入れ替える
print(list);
// => [3, 2, 1]

静的な拡張メソッドを宣言することはできません。ですが、拡張メソッド
から呼び出し可能なヘルパ関数として利用することができます。
extension SwapList<T> on List<T> {
// 静的メソッド（拡張メソッドから呼び出し可能）
static bool noNeedToSwap(List<T> list) {
return list.isEmpty;
}
void swap(int index1, int index2) {
if (noNeedToSwap(this)) { // 拡張メソッド内で静的メソッドを利用するのはOK
return;
}

}

}

final tmp = this[index1];
this[index1] = this[index2];
this[index2] = tmp;

final list = [1, 2, 3];

68

クラス

2.12

// 拡張メソッド以外からは呼び出せない

List.noNeedToSwap(list); // => Error: The method 'noNeedToSwap' isn't defined for
the type 'List'.

拡張名のない拡張メソッドは同一ファイル内でのみ参照可能です。
extension on List<T> {

void swap(int index1, int index2) {
final tmp = this[index1];
this[index1] = this[index2];

}

}

this[index2] = tmp;

mixin ── クラスに機能を追加する
Dart は多重継承を許可していませんが、それに似た言語仕様として mixin
（ミックスイン）
があります。with キーワードに続けてミックスイン名を記述
します。
mixin Horse {
void run() {
print('run');
}
}
mixin Bird {
void fly() {
print('fly');
}
}
class Pegasus with Bird, Horse {
}
final pegasus = Pegasus();
pegasus.run(); // PegasusはHorseのメソッドを持つ
// => run
pegasus.fly(); // PegasusはBirdのメソッドも持つ
// => fly

ミックスイン（上の例では Horse と Bird）はクラスのようにメソッドやフィ
ールドを宣言できます。クラスとの違いは、

69

第

2 Dartの言語仕様
章

・インスタンス化できないこと
・extends キーワードを使って他のクラスから継承できないこと
・コンストラクタを宣言できないこと

です。
ミックスインを宣言する際に、使用するクラスを制限することも可能です。
次の例ではミックスイン Horse と Bird は on キーワードでクラス Animal でしか
使用できないよう制限をしています。この制限によりミックスイン Horse と
Bird 内でクラス Animal のメソッドが利用できます。
class Animal {
}

String greet() => 'hello';

// onキーワードで使用可能なクラスをAnimalに制限
mixin Horse on Animal {
void run() {
greet(); // Animalのメソッドを使用可能
print('run');
}
}
// onキーワードで使用可能なクラスをAnimalに制限
mixin Bird on Animal {
void fly() {
greet(); // Animalのメソッドを使用可能
print('fly');
}
}
class Pegasus extends Animal with Bird, Horse {
}

なお、mixin class で宣言する場合は on キーワードは使えません。

Enum
Dart の列挙型です。
Enumの宣言

列挙型は enum キーワードを使い宣言します。

70

クラス

2.12

enum Shape {
}

circle, triangle, square,

フィールドやメソッド、constant コンストラクタを持った高機能な Enum も
宣言できます。通常のクラスに似た構文ですが、いくつかの条件があります。
・1 つ以上のインスタンスすべてが冒頭で宣言されていなくてはならない
・インスタンス変数は final でなければならない
（mixin で追加されるものも同様）
・コンストラクタは constant コンストラクタまたは factory コンストラクタが宣
言可能
・他のクラスを継承することはできない
・index、hashCode、== 演算子をオーバーライドすることはできない
・values という名前のメンバを宣言することができない
// フィールドやfactoryコンストラクタを持ったEnum
enum Shape {
circle(corner: 0),
triangle(corner: 3),
square(corner: 4);
final int corner;
const Shape({
required this.corner,
});

}

factory Shape.ellipse() {
return circle;
}

// factoryコンストラクタからインスタンスを取得
final ellipse = Shape.ellipse();
// フィールドにアクセス
print(ellipse.corner);
// => 0

Enumの利用

Enum の型名に続きドット（.）のあとに列挙子名でアクセスすることができ
ます。

71

第

2 Dartの言語仕様
章

final myShape = Shape.circle;

assert(myShape == Shape.circle);

各列挙子には宣言された順に index が振られ、ゲッタから取得できます。ま
た列挙子の名前を String 型で取得できる name プロパティも生成されます。
final myShape = Shape.circle;
print(myShape.index);
// => 0
print(myShape.name);
// => circle

Enum の型にはすべての列挙子をリストで得られる values プロパティも生
成されます。
Shape.values.forEach((shape) {
print(shape.name);
});
// => circle
// => triangle
// => square

クラス修飾子
クラス修飾子はクラスやミックスインに付与し、インスタンス化や継承に
制限を与えます。その効果はさまざまありますが、本書では以下のように分
類してみました。
・タイプ 1
インスタンス化、extends キーワードによる継承、implements キーワードによる実
装、これらに制限を与える
・タイプ 2
タイプ 1 以外の効果を持つ修飾子（タイプ 1 の効果を併せ持つ場合もある）

以下はクラス修飾子の一覧です。
・abstract
・base
・final
・interface
・sealed
72

クラス

2.12

・mixin
abstract

abstract 修飾子はタイプ 1 です。
インスタンス化

extends キーワードによる継承

implements キーワードによる実装

×

〇

〇

abstract 修飾子を使って宣言されたクラスは本体のない関数を宣言できま
す。またクラスをインスタンス化できなくなります。
abstract class Animal {
}

String greet(); // 本体のないabstract関数

class Dog extends Animal {
@override
String greet() => 'bowwow';
}
// インスタンス化はできない
// final animal = Animal();
Animal dog = Dog();
print(dog.greet());
// => bowwow

base

base 修飾子はタイプ 1 です（表は自身が宣言されたライブラリ以外での制限
を示しています）。
インスタンス化

extends キーワードによる継承

implements キーワードによる実装

〇

〇

×

base 修飾子を使って宣言されたクラスは自身が宣言されたライブラリ以外
では implements キーワードを使った実装を禁止します。
ライブラリ1

base class Animal {
String greet() {
return 'hello';
}
}

73

第

2 Dartの言語仕様
章

ライブラリ2

// クラスの継承はOK。Dogクラスにもbase修飾子を付与しなければならない理由は後述。
base class Dog extends Animal {
}

// クラスの実装はNG、コンパイルエラー
// base class Cat implements Animal {
//

@override

// String greet() => 'mew';
// }
final animal = Animal(); // インスタンス化はOK
final dog = Dog();

print(dog.greet());
// => hello

implements キーワードを使ったクラスの実装が自身のライブラリ内に限定さ
れるため、プライベートメソッドも含めて実装を強制することになります。base
修飾子を使う目的はプライベートメソッドまで含めて全体の整合性を保つこと
にあります。そのため、base 修飾子を使って宣言されたクラスはライブラリ外
でもbase 修飾子か、同じように実装を制限するクラス修飾子を付与しなければ
なりません。上の例では Dog クラスにもbase 修飾子を付与しています。
ライブラリ1

base class Animal {
void _sleep() {
print('sleep');
}

}

String greet() {
return 'hello';
}

// 同一ライブラリ内であればクラスの実装OK
base class Cat implements Animal {
// 同一ライブラリ内なのでプライベートメソッドもオーバーライドが強制される
@override
void _sleep() {
// 省略
}

74

クラス

2.12

@override

String greet() {
return 'mew';
}

}

interface

interface 修飾子はタイプ 1 です（表は自身が宣言されたライブラリ以外で
の制限を示しています）。
インスタンス化

extends キーワードによる継承

implements キーワードによる実装

〇

×

〇

interface 修飾子を使って宣言されたクラスは自身が宣言されたライブラ
リ以外では extends キーワードを使ったクラスの継承を禁止します。
ライブラリ1

interface class Animal {
String greet() {
return 'hello';
}
}
ライブラリ2

// クラスの継承はNG
// class Dog extends Animal {
// }
// クラスの実装はOK
class Cat implements Animal {
@override
String greet() => 'mew';
}
final animal = Animal(); // インスタンス化はOK
final cat = Cat();
print(cat.greet());
// => mew

implements キーワードを使い、すべてのメソッドを実装する必要がありま
す。常に同じライブラリで実装された既知の実装が呼び出されることが保証
75

第

2 Dartの言語仕様
章

できます。
abstractとinterfaceの組み合わせ

abstractとinterface の 2 つの修飾子を組み合わせると実装を持たない純粋
なインタフェースを定義することが可能になります。interface 修飾子の効果
として、外部のライブラリでは implements キーワードを使ったクラス実装が強
制され、abstract 修飾子の効果として実装を持たない関数を宣言できます。
final

final 修飾子はタイプ 1 です（表は自身が宣言されたライブラリ以外での制
限を示しています）
。
インスタンス化

extends キーワードによる継承

implements キーワードによる実装

〇

×

×

final 修飾子を使って宣言されたクラスは、自身が宣言されたライブラリ
以外ではすべてのサブタイプ化を禁止します。extends キーワードを使った
クラスの継承、implements キーワードを使ったクラスの実装の両方が禁止さ
れます。
ライブラリ1

final class Animal {
String greet() {
return 'hello';
}
}
ライブラリ2

// クラスの継承はNG
// base class Dog extends Animal {
// }
// クラスの実装もNG
// base class Cat implements Animal {
// @override
// String greet() => 'mew';
// }

final animal = Animal(); // インスタンス化はOK

76

クラス

2.12

mixin

mixin 修飾子はタイプ 2 です。
mixin 修飾子を使って宣言されたクラスはミックスインのように扱うこと
が可能でありながら、クラスなのでインスタンス化することができます。た
だし、ミックスインと同様に extends は使えずコンストラクタも宣言できま
せん。
mixin class Horse { // `mixin class`で宣言
}

mixin Bird {
}

class Pegasus with Bird, Horse { // `with`キーワードでHorseをmixin
}
final horse = Horse(); // Horseはインスタンス化可能

sealed

sealed 修飾子はタイプ 2 です。sealed 修飾子を使うとサブタイプを Enum
のように扱うことができます。sealed 修飾子を使って宣言されたクラスは、
自身が宣言されたライブラリ以外ではすべてのサブタイプ化を禁止します。
この点は final と共通していますが、さらにクラス自身が暗黙的に abstract

class として扱われます。
ライブラリ1

sealed class Shape {
abstract int corner;
}
// Shape shape = Shape(); インスタンス化はNG
class Rectangle extends Shape {
@override
int corner = 4;
}
class Triangle extends Shape {

}

@override
int corner = 3;

77

第

2 Dartの言語仕様
章

class Circle extends Shape {
@override
int corner = 0;

}

switch 文ですべてのサブタイプが網羅されていなければ、コンパイラが警
告を出します。
ライブラリ2

// サブクラス化はNG

// class Rectangle extends Shape {
// @override
//

// }

int corner = 4;

final Shape shape = getShepe();
switch (shape) {
case Rectangle():
print('Rectangle');
case Triangle():
print('Triangle');
case Circle():
print('Circle');
}

2.13
非同期処理
Dart の非同期処理です。Future 型と Stream 型、スレッドのようなしくみの
アイソレートについて解説します。

Future型
Dart には非同期処理の結果を取り扱う Future 型があります。
import 'dart:io';
void main() {

78

非同期処理

2.13

Future<String> content = File('file.txt').readAsString();
content.then((content) {
print(content);
}

});

readAsString メソッドは非同期にファイルの内容を読み取り、文字列とし
て返します。戻り値の型は Future<String> 型です。Future の then メソッド
には処理が完了したときに呼び出されるコールバックを渡します。
Future クラスは async、await キーワードと組み合わせることで、同期的な
コードのように記述できます。
import 'dart:io';
Future<void> main() async {

String content = await File('file.txt').readAsString();

}

print(content);

readAsString メソッドの呼び出しに await キーワードを付与しました。こ
れ に よ り、readAsString が 終 了 す る ま で 待 機 し ま す。ま た、戻 り 値 の
Future<String> 型を String 型に自動的に変換します。コールバックのネスト
が減り、コードが簡潔になります。
重要なポイントとして await キーワードは async キーワードを付与したメソ
ッド内でしか使えません。また、async キーワードを付与したメソッドの戻
り値は暗黙的に Future クラスでラップされます。main() の本体に async キー
ワードを付与し、戻り値は Future<void> に変更しています。
エラーハンドリング

Future 型のエラーハンドリングです。catchError メソッドで例外が発生し
たときに呼び出されるコールバックを登録します。
// 戻り値がFuture型、例外をスローする関数
Future<String> fetchUserName() {
var str = Future.delayed(
const Duration(seconds: 1),
() => throw 'User not found.');
return str;
}
fetchUserName()
.then((name) {

79

第

2 Dartの言語仕様
章

print('User name is $name');

})
.catchError((e) {
print(e);

});
// => User not found.

async-await で実行した非同期処理は try-catch 構文で例外を捕捉します。
// 戻り値がFuture型、例外をスローする関数
Future<String> fetchUserName() {
var str = Future.delayed(

const Duration(seconds: 1),

}

() => throw 'User not found.');
return str;

try {

final name = await fetchUserName();
print('User name = $name');
} catch (e) {
print(e);
}
// => User not found.

例外発生時に返す代替の値がある場合は then メソッドの引数 onError で処
理する方法があります。
// 戻り値がFuture型、例外をスローする関数
Future<String> fetchUserName() {
var str = Future.delayed(
const Duration(seconds: 1),
() => throw 'User not found.');
return str;
}
final result = await fetchUserName()
.then((name) {
// fetchUserName関数が正常終了した場合の値を返す
return 'User name is $name';
},
onError: (e, st) {
// fetchUserName関数で例外が発生した場合の値を返す
return 'Unknown user';
},
);
print(result);
// => Unknown user

80

非同期処理

2.13

Stream型
非同期に連続した値を扱う Stream 型です。
import 'dart:io';
void main() {

final file = File('file.txt');

final Stream<List<int>> stream = file.openRead();
stream.listen((data) {

}

print('data: ${data.length} bytes');
});

openRead メソッドはファイルを読み込み、一定のサイズごとにデータを返し
ます。戻り値の型は Stream<List<int>> 型です。Stream は listen メソッドで購
読し、データが通知されたときに呼び出されるコールバックを登録します。
Future クラスと同様に async と await for キーワードと組み合わせること
で、同期的なコードのように記述できます。
import 'dart:io';
Future<void> main() async {
final file = File('file.txt');
final Stream<List<int>> stream = file.openRead();
await for (final data in stream) {
print('data: ${data.length} bytes');
};
}

Stream を for 文に渡し、await キーワードを付与しました。for 文の一時変
数 data には Stream の値である List<int> 型のデータが代入されます。こちら
も await を使うため関数に async キーワードを付与する必要があります。
Streamの購読をキャンセル、
一時停止する

listen メソッドの戻り値は StreamSubscription 型です。cancel メソッドで
購読をキャンセルできます。
import 'dart:io';
void main() {
final file = File('file.txt');
final subscription = file.openRead()
.listen((data) {

81

第

2 Dartの言語仕様
章

}

print('data: ${data.length} bytes');

);

}

Future<void> result = subscription.cancel(); // 購読をキャンセル

cancel を呼び出すと、以降イベントが通知されなくなります。購読がキャ
ンセルされることで、Stream でリソースの解放処理が発生する場合がありま
す。解放処理の完了や例外を検知するために cancel メソッドの戻り値は Future
型となっています。たとえば、ファイルを openRead メソッドで読み込んだ後
に削除するようなケースで利用します。
また、購読を一時停止する pause メソッド、購読を再開する resume メソッ
ドがあります。
import 'dart:io';
Future<void> main() async {
final file = File('file.txt');
final subscription = file.openRead()
.listen((data) {
print('data: ${data.length} bytes');
}
);

}

await Future.delayed(const Duration(seconds: 1));
subscription.pause(); // 購読を一時停止
await Future.delayed(const Duration(seconds: 4));
subscription.resume(); // 購読を再開

Stream型を生成する関数

Stream 型を返す関数を実装するには async* キーワードを使います。関数が
呼び出されると Stream が生成され、Stream が購読されると関数の本体が実行
されます。
import 'dart:io';
Stream<String> languages() async* {
await Future.delayed(const Duration(seconds: 1));
yield 'Dart';
await Future.delayed(const Duration(seconds: 1));
yield 'Kotlin';

82

非同期処理

2.13

await Future.delayed(const Duration(seconds: 1));
yield 'Swift';
await Future.delayed(const Duration(seconds: 1));
}

yield* Stream.fromIterable(['JavaScript', 'C++', 'Go']);

String 型の Stream を生成する関数の例です。yield に続いて String を記述す
ると、その値が戻り値の Stream に通知されます。yield* に続いて Stream を記
述すると、その Stream の値が戻り値の Stream に通知されます。購読がキャン
セルされた際は、次の yield 文が実行されると関数の実行が中断されます。
Streamの終わり

Stream の終了時に処理を実行するには listen メソッドの onDone にコール
バックを渡します。
Stream<String> languages() async* {
await Future.delayed(const Duration(seconds: 1));
yield 'Dart';
await Future.delayed(const Duration(seconds: 1));
yield 'Kotlin';
await Future.delayed(const Duration(seconds: 1));
yield 'Swift';
await Future.delayed(const Duration(seconds: 1));
yield* Stream.fromIterable(['JavaScript', 'C++', 'Go']);
}
void main() async {
languages().listen((language) {
print(language);
}, onDone: () {
print('Done');
});
}
// => Dart
// => Kotlin
// => Swift
// => JavaScript
// => C++
// => Go
// => Done

async - await forを使った場合は、Stream が終了すると for 文から抜けます。

Stream の終了時に実行する処理はシンプルに for 文のあとに書けば OK です。

83

第

2 Dartの言語仕様
章

Stream<String> languages() async* {

await Future.delayed(const Duration(seconds: 1));
yield 'Dart';
await Future.delayed(const Duration(seconds: 1));
yield 'Kotlin';
await Future.delayed(const Duration(seconds: 1));
yield 'Swift';

}

await Future.delayed(const Duration(seconds: 1));
yield* Stream.fromIterable(['JavaScript', 'C++', 'Go']);

Future<void> main() async {

await for (final language in languages()) {
}

}

print(language);

print('Done');

// => Dart
// => Kotlin
// => Swift
// => JavaScript
// => C++
// => Go
// => Done

Stream は購読をキャンセルしない限り終了しない特性を持ったものもあり
得ます。たとえば、Stream.periodic コンストラクタから得られる Stream は
一定の間隔で繰り返し値を通知する Stream を生成します。このような終了し
ない Stream で async - await for を用いると以降の処理が実行されないので
注意が必要です。
Future<void> main() async {
await for (final count in Stream<int>.periodic(const Duration(seconds: 1), (i)
=> i)) {
print(count);
}

}

print('Done!'); // この行は実行されない

エラーハンドリング

Stream の例外を処理するには listen メソッドの onError にコールバックを
渡します。

84

非同期処理

2.13

Stream<String> languages() async* {

await Future.delayed(const Duration(seconds: 1));
yield 'Dart';
await Future.delayed(const Duration(seconds: 1));

}

throw Exception('Some error');

void main() {
languages().listen((language) {
print(language);
}, onError: (e) {
print(e);

});

}
// => Dart

// => Exception: Some error

async - await for を使った場合は、try-catch 構文で例外を捕捉します。
Stream<String> languages() async* {
await Future.delayed(const Duration(seconds: 1));
yield 'Dart';
await Future.delayed(const Duration(seconds: 1));
throw Exception('Some error');
}
Future<void> main() async {
try {
await for (final language in languages()) {
print(language);
}
} catch (e) {
print(e);
}
}
// => Dart
// => Exception: Some error

また、listen メソッドの第四引数 cancelOnError は Stream で例外が発生し
た場合に購読を中止するかどうかを指定できます。デフォルト値は false で、
例外が発生しても購読は継続されます。
StreamController

async* 関数よりも簡単に Stream を生成する方法として StreamController
クラスがあります。
85

第

2 Dartの言語仕様
章

import 'dart:async';
class Counter {

int _count = 0;

StreamController<int> _controller = StreamController<int>();
Stream<int> get stream => _controller.stream;
void increment() {

}

}

_count++;
_controller.add(_count);

Future<void> main() async {

final counter = Counter();
counter.increment();
counter.increment();

counter.stream.listen((i) {
print('count: $i');
});
counter.increment();
}
// => count: 1
// => count: 2
// => count: 3

Counter クラスは内部に StreamController を持ち、increment メソッドが呼
び出されると StreamController に値を送信します。StreamController への値
の送信は add メソッドで行います。async* 関数では関数内で yield を使って
イベントを送信しましたが、StreamController では外部からイベントを送信
できるため、より柔軟に Stream を扱うことができます。
このほか、例外を送信する addError メソッドや、購読されているかどうか
を判定する hasListener プロパティなどがあります。
async* は 購 読 さ れ る ま で 関 数 の 本 体 が 実 行 さ れ ま せ ん。し か し、
StreamController は購読されていなくても add メソッドで値を送信すること
ができ、その値はバッファリングされ購読されたとき一斉に通知されます（購
読の一時停止時も同様にバッファリングされます）。そのため、用途によりメ
モリを消費する可能性があるので注意が必要です。

86

非同期処理

2.13

ブロードキャスト

1 つの Stream に対して複数回購読すると例外が発生します。複数の購読者
へイベントを通知するには、asBroadcastStream メソッドを使います。
import 'dart:async';
Stream<String> languages() async* {

await Future.delayed(const Duration(milliseconds: 500));
yield 'Dart';
await Future.delayed(const Duration(milliseconds: 500));
yield 'Kotlin';
await Future.delayed(const Duration(milliseconds: 500));
yield 'Swift';

await Future.delayed(const Duration(milliseconds: 500));
}

yield* Stream.fromIterable(['JavaScript', 'C++', 'Go']);

Future<void> main() async {
final broadcastStream = languages().asBroadcastStream();
await Future.delayed(const Duration(milliseconds: 1000));
broadcastStream.listen((i) {
print('listener 1: $i');
});

❶

❷

await Future.delayed(const Duration(milliseconds: 1100));
broadcastStream.listen((i) {
print('listener 2: $i');
});

❸

}
// => listener 1: Dart
// => listener 1: Kotlin
// => listener 1: Swift
// => listener 2: Swift
// => listener 1: JavaScript
// => listener 2: JavaScript
// => listener 1: C++
// => listener 2: C++
// => listener 1: Go
// => listener 2: Go

ブロードキャストタイプの Stream は最初に購読されたタイミングで元の

Stream の購読を開始します。そのため❶で待機している間は languages 関数
の本体は実行されません。❷で購読が開始されると languages 関数の本体が
87

第

2 Dartの言語仕様
章

実行され、yield でイベントが通知されます。❸で 2 つ目の購読がスタートす
ると、そのタイミングからイベントが通知され、それまでの値は通知されま
せん。
Streamを変更する

標準で Stream を変化させるメソッドが多く提供されています。ここですべ
てを紹介しませんが、代表的なものは、
・Stream の値を変換する map
・Stream の値をフィルタする where
・Stream の値の最大数を制限する take

などがあります。
import 'dart:async';
Stream<int> numberStream() {
return Stream.fromIterable(List.generate(10, (index) => index));
}
void main() {
numberStream()
.where((num) => num % 2 == 0) // 0, 2, 4, 6, 8
.map((num) => num * 2) // 0, 4, 8, 12, 16
.take(3) // 0, 4, 8
.listen((num) {
print(num);
});
}
// => 0
// => 4
// => 8

Zone ── 非同期処理のコンテキスト管理
Dart には Zone という非同期処理のコンテキストを管理するしくみがありま
す。その機能の一つに非同期処理で捕捉されなかった例外のハンドリングが
あります。
以下は Zone を使わない場合の例です。

88

非同期処理

2.13

import 'dart:async';
// 戻り値がFuture型、例外をスローする関数
Future<String> fetchUserName() {

var str =
Future.delayed(const Duration(seconds: 1), () => throw 'User not found.');

}

return str;

void main() {
fetchUserName().then((data) {
print(data);

}

});

例外をスローする非同期処理です。Future へ例外発生時のコールバックを
登録していません。実行するとプログラムが強制終了します。
続いて、Zone を使って例外をハンドリングする例です。
import 'dart:async';
// 戻り値がFuture型、例外をスローする関数
Future<String> fetchUserName() {
var str =
Future.delayed(const Duration(seconds: 1), () => throw 'User not found.');
return str;
}
void main() {
runZonedGuarded(() {
fetchUserName().then((data) {
print(data);
});
}, (error, stackTrace) {
print('Caught: $error');
});
}
// => Caught: User not found.

runZonedGuarded は第一引数に受け取った処理を自身の Zone で実行します。
第二引数には自身の Zone で発生した例外をハンドリングするコールバックを
渡します。実行するとプログラムが強制終了することなく、例外がハンドリ
ングされます。ただし、Flutter のエラーハンドリングは Zone ではなく前述の
PlatformDispatcher を使うことが一般的です。
（main 関数は暗黙的にデ
実際はすべての Dart コードは Zone で実行されます
89

第

2 Dartの言語仕様
章

フォルト Zone で実行されています）。Zone にはエラーハンドリングのほかに
も print 関数の動作を変更する機能や非同期コールバックの登録を捕捉する
機能などがあります。

アイソレート
アイソレートはスレッドやプロセスのようなしくみで、
・専用のヒープメモリを持つ
・専用の単一のスレッドを持ち、イベントループを実行する
・アイソレート間でメモリの共有はできない

といった特徴があります。
すべての Dart プログラムはアイソレートの中で実行されます。通常、自動
的にメインアイソレートが起動し、その中でプログラムが実行されるので意
識することはありません。
Flutterアプリとアイソレート

Flutter アプリを作るうえでアイソレートを意識することはほとんどありま
せん。前述のとおりメインアイソレートが自動的に起動し、その中で Dart の
プログラムが実行されます。
アプリでよく実装される時間のかかる処理として、HTTP 通信やファイル
（その間 Dart
の I/O が挙げられます。これらは OS など Dart コード外で実行され
のアイソレートは他のイベントを処理可能）、完了すると Dart が再開される
ためアプリがフリーズするようなことは起こりません。
アイソレートを活用するアプリのサンプルを以下に用意しました。Dart の
プログラムで数値が素数かどうか判定する関数です。67280421310721 という
大きな素数を判定させるため計算に時間がかかります。ボタンをタップする
と計算が開始します。
lib/main.dart

import 'package:flutter/foundation.dart';
import 'package:flutter/material.dart';
void main() {
runApp(
const MaterialApp(

90

非同期処理

2.13

home: HomeScreen(),

),

}

);

// 引数が素数かどうか判定する関数
bool isPrime(int value) {
if (value == 1) {
return false;

}
for (var i = 2; i < value; ++i) {
if (value % i == 0) {

}
}

}

return false;

return true;

class HomeScreen extends StatelessWidget {
const HomeScreen({super.key});
@override
Widget build(BuildContext context) {
return Scaffold(
body: Center(
child: Column(
mainAxisAlignment: MainAxisAlignment.center,
crossAxisAlignment: CrossAxisAlignment.center,
children: [
const CircularProgressIndicator(),
ElevatedButton(
onPressed: () async {
const number = 67280421310721;
final result = await compute((number) {
return isPrime(number);
}, number);
print('$number is prime: $result');
},
child: const Text('button')),
],
),
),
);
}
}

❶

compute 関数は新たにアイソレートを起動し、引数に渡した関数オブジェク
トを実行します
（❶）
。筆者の環境では、compute 関数に渡した isPrime(number);
91

第

2 Dartの言語仕様
章

をメインアイソレートで実行するとインジケータのアニメーションが止まり、

Dart プログラムがブロックしたことが目視できました注 4。

2.14
まとめ
Dart の言語仕様について解説しました。変数宣言、組み込み型、オペレー
タなど他の多くの言語と似たような文法が多く、基本的には習得しやすい言
語だと思います。ただ、Dart 3 で登場したパターンや、クラス修飾子など、
全体像を把握するのが難しい機能も増えてきた印象です。

Dart は現在も活発に開発が進んでおり、これからも新しい機能が増えてい
くことでしょう。最新情報は公式の情報を参照してください。その前の基礎
固めに本章がお役に立てばと思います。

注4

92

手もとで再現させたいと思った読者の方は注意しながら実行してください。実行環境の CPU を長
時間占有する可能性があります。

第

3

章

フレームワークの中心となる
Widgetの実装体験
StatelessWidget、StatefulWidget

93

第

3 フレームワークの中心となるWidgetの実装体験
章

StatelessWidget、StatefulWidget

本章では Flutter アプリ開発の中心となるウィジェット（Widget）について
学びます。Flutter アプリをブラウザ上で実装、動作させることができる
DartPad というツールがあります。まずはこのツールを利用して、Widget を
使った小規模なプログラムを書いてみましょう。

3.1
DartPadでアプリ開発を体験しよう
ブラウザで DartPad にアクセスします。
・https://dartpad.dev/

左側に以下のサンプルコードを入力し、
「Run」
ボタンをクリックしましょう。
import 'package:flutter/material.dart';
void main() {
runApp(
Container(
color: Colors.blue,
child: const Center(
child: Text(
'Hello, world!',
textDirection: TextDirection.ltr,
),
),
),
);
}

すると、ブラウザの右半分に、青い背景で「Hello, world!」
と文字が表示され
ているかと思います（図 3.1）。

94

DartPadでアプリ開発を体験しよう

図 3.1

3.1

DartPad でアプリを実行した様子

ここでサンプルコードについて解説します。最初のimport から始まる行はパ
ッケージ（パッケージについては第 4 章で解説します）からライブラリに定義され
たクラスや関数を利用可能にするものです。ここでは Flutter のマテリアルデザイ
ンに準拠したアプリを開発するためのクラスや関数をインポートしています。
続いて Dart コードのエントリポイントとなる main 関数があります。そし
く けい

（矩形の描画）
、Center
（中央配置のレイ
て、runApp 関数注 1 の引数は Container
（図 3.2）
。
アウト）
、Text（文字の描画）の 3 つが階層構造になっています
図 3.2

ウィジェットの階層構造

Container(
color: Colors.blue,
child:
const Center(
child:
Text(
'Hello, world!',
textDirection: TextDirection.ltr,
),
),
),

この 3 つはすべてウィジェット（Widget）と呼ばれるオブジェクトです。

Flutter アプリの UI はこのウィジェットの階層構造（ウィジェットツリー）をも
注1

runApp 関数は引数に与えられたウィジェットを画面全体に適用する関数です。

95

第

3 フレームワークの中心となるWidgetの実装体験
章

StatelessWidget、StatefulWidget

とに作られます。ほとんどのウィジェットは次の 2 つのクラスに分類できま
す。状態を持たない StatelessWidget と、状態を持つ StatefulWidget です。

3.2
状態を持たないWidget ── StatelessWidget
状態を持たないウィジェットクラスを StatelessWidget と言います。まず
は次のサンプルコードを DartPad で実行してみましょう。
import 'package:flutter/material.dart';
void main() {
runApp(

Center(
child: Container(
color: Colors.yellow,
width: 100,
height: 100,
child: const Center(
child: Text(
'mouse',
textDirection: TextDirection.ltr,
),
),
),
),

}

96

);

状態を持たないWidget ── StatelessWidget

図 3.3

3.2

黄色いネズミを配置した実行結果

画面中央に黄色の四角形、「mouse」というテキストを配置しました（図 3.3）
。
同じ要領で他の動物を追加してみたいと思います。runApp 関数に直接引数
で渡されている Center ウィジェットを Column という垂直なレイアウトをする
ウィジェットに変更します
（❶）。続いて、Column の children 配列に、赤いト
カゲを追加します（❷）。
import 'package:flutter/material.dart';
void main() {
runApp(
❶
Column(
children: [
Container(
color: Colors.yellow,
width: 100,
height: 100,
child: const Center(
child: Text(
'mouse',
textDirection: TextDirection.ltr,
),
),
),
Container(
color: Colors.red,
width: 100,
height: 100,

❷

97

第

3 フレームワークの中心となるWidgetの実装体験
章

StatelessWidget、StatefulWidget

child: const Center(
child: Text(
'lizard',

textDirection: TextDirection.ltr,

),

❷

),

),

],

),

}

);

図 3.4 のように黄色いネズミと赤いトカゲが並びました。
図 3.4

黄色いネズミと赤いトカゲが並んだ実行結果

独自のStatelessWidgetを定義する
ここで、Column の子ウィジェットがテキストと色以外が同じ冗長なものに
なりました。テキストと色をパラメータにウィジェットを構成する機能があ
ると共通化できそうです。

StatelessWidget を利用して実現してみましょう。
import 'package:flutter/material.dart';
void main() {

98

状態を持たないWidget ── StatelessWidget

3.2

runApp(

const Column(
children: [

AnimalView(

text: 'mouse',
color: Colors.yellow,

),

AnimalView(
text: 'lizard',

❶

color: Colors.red,

),

],

),

}

);

class AnimalView extends StatelessWidget {

const AnimalView({super.key, required this.text, required this.color});
final String text;
final Color color;

}

@override
Widget build(BuildContext context) {
return Container(
color: color,
width: 100,
height: 100,
child: Center(
child: Text(
text,
textDirection: TextDirection.ltr,
),
),
);
}

❷

StatelessWidget を継承した AnimalView クラスを実装しました（❷）。Column
の子ウィジェットが再利用可能になったことによって runApp の引数がシンプ
ルになりました
（❶）。
AnimalView クラスはクラス変数にテキストと色を持ち、コンストラクタ引
数で渡されます。
オーバーライドした build メソッドでこのウィジェットの UI を構成します。
ちなみにコンストラクタの第一引数の Key は、フレームワークがウィジェ
99

第

3 フレームワークの中心となるWidgetの実装体験
章

StatelessWidget、StatefulWidget

ットのライフサイクルを判断する際に用いられるオブジェクトです
（第 9 章で
詳しく解説します）
。多くのケースでは省略（null）で問題ありません。ウィジ
ェットのコンストラクタは名前付き引数、第一引数を Key 型とすることが慣
習とされています。

3.3
状態を持つウィジェット ── StatefulWidget
状態を持ち、自身で表示を更新ができるウィジェットクラスを StatefulWidget
と言います。サンプルコードを DartPad で実行してみましょう。解説のためサ
ンプルコードは StatelessWidget からスタートします。
import 'package:flutter/material.dart';
void main() {
runApp(
const Center(
child: Counter(),
),
);
}
class Counter extends StatelessWidget {
const Counter({super.key});
final _count = 0;
@override
Widget build(BuildContext context) {
return Container(
color: Colors.red,
width: 100,
height: 100,
child: Center(
child: Text(
'$_count',
textDirection: TextDirection.ltr,
),
),

}

100

}

);

状態を持つウィジェット ── StatefulWidget

3.3

赤い四角形の中にテキスト「0」が描画されました
（図 3.5）
。
図 3.5

赤い四角形の中に 0 が描画された実行結果

Widgetのタップ操作を検知する
今回のサンプルは、赤い四角形をタップすると数字がカウントアップする
アプリにしたいと思います。タップ操作を検知するために Container ウィジ
ェットを GestureDetector ウィジェットで包みます（❶）
。
import 'package:flutter/material.dart';
void main() {
runApp(
const Center(
child: Counter(),
),
);
}
class Counter extends StatelessWidget {
const Counter({super.key});
final _count = 0;
@override
Widget build(BuildContext context) {
❶
return GestureDetector(
onTap: () {
print('tapped!');
},

101

第

3 フレームワークの中心となるWidgetの実装体験
章

StatelessWidget、StatefulWidget

child: Container(

color: Colors.red,
width: 100,
height: 100,

child: Center(
child: Text(
'$_count',

textDirection: TextDirection.ltr,

),

),

),

}

}

);

赤い四角形をタップするとコンソールにメッセージが表示されます
（図 3.6）
。
図 3.6

コンソールに出力されるメッセージ

StatefulWidgetを継承する
続いて、タップした際に数字をカウントアップするように変更を加えたい
と思います。
クラス変数 _count は final で宣言されているため変更することはできませ
ん。仮に _count を int _count = 0; のように宣言したとしても、変化した _
count の値に追従して画面が更新されることはありません。このようなケー
スでは StatefulWidget を採用します。
import 'package:flutter/material.dart';
void main() {
runApp(
const Center(
child: Counter(),
),

102

状態を持つウィジェット ── StatefulWidget

}

3.3

);

class Counter extends StatefulWidget {
const Counter({super.key});

}

@override
State<Counter> createState() => _CounterState();

❶

class _CounterState extends State<Counter> {
int _count = 0;
@override
Widget build(BuildContext context) {

}

}

❷

return GestureDetector(
onTap: () {
print('tapped!');
},
child: Container(
color: Colors.red,
width: 100,
height: 100,
child: Center(
child: Text(
'$_count',
textDirection: TextDirection.ltr,
),
),
),
);

Counter ウィジェットを StatefulWidget に書き換えました。StatefulWidget は
build メソッドを持ちません。代わりに createState メソッドをオーバーライ
ドし State オブジェクトを返します（❶）。build メソッドは State クラスで実
装します（❷）。State クラスは状態が変化したことをフレームワークに知ら
せる setState() というメソッドを持っており、このメソッドを呼び出すと
build メソッドが呼び出されるしくみになっています。

103

第

3 フレームワークの中心となるWidgetの実装体験
章

StatelessWidget、StatefulWidget

Widgetの状態を変化させる
それでは _count の値を変化させ、それに追従して build メソッドが呼び出
されるように修正してみます。
import 'package:flutter/material.dart';
void main() {
runApp(

const Center(
child: Counter(),
),

}

);

class Counter extends StatefulWidget {
const Counter({super.key});

}

@override
State<Counter> createState() => _CounterState();

class _CounterState extends State<Counter> {
int _count = 0;
@override
Widget build(BuildContext context) {
return GestureDetector(
onTap: () {
print('tapped!');
setState(() {
_count += 1;
❶
});
},
child: Container(
color: Colors.red,
width: 100,
height: 100,
child: Center(
child: Text(
'$_count',
textDirection: TextDirection.ltr,
),

),

104

まとめ

3.4

),

}

}

);

onTap に渡すコールバックの中で、setState の呼び出しと _count の変更を
実装しました（❶）。setState は引数にクロージャで _count の変更処理を渡し
ています。このように、状態を変更するときは setState の引数で行います。
このサンプルコードを実行すると、赤い四角形をタップするたびに数字が
更新されカウントアップします。

3.4
まとめ
StatelessWidget と StatefulWidget について、それぞれの特徴をあらためてお
さらいします。
・StatelessWidget の特徴
・状態を持たない
・build メソッドをオーバーライドし、1 つ以上の Widget を組み合わせて UI を構成
する
・自身で表示更新するしくみがない
・StatefulWidget の特徴
・StatefulWidget は State を生成する
・StatelessWidget にあった build メソッドは State で実装する
・状態を変化させるときは setState の引数コールバック内で行う
・setState を呼び出すと自身の表示更新が行われる

シンプルなアプリであれば、StatelessWidget と StatefulWidget の組み合わせ
でだけで開発することができます。アプリが複雑になり、ウィジェットの更
新や状態の受け渡しに課題が見えてきたときは、状態管理について検討する
とよいでしょう。第 7 章でその考え方や代表的な手法を解説します。

105

第

4

章

アプリの日本語化対応、
アセット管理、
環境変数

107

第

4 アプリの日本語化対応、アセット管理、環境変数
章

本章では国際化対応、アイコンなどのアセット管理のしくみ、環境変数の
取り扱いについて解説します。特に製品レベルのアプリを開発する際には、
はじめに整えておくべき要素であり、さしずめ「開発の土台作り」
と言えます。
また、これらの要素を整えるために必要なパッケージ管理についても併せ
て解説します。

4.1
パッケージやツールを導入する
Dart 言語は標準でパッケージ管理ツールを提供しており、Flutter のプロジ
ェクトで利用することができます。まず、混乱のないよう用語の解説を表 4.1
にまとめたので確認してください。
パッケージに関する用語

表 4.1

用語

解説

パッケージ

Dart のプログラムライブラリ、アプリ、リソースなどを含んだデ
ィレクトリ。パッケージそのものや依存関係を記述した pubspec
ファイルが必ず含まれる

プラグイン

ネイティブコード（iOS 向けの Swift コードや Android 向けの Kotlin
コードなど）を同梱したパッケージ

pub

パッケージ管理ツール。パッケージを入手するために使う

pub.dev

共有パッケージを閲覧、検索できる Web サイト。https://pub.dev

Flutter Favorite Program 「最初に導入を検討すべきパッケージ」
を選出する活動のこと。pub.
dev で公開されている

pub.dev 注 1 にはたくさんのパッケージが公開されています。サードパーティ
のプログラムライブラリのみならず、Flutter が公式で提供するパッケージも
あります。カメラ操作、データ永続化、Firebase 連携など、pub.dev でパッケ
ージを検索することで多くのユースケースに対応できるでしょう。本章でも
後述のアセット管理のところで便利なパッケージを紹介します。
多くのパッケージは pubspec.yaml に所定の記述をし、コマンドを実行する
ことで導入できます。ただし、導入に必要な手順はパッケージにより異なり
ますので、必ずそれぞれのドキュメントを参照してください。

注1

108

https://pub.dev

パッケージやツールを導入する

4.1

パッケージの導入方法
pubspec.yaml にはパッケージを記述するセクションが 2 種類あります。以
下にサンプルを示します。
dependencies:

flutter:
sdk: flutter

cupertino_icons: ^1.0.2

❶

http: ^0.13.6

dev_dependencies:
flutter_test:
sdk: flutter

flutter_lints: ^2.0.0
build_runner: ^2.3.3

❷

dependencies セクションはアプリのコードが依存するパッケージを記述し
ます
（❶）
。dev_dependencies は開発フェーズでのみ利用するパッケージを記
述します。たとえばテストに関わるパッケージや、コード生成ツールなどで
す
（❷）
。
依存するパッケージを追加するには、YAML（YAML Ain't Markup Language）
ファイルを直接編集するか、コマンドを実行します。たとえば、http という
パ ッ ケ ー ジ を 導 入 す る 場 合 は、以 下 の よ う に コ マ ン ド を 実 行 す る と
dependencies セクションに http パッケージが追加されます。
$ flutter pub add http

dev_dependencies セクションに追加する際は --dev オプションを付与しま
す。たとえば、build_runner というパッケージを導入する場合は、以下のよ
うにコマンドを実行します。
$ flutter pub add --dev build_runner

こうして pubspec.yaml にパッケージを追加したら、コマンドを実行してパ
ッケージを導入します。
$ flutter pub get

または Android Studio には pub get コマンドを実行するためのボタンが用意
ボタンを押すとパ
されています。pubspec.yaml を開いている状態で
「Pub get」
109

第

4 アプリの日本語化対応、アセット管理、環境変数
章

ッケージを導入できます
（図 4.1）。
図 4.1

Android Studio の「Pub get」ボタン

パッケージバージョンの指定方法
パッケージのバージョン指定には次のような記述方法があります。
# 2.1.0以上、互換性のある限り最新のバージョンを利用する
❶
shared_preferences: ^2.1.0
# 2.1.0以上 3.0.0未満のバージョンを利用する
❷
shared_preferences: '>=2.1.0 <3.0.0'
# 2.1.0以下のバージョンを利用する
❸
shared_preferences: '<=2.1.0'
# 2.0.0より新しいバージョンを利用する
❹
shared_preferences: '>2.0.0'
# バージョンを2.1.1に固定する
❺
shared_preferences: 2.1.1

110

パッケージやツールを導入する

# 指定なし

❻

shared_preferences: any
# 未指定

shared_preferences:

4.1

❼

通常は❶のようなキャレット構文でバージョン番号を指定することが推奨
されています。キャレット構文は、「指定したバージョンから、互換性のある
最新のバージョンまで」の範囲を意味します。互換性の有無はセマンティック
バージョニングというルールで決められており、この❶の例では 2.1.0 以上、

3.0.0 未満を意味します。❷〜❹のように等号、不等号を組み合わせてバージ
ョンの範囲を指定することも可能です。
❺以降は推奨されない書き方になります。❺のようにバージョンを固定す
ることもできますが、依存関係の解決が困難になる可能性があります。❻は
すべてのバージョンを許可します。❼も同じ意味となります。
最終的に解決されたバージョン番号は pubspec.lock に記録されます。チー
ム開発を行う際には pubspec.lock を共有することで、メンバー間で同じバー
ジョンで開発することを保証できます。

パッケージバージョンの更新方法
導入しているパッケージの最新バージョンや、更新の可否は以下のコマン
ドで確認できます。
$ flutter pub outdated

出力は図 4.2 のようになります。

Tips セマンティックバージョニングについて
pub はセマンティックバージョニングというルールに従って依存関係を解決
します。セマンティックバージョニングは、major.minor.patch の 3 つの数字で
バージョンを表現します。互換性のない変更があった際には major バージョン
が上がります。ただし、1.0.0 未満は特別でいかなる変更も起こり得るとされて
います。Dart のパッケージにおいては、慣習的に 1.0.0 未満で互換性のない変
更があった場合は minor バージョンを上げることとしています。

111

第

4 アプリの日本語化対応、アセット管理、環境変数
章

図 4.2

flutter pub outdated の出力例

Showing outdated packages.

[*] indicates versions that are not the latest available.
Package Name
direct dependencies:
shared_preferences

Current

Upgradable Resolvable

Latest

*2.1.0

2.1.1

2.1.1

2.1.1

出力されたバージョン番号は表 4.2 のような意味を表します。
表 4.2

バージョン番号の意味

バージョン名

解説

Current

pubspec.lock に記述されている現在のバージョン

Upgradable

pubspec.yaml に記述された範囲で解決可能な最新バージョン

Resolvable

pubspec.yaml の制約にかかわらず解決可能な最新バージョン

Latest

最新の安定リリースバージョン

図 4.2 の出力結果からパッケージ shared_preferences は、pubspec.yaml に記
述された範囲で最新の 2.1.1 に更新できるようです。
のバージョンへ更新するには以下のコマンドを実行します。
「Upgradable」
$ flutter pub upgrade shared_preferences

更新されたパッケージとバージョンはターミナルに出力されます。
Resolving dependencies...
> shared_preferences 2.1.1 (was 2.0.0)

前項のキャレット構文を利用していれば互換性を保ったまま最新バージョ
ンに更新されますが、念のため関連するコードの動作確認やリリースノート
の確認を行いましょう。
「Resolvable」のバージョンへ更新するには --major-versions オプションを
付与します。pubspec.yaml も自動的に更新されますので注意してください。
$ flutter pub upgrade --major-versions shared_preferences

「Resolvable」
のバージョンが「Latest」と異なる場合は、以下のコマンドを実
行し依存関係を調査してみましょう。競合する依存関係によって最新のバー
ジョンを利用できない場合があります。

112

アプリを日本語に対応させる

4.2

$ flutter pub deps

以下は出力例です。パッケージの依存関係がツリー状に表示されます。こ
こから競合する依存関係を探し、利用可能なバージョンを調整します。
Dart SDK 2.19.5

Flutter SDK 3.7.8
flutter_playground 1.0.0+1

└── shared_preferences 2.1.1

├── flutter...
├── shared_preferences_android 2.1.4
│

├── flutter...

│
│

├── flutter...
└── shared_preferences_platform_interface...

│
└── shared_preferences_platform_interface...
├── shared_preferences_foundation 2.2.2

└── shared_preferences_platform_interface 2.2.0
├── flutter...
└── plugin_platform_interface 2.1.4
└── meta...

4.2
アプリを日本語に対応させる
Flutter は他の多くの UI フレームワークと同様に国際化するための機能が提
供されています。「私の開発するアプリは日本語のみをサポートするから関係
ないや」と思った読者の方はお待ちください。Flutter はデフォルト言語が英
語で開発されているため、特に対応しなければ意図せず英語が表示されたり、
英語圏の日付フォーマットが適用されたりします。そのため、日本向けのア
プリを開発するためには、日本向けのローカライズが必要なのです。本章で
は意図せず英語表示されるケースの紹介と、日本向けのローカライズ方法な
どを紹介します。

Dart のソースコード以外に、プロジェクトの設定ファイルを変更する必要
があります。本節の解説は新しいプロジェクトを作成し、そのプロジェクト
に変更を加えながら進めていきます。プロジェクトの作成方法は第 1 章を参
照してください。

113

第

4 アプリの日本語化対応、アセット管理、環境変数
章

意図せず英語表示されるケース
それでは意図せず英語表示されるケースについて具体例を見ていきましょう。
フレームワークが提供する表示文字列

ウィジェットの中には、Flutter フレームワークから表示文字列を提供する
ものがあります。Flutter はデフォルト言語が英語で開発されているため、特
別に対応しなければ英語でしか表示されません。例を見てみましょう。
./lib/main.dart

import 'package:flutter/material.dart';
void main() {
runApp(

/* ◆ MaterialApp
マテリアルデザインに準拠したテーマの提供や
画面遷移の機能を内包したWidget */
const MaterialApp(
home: HomeScreen(),
),

}

);

class HomeScreen extends StatelessWidget {
const HomeScreen({super.key});
@override
Widget build(BuildContext context) {
/* ◆ Scaffold
マテリアルデザインの基本的なレイアウトを提供するWidget */
return Scaffold(
body: Center(
child: Column(
// 子Widgetを中央へ寄せるためのパラメータ
mainAxisAlignment: MainAxisAlignment.center,
children: [
/* ◆ TextField
ユーザーがテキスト入力するウィジェット */
const TextField(),
],
),

),

}

114

}

);

アプリを日本語に対応させる

4.2

アプリを実行し、テキストフィールドに任意の文字を入力後、テキストフ
ィールドをロングタップしてみましょう。すると、コンテキストメニューが
表示されます（図 4.3）。
図 4.3

英語のコンテキストメニューが表示される様子

コンテキストメニューは「Paste」や「Select All」などの項目が表示されます。
これらの項目は、ローカライズする実装をしていないので、端末の言語設定
を変更しても日本語に切り替わりません。
日付フォーマット

続いて、現在日付を文字で表示する実装を試してみます。日時情報を扱う
DateTime クラス、日付フォーマットを扱う DateFormat クラスを使います。
先ほどのサンプルに追加する形で実装します。DateFormat は intl パッケージ
に含まれていますので、まずはこのパッケージを導入します。プロジェクトの
ディレクトリで、ターミナルから以下のコマンドを実行してください。
# intlパッケージを導入
$ flutter pub add intl:any

ここではバージョンを指定せずに any を指定しています。通常、any でのバ
ージョン指定は推奨されませんが、intl に関しては後述の flutter_localizations
パッケージと併用し、flutter_localizations に依存したバージョンを採用する
115

第

4 アプリの日本語化対応、アセット管理、環境変数
章

ため、any を指定することが一般的です。この後 flutter_localizations を導入す
るので、ここでは any を指定しておきます。
続いて、DateFormat クラスを使って現在日付をフォーマットした文字列を
表示するコードを追加します（❶）。
./lib/main.dart

import 'package:flutter/material.dart';

import 'package:intl/intl.dart'; // intlパッケージをインポート
void main() {

runApp(
const MaterialApp(

home: HomeScreen(),

),

}

);

class HomeScreen extends StatelessWidget {
const HomeScreen({super.key});

}

@override
Widget build(BuildContext context) {
return Scaffold(
body: Center(
child: Column(
mainAxisAlignment: MainAxisAlignment.center,
children: [
const TextField(),
Text(
DateFormat.yMEd().format(DateTime.now()),
),
],
),
),
);
}

すると表示結果は図 4.4 のようになります。

116

❶

アプリを日本語に対応させる

図 4.4

4.2

フォーマットされた日付が表示される様子

フォーマットされた日付文字列が表示されました。ただ、日本語圏では年
→月→日の順で表示するのが一般的ですが、この表示は英語圏で一般的な月
→日→年の順で表示されています。また、曜日も英語表記になっています。

アプリを日本にローカライズする
それでは Flutter アプリを日本語化する手順を紹介します。
フレームワークが提供する表示文字列を日本語化する

フレームワークが提供する表示文字列はデフォルトでは英語のみでした。
これらの翻訳情報は flutter_localizations パッケージとして提供されています。
さっそく、パッケージを導入してみましょう。プロジェクトのディレクトリ
で、ターミナルから以下のコマンドを実行してください。
# flutter_localizationsパッケージを導入
$ flutter pub add flutter_localizations --sdk=flutter

続いて、MaterialApp ウィジェットにいくつかパラメータを付与します。
./lib/main.dart

import 'package:flutter/material.dart';
import 'package:flutter_localizations/flutter_localizations.dart'; // flutter_loc
alizationsパッケージをインポート

117

第

4 アプリの日本語化対応、アセット管理、環境変数
章

import 'package:intl/intl.dart';
void main() {
runApp(

const MaterialApp(
localizationsDelegates: [

GlobalWidgetsLocalizations.delegate,

GlobalMaterialLocalizations.delegate,
GlobalCupertinoLocalizations.delegate,

❶

],
supportedLocales: [

Locale('ja', 'JP'),

],

❷

home: HomeScreen(),

),

}

);

localizationsDelegates パラメータへ、表示文字列の翻訳情報などを持って
。マテリアルデザインに準拠したウィジェットで扱
いる delegate を渡します（❶）
う翻訳情報は、GlobalMaterialLocalizations.delegateに含まれています。iOS
スタイルのウィジェットで扱う翻訳情報は、GlobalCupertinoLocalizations.
delegateに含まれています。また、GlobalWidgetsLocalizations.delegateは、
テキストの方向（左から右、または右から左）を扱います。これらの delegate は、

flutter_localizations パッケージが提供しているものです。
supportedLocales パラメータは、アプリがサポートするロケールを渡しま
す（❷）
。Locale クラスのパラメータは、言語と地域で IANA（Internet Assigned
Numbers Authority）言語サブタグレジストリに準拠しています。今回は日本語
のみをサポートするので、ja と JP を渡します。
それではアプリを実行してみましょう（図 4.5）。

118

アプリを日本語に対応させる

図 4.5

4.2

コンテキストメニューが日本語になった様子

テキストフィールドのコンテキストメニューは日本語になりました。しか
し、現在日時の表記は英語のままです。
日付フォーマットを日本語化する

DateFormat など intl パッケージの API は、独自のデフォルトロケールにし
たがって動作します。このデフォルトロケールは、Intl.defaultLocale で取
得や設定ができます。
./lib/main.dart

class HomeScreen extends StatelessWidget {
const HomeScreen({super.key});
@override
Widget build(BuildContext context) {
❶
// Intl.defaultLocale = 'ja';

Intl.defaultLocale = Localizations.localeOf(context).toString();
return Scaffold(
body: Center(
child: Column(
mainAxisAlignment: MainAxisAlignment.center,
children: [

❷

const TextField(),
Text(
DateFormat.yMEd().format(DateTime.now()),
),

119

第

4 アプリの日本語化対応、アセット管理、環境変数
章

],

),

),

}

}

);

❶のように、デフォルトロケールに固定値を設定することも可能ですが、の
ちに複数の言語に対応することになったときのために❷のように設定すること
もできます。❷は Localizations クラスからロケールを取得してデフォルトロ
ーケルを設定しています。Localizations クラスから取得できるロケールは、端
末の言語設定をベースに MaterialApp ウィジェットの supportedLocales パラメ
ータで渡したロケールの中から最適なロケールが選択されます。今回のケース
では、supportedLocales に Locale('ja', 'JP')のみ設定しているので、端末の
言語設定がなんであれ ja_JP が返却されます。
デフォルトローケルを設定したので、再度アプリを実行してみましょう
（図
4.6）。
図 4.6

日付の表記が日本語になった様子

現在日時の表記が日本語になりました。これでアプリを日本語化する対応
は完了ですが、iOS アプリをアプリストアに公開する際はもう一つ対応が必
要です。

120

アプリを日本語に対応させる

4.2

iOSアプリの対応言語を設定する

次に設定する内容は、主にアプリストア
（App Store）
に表示されるアプリの
対応言語に影響します。修正するファイルは、ios/Runner/Info.plist です。
Info.plist はアプリの構成情報を記述する XML 形式のファイルです。
CFBundleLocalizations キーにサポートする言語を記述します。
./ios/Runner/Info.plist

<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/
PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
<!-- 省略 -->

<key>CFBundleLocalizations</key>
<array>
<string>ja</string>

</array>
</dict>
</plist>

今回は日本語のみをサポートするので、ja を設定します。このキーには、
MaterialApp ウィジェットの supportedLocales パラメータで渡したロケール
と同じ言語を記述することが、Flutter として推奨されています。

メッセージをローカライズする
続いて、アプリ内で表示する独自の文字列（本項では
「メッセージ」
と呼ぶこ
とにします）
をローカライズする方法を紹介します。筆者は日本語のみをサポ
ートするアプリの場合も、ここで紹介する方法を使ってメッセージを扱うこ
とがあります。メッセージの管理がしやすいことや、将来的に複数言語に対
応する際にコストが下がるからです。
メッセージのローカライズについても intl パッケージが提供しています。

arb ファイルという JSON 形式のファイルにメッセージを記述し、コードジェ
ネレータを使って、Dart のコードに変換します。さっそくやってみましょう。
コードジェネレータを設定する

pubspec.yaml を編集し、コードジェネレータを有効にします。

121

第

4 アプリの日本語化対応、アセット管理、環境変数
章

./pubspec.yaml

flutter:

generate: true

❶

コードジェネレータの設定は、flutter セクションに記述します（❶）
。生
成されたコードをプロジェクトから参照できるように以下のコマンドを実行
します。
$ flutter pub get

続いて、ローカライズの構成ファイルを作成します。プロジェクトルート
に l10n.yaml というファイルを作成し、以下の内容を記述します。
「l10n」は
の略です（はじまりが
「L」、終わりが
「n」で、その間が 10 文字あ
「Localization」
）
。
るので
「l10n」
./l10n.yaml

template-arb-file: app_ja.arb
❷
output-class: L10n
❸
nullable-getter: false

❶

❶は arb ファイルのテンプレートファイルです。後述の属性を記述するフ
ァイルを指定します。
❷はコードジェネレータが生成するローカライズクラスのクラス名を指定
します。デフォルトは
「AppLocalizations」ですが、筆者はタイプ数を減らすた
に変更することが多いです。
めに
「L10n」
❸は、ローカライズクラスのゲッタが null 許容型かどうかを指定します。

Flutter の後方互換性のためにデフォルトは null 許容型となっていますので、
可能であれば false にしておきましょう。
arbファイルを作成する

続いて、lib/l10n ディレクトリを作成し、その中に app_ja.arb というファ
イルを作成します。
./lib/l10n/app_ja.arb

{

}

122

"helloWorld": "こんにちは世界！",
"@helloWorld": {
"description": "お決まりの挨拶"
}

アプリを日本語に対応させる

4.2

キーhelloWorld に対して、日本語のメッセージを記述しました。キーの先
頭 に @ を付 け る と、そ のキ ーは 属性 を 記述 す る キ ー と し て 扱わ れ ま す。
helloWorld の description 属性
（説明）
として " お決まりの挨拶 " と記述してお
きました。
そして次のコマンドを実行します。
$ flutter gen-l10n

すると、.dart_tool/flutter_gen/gen_l10n ディレクトリに arb ファイルを
もとに生成された Dart ファイル（app_localizations.dart）が出力されます。
このファイルにメッセージを扱うためのコードが記述されています。次項で
このファイルをインポートしてメッセージを表示するコードを書いてみまし
ょう。
ローカライズされたメッセージを表示する

それではメッセージを表示するコードを書いてみましょう。
./lib/main.dart

import 'package:flutter/material.dart';
❶
import 'package:flutter_gen/gen_l10n/app_localizations.dart';
// import 'package:flutter_localizations/flutter_localizations.dart';
import 'package:intl/intl.dart';
void main() {
runApp(
const MaterialApp(
/*
localizationsDelegates: [
GlobalMaterialLocalizations.delegate,
GlobalWidgetsLocalizations.delegate,
GlobalCupertinoLocalizations.delegate,
],
*/
localizationsDelegates: L10n.localizationsDelegates,
/*
supportedLocales: [
Locale('ja'),
],
*/
❸
supportedLocales: L10n.supportedLocales,

❷

home: HomeScreen(),

),

);

123

第

4 アプリの日本語化対応、アセット管理、環境変数
章

}
class HomeScreen extends StatelessWidget {
const HomeScreen({super.key});
@override

Widget build(BuildContext context) {

Intl.defaultLocale = Localizations.localeOf(context).toString();
❹
final l10n = L10n.of(context);
return Scaffold(
body: Center(

child: Column(

mainAxisAlignment: MainAxisAlignment.center,
children: [
const TextField(),

Text(
DateFormat.yMEd().format(DateTime.now()),
),
Text(l10n.helloWorld),

],

❺

),

),

}

}

);

まず生成されたコードをインポートします（❶）。次に MaterialApp のパラ
メータを調整します。localizationsDelegates と supportedLocales を、コー
ド生成されたものに置き換えます（❷、❸）。
L10n.localizationsDelegates は flutter_localizations が提供する delegate に
加え、❹で取得しているローカライズファイルをロードする delegate も含ま
れています。L10n.supportedLocales は arb ファイルが用意された言語が格納
されています。
続いて、生成されたローカライズクラスを取得します（❹）
。クラス名は
l10n.yaml ファイルの output-class で指定した L10n です。
このクラスは arb ファイルのキーに対応するプロパティを持ちます。先ほ
ど作成した arb ファイルには helloWorld というキーを記述しましたので、L10n
クラスは helloWorld というプロパティを持ちます。それを取り出して Text ウ
ィジェットに渡しているのが❺です。
エディタで helloWorld プロパティにカーソルを合わせると、arb ファイル
の description 属性の値が表示されます（図 4.7）。
124

アプリを日本語に対応させる

図 4.7

4.2

メッセージが表示される様子

以上でローカライズされたメッセージの設定が完了しました。

arbファイルの扱い方
そのほか便利な arb ファイルの記述方法や、複数の言語に対応する方法を
紹介します。
プレースホルダ

arb ファイルにはプレースホルダという機能があります。例として検索機能
のあるアプリを考えてみましょう。検索結果の件数を表示するメッセージを
表示するとします。
./lib/l10n/app_ja.arb

{

}

// 省略
"numOfSearchResult": "検索結果は{count}件です。",
"@numOfSearchResult": {
"description": "検索結果"
}

{count} の部分がプレースホルダです。キーnumOfSearchResult に対応する
メソッドが生成され、引数として count を受け取ります。動作を確認する際
125

第

4 アプリの日本語化対応、アセット管理、環境変数
章

は、以下のコマンドを実行してローカライズクラスを再生成してください。
$ flutter gen-l10n
Text(l10n.numOfSearchResult(1)),
// => 検索結果は1件です。

プレースホルダは属性で型を指定したほうが安全です（図 4.8）
。
図 4.8

プレースホルダを利用してメッセージをした様子

./lib/l10n/app_ja.arb

{

}

// 省略
"numOfSearchResult": "検索結果は{count}件です。",
"@numOfSearchResult": {
"description": "検索結果",
"placeholders": {
"count": {
"type": "int"
}
}
}

単数形と複数形の対応

日本語ではあまり意識しませんが、英語のように単数形と複数形でメッセ
ージを変える言語もあります。これを実現するための機能があります。
126

アプリを日本語に対応させる

4.2

構文はバリュー全体をブレース（{ }）
で囲い、プレースホルダ名に続けて、
plural というキーワードを記述します。
たとえば、日本語の arb ファイルを以下のように作成したとします。
./lib/l10n/app_ja.arb

{

// 省略
"numOfSearchResult": "{count, plural, =0{検索結果はありません} other{検索結果は

{count}件です}}",

"@numOfSearchResult": {
"description": "検索結果",
"placeholders": {
"count": {

}

}

}

}

"type": "int"

実行結果は次のようになります。
Text(l10n.numOfSearchResult(0)),
// => 検索結果はありません
Text(l10n.numOfSearchResult(1)),
// => 検索結果は1件です
Text(l10n.numOfSearchResult(2)),
// => 検索結果は2件です

この英語訳を作ります。検索結果を「result」と訳し、さらに「result」と
を使い分けます。arb ファイルを以下のように記述することで実現で
「results」
きます。
"numOfSearchResult": "{count, plural, =0{There is no result} =1{1 result found}
other{{count} results found}}"

英語での実行結果は次のようになります。
Text(l10n.numOfSearchResult(0)),
// => There is no result
Text(l10n.numOfSearchResult(1)),
// => 1 result found
Text(l10n.numOfSearchResult(2)),
// => 2 results found

場合分けは =0 や =1 のほかに、few や many といったキーワードも存在します
が、日本語や英語では使われません。具体的な数値がどのケースに該当する
かは言語ごとに異なるので注意してください。その挙動は ICU（International
127

第

4 アプリの日本語化対応、アセット管理、環境変数
章

Components for Unicode）というライブラリに準拠しており、ICU は CLDR
（Common Locale Data Repository）が提供するデータを活用しています。詳細な挙
動を知りたい方は Unicode CLDR 注 2 のドキュメントを参照してください。
複数の言語への対応

対応する言語ごとに arb ファイルを追加することでアプリを複数の言語に
翻訳できます。arb ファイルがどの言語に対応しているかはファイル名で決定
します。アンダーバーと拡張子の間の文字列が、その arb ファイルが対応す
る言語として扱われます。たとえば、app_ja.arb ではアンダーバーと拡張子
の間が ja なので日本語の arb ファイルとして扱われます。日本語と英語に対
応する場合は次のようなファイル構成となります。
~/project_root
└── lib
├── l10n
│
├── app_en.arb
│
└── app_ja.arb
└── ...（省略）

また、それ以外にも @@locale キーに言語を指定する方法もあります。
./lib/l10n/japanese.arb

{

}

"@@locale": "ja",
"helloWorld": "こんにちは世界！",
"@helloWorld": {
"description": "お決まりの挨拶"
}

この場合は自由にファイルを決めて問題ありません。
~/project_root
└── lib
├── l10n
│
├── english.arb
│
└── japanese.arb
└── ...（省略）

注2

128

https://cldr.unicode.org/index/cldr-spec/plural-rules

プロジェクトにアセットを追加する

4.3

4.3
プロジェクトにアセットを追加する
どうこん

Flutter ではアプリに同梱する画像やテキストファイルなどをアセットと呼
びます。本書では主に画像の取り扱いについて紹介します。後半ではアセッ
トを扱う際に便利な flutter_gen というパッケージについても紹介します。ア
セットを扱う際はこのパッケージを使うことをお勧めします。

アプリに画像を追加する
まずはアセットを配置するディレクトリを作成します。ディレクトリ名は
任意ですが assets などが一般的です。assets ディレクトリを作成したら、そ
の中に画像を配置します。今回は PNG 形式で円の画像を用意し、circle.png
という名前で assets ディレクトリに配置します（図 4.9）
。
~/project_root
└── assets
└── circle.png

なお、Flutter が対応している画像フォーマットは JPEG、WebP、GIF、PNG、

BMP、WBMP です。
図 4.9

circle.png

続いて、pubspec.yaml にアセットのパスを記述します。flutter セクショ
ンのサブセクションに assets を追加し、その下にアセットのパスを記述しま
す。
./pubspec.yaml

flutter:
# 省略
assets:
- assets/circle.png

これでアセットの準備は完了です。このアセットを表示するシンプルなア
プリを作成してみましょう。
129

第

4 アプリの日本語化対応、アセット管理、環境変数
章

./lib/main.dart

import 'package:flutter/material.dart';
void main() {
runApp(

const MaterialApp(
home: HomeScreen(),
),

}

);

class HomeScreen extends StatelessWidget {
const HomeScreen({super.key});

@override
Widget build(BuildContext context) {

}

}

return Scaffold(
body: Center(
child: Image.asset('assets/circle.png'),
),
);

❶

画像を表示するウィジェットとして Image ウィジェットがあります。❶で
アセットのパスを指定し、Image ウィジェットを作成しています。
アプリを実行すると、図 4.10 のように円が表示されます。
図 4.10

130

アセットの画像が表示される様子

プロジェクトにアセットを追加する

4.3

pubspec.yaml に記述するアセットのパスは、ディレクトリ単位で指定する
こともできます。以下のように、/ で終わるパスを指定すると、そのディレ
クトリのすべてのファイルがアセットとして扱われます。ただし、通常はサ
ブディレクトリを再帰的に探索しないので注意しましょう（後述の解像度バリ
エーションを除く）。
以下のようにアセットのパスを指定したとします。
./pubspec.yaml

flutter:

# 省略
assets:

- assets/

次のようなディレクトリ構成であれば、circle.png と square.png はアセッ
トしてアプリに組み込まれますが、icon.png はアセットとして扱われません。
~/project_root
└── assets
├── circle.png
├── square.png
└── icons
└── icon.png

アプリ内で assets/icons/icon.png を参照すると実行時エラーになります。

端末の解像度に応じて画像を切り替える
スマートフォンのディスプレイ解像度はさまざまです。解像度別にいくつ
か画像を用意し、実行時に切り替える手法があります。以下のようなディレ
クトリ構成でアセットを配置します。
~/project_root
└── assets
├── 2x
│
└── circle.png
├── 3x
│
└── circle.png
└── circle.png

そして、前節で紹介したように pubspec.yaml にアセットのパスをディレク
トリ単位で指定します。
./pubspec.yaml

flutter:
# 省略

131

第

4 アプリの日本語化対応、アセット管理、環境変数
章

assets:

- assets/

このように、数値と末尾に「x」で終わるディレクトリを作成すると、解像度
別のバリエーションとして解釈されます。assets/circle.png が縦横 72px だ
としたら、これを基準に 2x には縦横 144px、3x には縦横 216px の画像を配置
します。

iPhone を例に、これらの画像がどのように選択されるか説明します。
iPhone15 Pro Max のディスプレイ解像度は縦横 2796 × 1290px ですが、論理
解像度は縦横 932 × 430pt です。論理解像度に対して、ディスプレイの物理
解像度が 3 倍なので iPhone15 Pro Max で実行した場合、3x の画像が自動的に
選択されます。
わかりやすいように、2x の画像（図 4.11）と 3x の画像（図 4.12）として意図
的に異なるものを用意しました。
図 4.11

2x 配下の circle.png

図 4.12

3x 配下の circle.png

iPhone14 Pro Max のシミュレータ、iPhone SE（第 3 世代）のシミュレータそ
れぞれでアプリを実行すると、図 4.13 と図 4.14 のようになります。
ただし、この方法は画像の準備に手間がかかったり、アプリのファイルサイ
ズが大きくなるという問題があります。この問題はベクタ画像を使うことで解
決できますので、flutter_svg というパッケージを利用して画像を扱うことをお
勧めします。後述の flutter_gen と組み合わて利用する方法を紹介します。

132

プロジェクトにアセットを追加する

図 4.13

iPhone15 Pro Max のシミュレ
ータで実行した様子

図 4.14

4.3

iPhone SE（第 3 世代）のシミュ
レータで実行した様子

flutter_gen ── 型安全にアセットを扱うパッケージ
本節の最初に画像アセットを表示するアプリの例を紹介しましたが、アセ
ットのパスを文字列で指定していました。パスを誤って入力すると、実行時
エラーとなってしまいます。これを防ぐために、アセットを扱う際は flutter_

gen というパッケージを利用することをお勧めします。flutter_gen は、アセッ
トにアクセスするコードを自動生成してくれるパッケージです。
なお、前節でメッセージをローカライズした際に、生成されたコード
が .dart_tool/flutter_gen/gen_l10n ディレクトリに出力されていましたが、
ここで紹介する flutter_gen パッケージとは関係ありません。
flutter_genを導入する

flutter_gen を利用してみましょう。パッケージを導入するためにプロジェ
クトのディレクトリで、ターミナルから以下のコマンドを実行してください。
# build_runnerパッケージとflutter_gen_runnerパッケージを導入
$ flutter pub add --dev build_runner flutter_gen_runner

ソースコード生成ツールの build_runner と、flutter_gen のコードジェネレ
ータである flutter_gen_runner を導入しました。
パッケージを追加したら、コードを生成するコマンドを実行します。
133

第

4 アプリの日本語化対応、アセット管理、環境変数
章

$ flutter packages pub run build_runner build

さっそく flutter_gen が生成したコードを利用するコードを書いてみましょう。
./lib/main.dart

import 'package:flutter/material.dart';
❶
import 'gen/assets.gen.dart';
void main() {

runApp(
const MaterialApp(

home: HomeScreen(),

),

}

);

class HomeScreen extends StatelessWidget {
const HomeScreen({super.key});

}

@override
Widget build(BuildContext context) {
return Scaffold(
body: Center(
child:
// Image.asset('assets/circle.png'),
❷
Assets.circle.image(),
),
);
}

まず flutter_gen が生成したコードをインポートしています（❶）
。アセット
へのアクセスは flutter_gen の実行によって Assets クラスに定義されています。
また、画像のアセットに関しては Image ウィジェットを返すメソッドも生成
され便利です
（❷）
。
SVG画像の利用

先にも述べましたが、さまざまなスマートフォンの解像度に合わせて画像
を複数用意するのは手間がかかります。それを解決する方法として、SVG 形
式のファイルを利用する方法があります。SVG ファイルはベクタ画像の一種
で、拡大／縮小しても画質が劣化しません。Flutter は SVG 画像をサポートし
ていませんが、flutter_svg というパッケージが SVG 画像を描画するウィジェ
ットを提供しています。
134

プロジェクトにアセットを追加する

4.3

パッケージを導入するためにプロジェクトのディレクトリで、ターミナル
から以下のコマンドを実行してください。
# flutter_svgパッケージを導入
$ flutter pub add flutter_svg

flutter_gen は flutter_svg と組み合わせて利用することを想定して、オプシ
ョンを用意しています。pubspec.yaml のトップレベルに flutter_gen セクシ
ョンを追加します。
./pubspec.yaml

flutter_gen:

integrations:
flutter_svg: true

続いてプロジェクトに SVG 形式のアセットを追加します。assets フォルダ
に図 4.15 の SVG 画像を配置します。

図 4.15

SVG 形式のアイコン

~/project_root
└── assets
└── check.svg

アセットを追加したら、コードを生成するコマンドを実行します。
$ flutter packages pub run build_runner build

SVG 画像を描画するコードを書いてみましょう。
./lib/main.dart

import 'package:flutter/material.dart';
import 'gen/assets.gen.dart';
void main() {
runApp(
const MaterialApp(
home: HomeScreen(),
),

135

第

4 アプリの日本語化対応、アセット管理、環境変数
章

}

);

class HomeScreen extends StatelessWidget {
const HomeScreen({super.key});
@override

Widget build(BuildContext context) {
return Scaffold(
body: Center(
child: Assets.check.svg(
width: 72,

height: 72,

❶

),

),

}

}

);

SVG 画像を描画するコードに書き換えました（❶）。これで端末の解像度を
気にすることなく、画像アセットを扱うことができます。このコードを実行
すると、図 4.16 のように SVG 画像が表示されます。

図 4.16

136

SVG 画像を描画した様子

dart-define-from-file ── 環境変数を扱う

4.4

その他のアセット

flutter_gen は画像アセットだけでなく、フォントや JSON ファイルなどのア
セットにも対応しています。また、オプションで組み合わせて利用できるパ
ッケージも flutter_svg 以外にいくつか用意されています。アプリで扱うアセ
ットの種類が増えた場合は、pub.dev 注 3 を参照しサポートされているか確認し
てみましょう。
また、既知の問題があるようで、ソースコードを自動生成する際にエラー
が発生した際も同様に pub.dev を参照してください。

4.4
dart-define-from-file ── 環境変数を扱う
アプリを設計する際に、コードと設定を分離することは重要です。たとえ
ば開発環境と本番環境で API のエンドポイントが異なる場合、環境を切り替
えるためにコードを書き換えるのは良い運用とは言えません。ログレベルな
ども同様です。こういった設定情報は環境変数として扱うことで、コードと
分離することができます。

環境変数をJSON形式で記述する
Flutter の dart-define-from-file というしくみを利用することで、環境変
数をコードから参照できます。例として、プロジェクトルートに define/env.
json というファイルを作成し、以下の内容を記述します。
./define/env.json

{

}

"apiEndpoint": "https://example.com/api",
"logLevel": 1,
"enableDebugMenu": true

このファイルのパスを Flutter のコマンドへ渡すことで、コードから参照で
「Run」➡「Edit
きるようになります。Android Studio で実行する場合は、

Configurations」を選択し、「Run/Debug Configrations」ウィンドウを開きます
注3

https://pub.dev/packages/flutter_gen

137

第

4 アプリの日本語化対応、アセット管理、環境変数
章

（図 4.17）
。
「Additional run args」に --dart-define-from-file= に続いて、

JSON ファイルのパスを記述します。今回の場合は --dart-define-fromfile=define/env.json となります。
図 4.17

Run/Debug Configrations ウィンドウ

環境変数をコードから参照する
Dart のコードから環境変数を参照するには、以下のように記述します。
const endpoint = String.fromEnvironment('apiEndpoint');
const logLevel = int.fromEnvironment('logLevel');
const enableDebugMenu = bool.fromEnvironment('enableDebugMenu');

String 型、int 型、bool 型のそれぞれに対応した fromEnvironment メソッ
ドを呼び出します。引数には環境変数のキーを指定します。
このとき必ず const 変数に代入するか、呼び出し側に const キーワードを付
与する必要があるので注意してください。これを忘れると環境変数が取得で
きず、デフォルト値が返されます。キーが間違っている場合も同様です。デ
フォルト値は fromEnvironment メソッドの第二引数で指定するか、未指定の
場合は表 4.3 の値が返されます。

138

まとめ

表 4.3

4.5

fromEnvironment() のデフォルト値

型

デフォルト値

String

空文字

int

0

bool

false

4.5
まとめ
アプリのローカライズ、アセットの管理、環境変数の扱い方を紹介しました。

Flutter は、たとえ日本語だけをサポートするアプリであっても、しっかり
と対応しなければ意図せず英語が表示されてしまうことがあります。ローカ
ライズ対応は少々手間ですが、はじめに整えておくことでメッセージの管理
にも役立ちます。
アセットはパス文字列にタイプミスの懸念があるので flutter_gen を利用し
て安全に扱うことが望ましいです。また、解像度別の画像を用意するのは手
間がかかりますので、SVG 形式のファイルを使うのがお勧めです。
コードと設定を分離する手法として、環境変数を扱う方法を紹介しました。
本章で紹介した内容は、製品レベルのアプリを開発、保守していくうえで
重要な要素です。もちろん要件によっては不要な要素もあるでしょうが、採
用するか否かをはじめに検討しておくことで、後々の開発がスムーズに進む
ことでしょう。

139

第

5

章

テーマとルーティング

141

第

5 テーマとルーティング
章

本章では Flutter フレームワークの機能を紹介します。その中でも
「テーマ」
「画面遷移」この 2 点に的を絞って解説します。筆者の経験上、この 2 つの要
素はおおよそどのようなアプリを開発する場合にも知識として必要になり、
後工程での方針変更は手間がかかることがあります。
前章は、はじめに整えておくべき要素を紹介しました。本章では、はじめに
設計しておくとよい要素として、フレームワークの 2 つの要素を紹介します。
なお、本章では解説に重きを置くため、関連したコードの断片を掲載して
いますので、省略されている部分がある点に留意してください。完全なサン
プルコードの場合は、その旨を明記しています。手もとで動作確認する際
は、./lib/main.dart を書き換えてください。

5.1
テーマ ── アプリ全体のヴィジュアルを管理
アプリ全体を通した色やフォントを定義し、適用する方法を解説します。
アプリの UI で一貫した世界観を演出したり、視覚的にわかりやすいことは重
要です。
本節では
「アプリ全体を通した色やフォントの定義」をテーマと呼ぶことに
し、テーマに関する 2 つの機能を解説します。1 つ目はアプリのテーマを自動
的に計算し適用する機能、2 つ目はアプリ独自のテーマを管理し適用する機
能です。

フレームワークによるテーマの自動計算機能
まずはテーマの自動計算機能を確認しましょう。Flutter のテンプレートプ
ロジェクトで動作を確認します。第 1 章で解説した方法で新たにプロジェク
トを作成し、アプリを実行します。
import 'package:flutter/material.dart';
void main() {
runApp(const MyApp());
}
class MyApp extends StatelessWidget {

142

5.1

テーマ ── アプリ全体のヴィジュアルを管理

const MyApp({super.key});
// This widget is the root of your application.
@override

Widget build(BuildContext context) {
return MaterialApp(
title: 'Flutter Demo',

theme: ThemeData(
// This is the theme of your application.

//
// TRY THIS: Try running your application with "flutter run". You'll see
// the application has a purple toolbar. Then, without quitting the app,
// try changing the seedColor in the colorScheme below to Colors.green
// and then invoke "hot reload" (save your changes or press the "hot
// reload" button in a Flutter-supported IDE, or press "r" if you used
// the command line to start the app).
//

// Notice that the counter didn't reset back to zero; the application
// state is not lost during the reload. To reset the state, use hot
// restart instead.
//
// This works for code too, not just values: Most code changes can be
// tested with just a hot reload.
❷
colorScheme: ColorScheme.fromSeed(seedColor: Colors.deepPurple),

❶

useMaterial3: true,
),
home: const MyHomePage(title: 'Flutter Demo Home Page'),

}

}

);

❶で ThemeData クラスのインスタンスを作成し、MaterialApp ウィジェット
に渡しています。英語のコメントにもあるように、カラーを変更して動作を
確認してみましょう。
今回は❷の deepPurple を blue に変更してください。ソースコードを保存す
ると、ホットリロード機能でアプリの外観が変化します。もし、変化しなけ
れば Android Studio のホットリロードボタンをクリックしてみましょう。
アプリの外観が紫を基調としたテーマから青に変化したことが確認できる
と思います。ThemeData クラスはアプリのテーマ情報を持つクラスです。
ThemeData クラスの代表的なプロパティに、色のパラメータを持つ colorScheme
と、文字のパラメータを持つ textTheme があります。
ColorScheme クラスはマテリアルデザインのルールにのっとり、テーマの
色のパラメータを計算します。さらに、計算済みの色を一部カスタマイズす
143

第

5 テーマとルーティング
章

ることもできます。
class MyApp extends StatelessWidget {
const MyApp({super.key});
@override

Widget build(BuildContext context) {
return MaterialApp(
title: 'Flutter Demo',
// theme: ThemeData(
//

colorScheme: ColorScheme.fromSeed(seedColor: Colors.blue),

// ),

theme: ThemeData(
colorScheme: ColorScheme.fromSeed(seedColor: Colors.blue)
❶
.copyWith(background: Colors.blueGrey),
useMaterial3: true,

),

home: const MyHomePage(title: 'Flutter Demo Home Page'),

}

}

);

ColorScheme クラスの copyWith メソッドを使い、カラーを変更したコピー
を作成します。この例では背景カラーを変更しています（❶、図 5.1）
。
図 5.1

background カラーが変更された様子

続いて textTheme について見てみましょう。
144

テーマ ── アプリ全体のヴィジュアルを管理

5.1

class MyApp extends StatelessWidget {
const MyApp({super.key});
@override

Widget build(BuildContext context) {
return MaterialApp(
title: 'Flutter Demo',

theme: ThemeData(
colorScheme: ColorScheme.fromSeed(seedColor: Colors.blue)
.copyWith(background: Colors.blueGrey),
textTheme: const TextTheme(
bodyMedium: TextStyle(
color: Colors.white,

fontWeight: FontWeight.w600,

❶

),

),
useMaterial3: true,

❷

),
home: const MyHomePage(title: 'Flutter Demo Home Page'),

}

}

);

ThemeData クラスへ TextTheme を渡しました（❶）
。ここでは bodyMedium と
いうテキストスタイルの色とフォントウェイトを変更しています（図 5.2）
。
図 5.2

TextTheme が変更された様子

145

第

5 テーマとルーティング
章

アプリのデザインを細かくカスタマイズするには、ColorScheme のリファ
レンス注 1 と TextTheme のリファレンス注 2、それと併せてマテリアルデザインの
ドキュメント注 3 を参照してください。
また最後に useMaterial3 というコンストラクタのパラメータについても触
（以降、M3）
のテーマ
れておきます
（❷）
。このパラメータは Material Design 3
を利用するかどうかを指定します。M3 は Google が提唱するマテリアルデザ
インの新しいバージョンで、従来のものよりも表現力が豊かでアクセシビリ
ティが高いデザインとなっています。

M3 はオプトインの形で段階的に導入されてきましたが、Flutter 3.16 をも
って M3 がデフォルトになりました。今後は useMaterial3 フラグは削除され、
従来までの Material Design 2 のコードは削除される予定です。
ダークモード対応

ここ数年の iOS や Android はユーザー設定や時間帯に応じて暗い外観に切り
替わるダークモード機能を持っています（iOS はダークモード、Android では
ダークテーマと言いますが、本書では両方を指してダークモードと呼ぶこと
とします）
。MaterialApp ウィジェットや ThemeData クラスを使うことで簡単
にダークモードに対応できます。サンプルをお見せしましょう。
class MyApp extends StatelessWidget {
const MyApp({super.key});
// This widget is the root of your application.
@override
Widget build(BuildContext context) {
return MaterialApp(
title: 'Flutter Demo',
theme: ThemeData(
colorScheme: ColorScheme.fromSeed(seedColor: Colors.deepPurple),
useMaterial3: true,
),
darkTheme: ThemeData(
colorSchemeSeed: Colors.deepPurple,
❶
❷
brightness: Brightness.dark,
),
home: const MyHomePage(title: 'Flutter Demo Home Page'),

146

注1

https://api.flutter.dev/flutter/material/ColorScheme-class.html

注2

https://api.flutter.dev/flutter/material/TextTheme-class.html

注3

https://m3.material.io/styles/color/the-color-system/color-roles

テーマ ── アプリ全体のヴィジュアルを管理

}

}

5.1

);

MaterialApp ウィジェットの darkTheme パラメータにダークモード用の
ThemeData ク ラ ス を 渡 し ま す（❶）。ThemeData ク ラ ス は brightness に
Brightness.dark を指定することで、ダークモード用のテーマを自動計算し
てくれます（❷）。MaterialApp ウィジェットがシステムのダークモード設定
を監視しているので、スマートフォンがダークモードに切り替わるとアプリ
の外観もダークモードに変化します。
それでは実際にアプリを実行し、ダークモードを切り替えてみましょう。

iOS Simulator の場合は、設定アプリから「Developer」➡「Dark Appearance」の
順に選択し、スイッチでモードを切り替えます（図 5.3）
。
図 5.3

モード切り替えでアプリの外観が変化する様子

アプリ独自のテーマ管理
マテリアルデザインにのっとったテーマについては、MaterialApp ウィジェ
ットや ThemeData クラスを用いることで実現できることがわかりました。一方
で、アプリ独自のテーマを管理する方法として Theme Extension があります。
class MyTheme extends ThemeExtension<MyTheme> {
const MyTheme({

147

第

5 テーマとルーティング
章

required this.themeColor,

});

final Color? themeColor;

❶

@override

MyTheme copyWith({Color? themeColor}) {

return MyTheme(
themeColor: themeColor ?? this.themeColor,

}

❷

);

@override

MyTheme lerp(MyTheme? other, double t) {
if (other is! MyTheme) {
}

}

}

return this;

return MyTheme(
themeColor: Color.lerp(themeColor, other.themeColor, t),
);

❸

ThemeExtension クラスを継承した MyTheme クラスを実装しました。MyTheme
ク ラ ス で は t h e m e C o l o r と い う カ ラ ー を 扱 う こ と に し ま す（❶）
。
ThemeExtension は抽象クラスで、サブクラスでは 2 つのメソッドを実装しな
ければなりません。
❷の copyWith メソッドは任意のフィールドを変更したコピーをインスタン
ス化するメソッドです。
❸の lerp メソッドはテーマの変化を線形補間するメソッドです。このメソ
ッドを実装しておくことで、テーマ変更時にアニメーション処理されるよう
になります。たとえば、ダークモードへの切り替えタイミングが該当します。
こうして実装したMyThemeクラスはThemeDataクラスのパラメータに渡します。
class MyApp extends StatelessWidget {
const MyApp({super.key});
// This widget is the root of your application.
@override
Widget build(BuildContext context) {
return MaterialApp(
title: 'Flutter Demo',
theme: ThemeData(

148

テーマ ── アプリ全体のヴィジュアルを管理

colorSchemeSeed: Colors.deepPurple,

extensions: const [MyTheme(themeColor: Color(0xFF0000FF))],

),

5.1

❶

darkTheme: ThemeData(

colorSchemeSeed: Colors.deepPurple,
brightness: Brightness.dark,

extensions: const [MyTheme(themeColor: Color(0xFFFF0000))],

),

❷

ThemeData クラスの extensions パラメータに ThemeExtension クラスを継承
した MyTheme クラスのインスタンスを渡します（❶）
。extensions パラメータ
は List 型なので、複数の Theme Extension を設定することも可能です。
ThemeData クラスのパラメータなので、ダークモード用に別の MyTheme クラス
を指定することも容易です（❷）。
続いて、MyTheme クラスのテーマを適用したウィジェットを実装します。
ThemedWidget という正方形を描画するウィジェットです。
./lib/main.dart

class ThemedWidget extends StatelessWidget {
const ThemedWidget({super.key});

}

@override
Widget build(BuildContext context) {
❶
final themeData = Theme.of(context);
❷
final myTheme = themeData.extension<MyTheme>()!;
final color = myTheme.themeColor;
return Container(width: 100, height: 100, color: color);
}

Theme ウィジェットの of メソッドを使い、ThemeData クラスのインスタンス
を取得します（❶）。さらに、ThemeData クラスの extension メソッドを使い、
MyTheme クラスのインスタンスを取得します（❷）
。
Theme というウィジェットがここで初めて登場しましたが、MaterialApp ウ
ィジェットが内部で生成しているウィジェットで、ThemeData クラスのイン
スタンスを持っています。Theme ウィジェットの子孫であれば、どのウィジ
ェットも of メソッドを使って ThemeData クラスのインスタンスを取得するこ
とができるのです。さらにこの ThemedWidget のように、build メソッドの中
で Theme ウィジェットの of メソッドを呼び出すと、テーマが変更されたとき
。こ
に再描画されるしくみも備わっています（詳しくは第 9 章で解説します）
のしくみのおかげで、ダークモードへの切り替え時に色がアニメーションす
る様子を確認できます。
149

第

5 テーマとルーティング
章

Theme Extensionを利用したアプリのサンプル

最後に、Theme Extension を利用したサンプルの全体を掲載します。この
サンプルではシステムのダークテーマ設定を利用せず、アプリ独自にダーク
テーマ設定を持つようにしました。Theme Extension を継承したクラスで lerp
メソッドを実装したことにより、テーマ変更時に色がアニメーションする様
子が確認できます。
./lib/main.dart

import 'package:flutter/material.dart';
class MyTheme extends ThemeExtension<MyTheme> {
const MyTheme({

required this.themeColor,
});
final Color? themeColor;
@override
MyTheme copyWith({Color? themeColor}) {
return MyTheme(
themeColor: themeColor ?? this.themeColor,
);
}

}

@override
MyTheme lerp(MyTheme? other, double t) {
if (other is! MyTheme) {
return this;
}
return MyTheme(
themeColor: Color.lerp(themeColor, other.themeColor, t),
);
}

void main() {
runApp(const MyApp());
}
class MyApp extends StatefulWidget {
const MyApp({super.key});

}

150

@override
State<StatefulWidget> createState() => _MyAppState();

テーマ ── アプリ全体のヴィジュアルを管理

5.1

class _MyAppState extends State<MyApp> {
bool _isDarkMode = false;
void _toggleDarkMode() {

setState(() {
_isDarkMode = !_isDarkMode;

}

});

@override
Widget build(BuildContext context) {
return MaterialApp(

title: 'Flutter Demo',

theme: ThemeData(
colorSchemeSeed: Colors.green,

extensions: const [MyTheme(themeColor: Color(0xFF0000FF))],
),
darkTheme: ThemeData(
colorSchemeSeed: Colors.green,
brightness: Brightness.dark,
extensions: const [MyTheme(themeColor: Color(0xFFFF0000))],
),
themeMode: _isDarkMode ? ThemeMode.dark : ThemeMode.light,
home: Scaffold(
body: const Center(
child: ThemedWidget(),
),
floatingActionButton: FloatingActionButton(
onPressed: () {
_toggleDarkMode();
},
child: const Icon(Icons.settings_brightness),
),

),

}

}

);

class ThemedWidget extends StatelessWidget {
const ThemedWidget({super.key});
@override
Widget build(BuildContext context) {

final myTheme = Theme.of(context).extension<MyTheme>()!;
final color = myTheme.themeColor;

151

第

5 テーマとルーティング
章

}

}

return Container(width: 100, height: 100, color: color);

Tips Cupertino（クパチーノ）デザイン
ここまで MaterialApp ウィジェットを使い、マテリアルデザインをベースに

した機能を紹介してきました。Flutter はこれ以外にも、iOS のルック＆フィー
ルを再現したウィジェットがあります。テーマの扱いに関しては MaterialApp

ウ ィ ジ ェ ッ ト の 代 わ り に C u p e r t i n o A p p ウ ィ ジ ェ ッ ト を 使 い、
CupertinoThemeData クラスでアプリのテーマを管理します。

iOS のルック＆フィールを再現したウィジェットの中には、CupertinoApp ウ

ィジェットが先祖になければ利用できないものもありますので注意してくださ
い。同様に、マテリアルデザインのウィジェットも先祖に MaterialApp ウィジ

ェットがあり、ThemeData クラスが提供されていないと利用できないものがあ
ります。
Flutter 公式では、iOS 以外のプラットフォームにもアプリを提供する場合は
マテリアルデザインを採用することを推奨しています。なお、本書は引き続き
マテリアルデザインをベースに解説を進めていきます。

5.2
ナビゲーションとルーティング
── 画面遷移を実現する3つの手法

Flutter の画面遷移は、画面の履歴をスタック構造のコンテナで管理するこ
とで実現しています。スタックへプッシュ（追加）することで新たな画面に遷
移し、ポップ
（取り除く）ことで元の画面に戻ります（図 5.4）
。

152

ナビゲーションとルーティング ── 画面遷移を実現する3つの手法

図 5.4

5.2

画面スタックのイメージ

画面❶

画面❶

進む

画面❷

戻る

Push

画面❷

Pop

画面❶

画面❶

画面❶

Flutter の提供する画面遷移の全体像を理解するうえで、重要な歴史的背景
があります。2020 年、Flutter は Web アプリをサポートする際にブラウザと連
携する新たな API を提供しました。新しい API 群は Navigator 2.0 と呼ばれてい
ます
（便宜上、Navigator 2.0 より前から存在する API 群を Navigator 1.0 と呼びま
す）
。これらの API は置き換えではなく追加の形で提供されました。そのため理
解を難しくしている以下のようなポイントがあると筆者は感じています。
・Navigator 1.0 から提供されている一部のクラスへ、Navigator 2.0 の機能が追
加されている
・Navigator 1.0 と Navigator 2.0 とでネーミングに統一感がない
・Navigator 1.0 と Navigator 2.0 は併用が可能

続いて、表 5.1 で用語を整理しましょう。
表 5.1

用語の一覧

用語

意味

Navigator ウィジェット

スタックを管理するウィジェット。Navigator 1.0 から存在する

Route クラス

スタックで管理される画面の単位。Navigator 1.0 から存在する

Router ウィジェット

プラットフォームと連携した画面遷移を実現する中心的なウィジェ
ット。Navigator 2.0 で追加された

Page クラス

Route クラスを生成する軽量なオブジェクト。Navigator 2.0 で追加
された

Flutter の画面スタックを管理しているのは Navigator ウィジェットです。
Flutter ではスタックで管理される画面の単位は Route クラスです。画面スタ
ックへ Route クラスのインスタンスをプッシュ／ポップすることで画面遷移
を実現します。この方法は Navigator 1.0 から提供されています。
Router ウィジェットは Navigator 2.0 で提供され、プラットフォームと連携
153

第

5 テーマとルーティング
章

した画面遷移を実現する中心的なウィジェットです。プラットフォームとの
連携とはブラウザの「進む」
「戻る」ボタンを契機にした画面遷移、アプリ内の
画面遷移とアドレスバーの URL との連動などを指します。
また、Navigator 1.0 の API では画面を 1 つずつプッシュ／ポップして履歴を
積み上げていくのに対して、Navigator 2.0 の API では画面履歴を一度に書き
換えてしまうことが可能です（図 5.5）。たとえば、設定画面からユーザー情
報画面に遷移するアプリで、ユーザー情報画面をブックマークしていたとし
ましょう。ブラウザでブックマークからユーザー情報画面を開いたとき、ブ
ラウザの
「戻る」
ボタンを押すと設定画面が現れるといったことを実現できる
のが Navigator 2.0 の API です。
このとき、Route クラスのインスタンスを複数生成するのではなく、軽量
な Page クラスが用いられます。Page クラスには自身を一意に判定する key プ
ロパティがあり、画面履歴書き換え時の最適化に利用されます。この最適化
（ウィジェットと
はウィジェットとエレメント
（Element）の関係に似ています
エレメント
（Element）の関係は第 9 章で解説します）。

iOS/Android をターゲットとしたモバイルアプリの場合、Navigator 1.0 の
API で十分なケースも多いです。また、Navigator 2.0 を利用した実装は複雑
で、ラップされたライブラリを利用するのがよいでしょう。

NavigatorウィジェットとRouteクラスによる画面遷移

── Navigator 1.0

それでは Navigator ウィジェットと Route クラスを利用した Navigator 1.0 の
画面遷移を見てみましょう。繰り返しになりますが、Flutter ではスタックで管
理される画面の 1 単位を Route クラスで表現します。Navigator ウィジェットに
対して、Route クラスのインスタンスをプッシュすることで新しい画面に遷移
し、ポップすることで元の画面に戻ります。通常、Navigator ウィジェットは
MaterialApp ウィジェットが内部でインスタンス化したものを利用します。
簡単なサンプルを見てみましょう
（理解を優先して、コードは簡略化してい
ます）
。
class FirstScreen extends StatelessWidget {
@override
Widget build(BuildContext context) {
/* ◆ ElevatedButton
マテリアルデザインのボタン */

154

ナビゲーションとルーティング ── 画面遷移を実現する3つの手法

5.2

Navigator 1.0 と Navigator 2.0 の違い

図 5.5

Navigator 1.0
履歴を一つずつ積み上げていく

ホーム
画面

進む

設定
画面

ユーザー
情報画面

進む

戻る

設定
画面

Pop

設定
画面

ユーザー
情報画面

Push
ホーム
画面

Push

設定
画面
ホーム
画面

設定
画面
ホーム
画面

ホーム
画面

Navigator 2.0
履歴を一つずつ積み上げていく
（Navigator 1.0 と同じ）
履歴を一度に書き換える

ユーザー
情報画面

ブラウザの
ブックマーク
から

戻る

設定
画面

Pop

設定
画面

ユーザー
情報画面
設定
画面
ホーム
画面

ホーム
画面

return ElevatedButton(
child: const Text('次へ'),
onPressed: () {
❶
final navigatorState = Navigator.of(context);
/* ◆ MaterialPageRoute
実行するプラットフォームに適した画面遷移アニメーションを提供するRoute */
final route = MaterialPageRoute(
❸
builder: (context) => const SecondScreen(),
❷
);
navigatorState.push(route);

},

❹

);

155

第

5 テーマとルーティング
章

}
}

FirstScreen 画面のボタンをタップすると、SecondScreen 画面に遷移する
サンプルです。ボタンをタップすると、Navigator ウィジェットの静的メソ
ッド of から NavigatorState クラスのインスタンスを取り出します（❶）
。
次に Route クラスのインスタンスを生成します
（❷）。MaterialPageRoute ク
ラスはプラットフォームに合わせて画面遷移のアニメーションを提供してく
、ほ
れ
（iOS であれば右から左へスライドイン、Android であればズームイン）
と ん ど の 場 合 は こ れ を 使 用 し ま す。ク ラ ス 名 に「Page」と あ り ま す が、
Navigator 2.0 の Page クラスではないので注意しましょう。
❸の引数 builder へは、遷移先のウィジェットを生成する関数型を渡しま
す。こうして生成した Route クラスを NavigatorState クラスへプッシュする
ことで画面遷移します
（❹）。
このサンプルでは理解しやすいように、NavigatorState を変数に格納して
いますが、実際には、
Navigator.of(context).push(
MaterialPageRoute(
builder: (_) => const SecondScreen(),
),
);

と 1 つの文で記述されることが多いです。
または、Navigator ウィジェットの静的メソッド push を直接呼び出しても
結果は同じです。
Navigator.push(
context,
MaterialPageRoute(
builder: (_) => const SecondScreen(),
),
);

続いて、遷移した先から元の画面に戻る方法を見てみましょう
（こちらもコ
ードは簡略化しています）。
class SecondScreen extends StatelessWidget {
@override
Widget build(BuildContext context) {

156

ナビゲーションとルーティング ── 画面遷移を実現する3つの手法

5.2

return ElevatedButton(

child: const Text('戻る'),
onPressed: () {

Navigator.of(context).pop();

},

}

❶

);

}

SecondScreen 画面で「戻る」タップすると、元の画面に戻るサンプルです。
NavigatorState クラスの pop メソッドを呼び出し、元の FirstScreen 画面へ
戻ります
（❶）。
上記のサンプルは理解を優先してコードを簡略化しているため、あまり一般
的な実装ではなく外観も不恰好です。以下が完全な動作サンプルとなります。
./lib/main.dart

import 'package:flutter/material.dart';
void main() {
runApp(const MaterialApp(
home: FirstScreen(),
));
}
// アプリ起動時に表示されるFirstScreenウィジェット
class FirstScreen extends StatelessWidget {
const FirstScreen({super.key});
@override
Widget build(BuildContext context) {
return Scaffold(
/* ◆ AppBar
画面上部のヘッダ部分となるWidget */
appBar: AppBar(
title: const Text('FirstScreen'),
),
body: Center(
child: ElevatedButton(
child: const Text('次へ'),
onPressed: () {

Navigator.of(context).push(
MaterialPageRoute(
builder: (_) => const SecondScreen(),
),
);

157

第

5 テーマとルーティング
章

},

),

),

}

}

);

// 画面遷移先として用意したSecondScreenウィジェット
class SecondScreen extends StatelessWidget {
const SecondScreen({super.key});
@override

Widget build(BuildContext context) {
return Scaffold(
appBar: AppBar(

title: const Text('SecondScreen'),

),

body: Center(
child: ElevatedButton(
child: const Text('戻る'),
onPressed: () {
Navigator.of(context).pop();
},
),
),

}

}

);

画面間でのデータの受け渡し

続いて画面間でデータを受け渡す方法を見ていきましょう。数値を表示す
る FirstScreen 画面と、数値を受け取り変更する SecondScreen 画面を用意し
ます。SecondScreen 画面で変更された数値は FirstScreen 画面に反映させる
。
ので、FirstScreen 画面は StatefulWidget を継承します（図 5.6）
図 5.6

画面間でのデータの受け渡し
数値を渡す
First
Screen

Second
Screen

変更した結果を返す

まずは FirstScreen 画面を見てみましょう。

158

数値を変更する

ナビゲーションとルーティング ── 画面遷移を実現する3つの手法

5.2

import 'package:flutter/material.dart';
void main() {

runApp(const MaterialApp(

}

home: FirstScreen(),
));

// アプリ起動時に表示されるFirstScreenウィジェット
class FirstScreen extends StatefulWidget {
const FirstScreen({super.key});
@override
}

State<StatefulWidget> createState() => _FirstScreenState();

class _FirstScreenState extends State<FirstScreen> {
❶
int _number = 0;
@override
Widget build(BuildContext context) {
return Scaffold(
appBar: AppBar(
title: const Text('FirstScreen'),
),
body: Center(
child: Column(
mainAxisAlignment: MainAxisAlignment.center,
children: [
Text(
'number = $_number',
❷
),
ElevatedButton(
onPressed: () async {
final newNumber = await Navigator.of(context).push<int>(
MaterialPageRoute(
builder: (_) => SecondScreen(number: _number),
),
);
setState(() {
if (newNumber != null) {
❹
_number = newNumber;

❸

}
});

},

child: const Text('Secondへ'),

),

159

第

5 テーマとルーティング
章

],

),

),

}

}

);

_FirstScreenState クラスは _number というフィールドを持ち
（❶）
、Text ウ
ィジェットで表示します
（❷）。ボタンをタップすると SecondScreen 画面へ遷
移します。このとき、_number の値を引数として渡します（❸）
。
続いて SecondScreen 画面を見てみましょう。
class SecondScreen extends StatelessWidget {

const SecondScreen({super.key, required this.number});
final int number;

}

❺

@override
Widget build(BuildContext context) {
return Scaffold(
appBar: AppBar(
title: const Text('IncrementScreen'),
),
body: Center(
child: Column(
mainAxisAlignment: MainAxisAlignment.center,
children: [
ElevatedButton(
child: const Text('Increment'),
onPressed: () {
Navigator.of(context).pop(number + 1);
},
),
ElevatedButton(
child: const Text('Decrement'),
onPressed: () {
Navigator.of(context).pop(number - 1);
},
),
],
),
),
);
}

❻

❼

SecondScreen 画面は引数で渡された数値をフィールドで保持します（❺）
。
160

ナビゲーションとルーティング ── 画面遷移を実現する3つの手法

5.2

ボタンをタップすると数値を増減させて FirstScreen 画面へ戻ります
（❻、❼）
。
NavigatorState クラスの pop メソッドの引数が、遷移元の画面に渡ります。
再び FirstScreen 画面の❸に注目してください。push メソッドへ型パラメ
ータを指定しています。これは遷移先からの戻り値の型を指定しています。
また、push メソッドの戻り値は Future クラスなので、await キーワードで戻
り値を待つ実装となっています。戻ってきた数値で状態を更新して、このサ
ンプルは完了です（❹）。

名前付きルートによる画面遷移 ── Navigator 1.0（非推奨）
名前付きルートは、遷移先の画面に任意の名前を付けて名前で画面遷移す
る方法です。画面遷移に関わるコードを一ヵ所に集約したり、ボイラープレ
ートを削減することができます。ただし、名前付きルートは後述の制限事項
により現在は推奨されていません。本書では次項の Router ウィジェットとの
比較のため解説します。
サンプルコードを見てみましょう。First、Second、Third の 3 つの画面を行
き来できるアプリです（図 5.7）。
図 5.7

名前付きルートサンプルの画面遷移イメージ

First
Screen

Second
Screen

Third
Screen

3 つの画面はそれぞれ以下のように用意します。
// アプリ起動時に表示されるFirstScreenウィジェット
class FirstScreen extends StatelessWidget {
const FirstScreen({super.key});
@override
Widget build(BuildContext context) {
return Scaffold(
appBar: AppBar(
title: const Text('FirstScreen'),
),
body: Center(
child: Column(

161

第

5 テーマとルーティング
章

mainAxisAlignment: MainAxisAlignment.center,
children: [
ElevatedButton(

child: const Text('FirstからSecondへ'),
onPressed: () {
},

),

ElevatedButton(
child: const Text('FirstからThirdへ'),
onPressed: () {
},

),

],

),

),

}

}

);

// 画面遷移先として用意したSecondScreenウィジェット
class SecondScreen extends StatelessWidget {
const SecondScreen({super.key});
@override
Widget build(BuildContext context) {
return Scaffold(
appBar: AppBar(
title: const Text('SecondScreen'),
),
body: Center(
child: Column(
mainAxisAlignment: MainAxisAlignment.center,
children: [
ElevatedButton(
child: const Text('SecondからThirdへ'),
onPressed: () {
},
),
ElevatedButton(
child: const Text('戻る'),
onPressed: () {
Navigator.of(context).pop();
},
),
],
),

),

162

ナビゲーションとルーティング ── 画面遷移を実現する3つの手法

}

}

5.2

);

// 画面遷移先として用意したThirdScreenウィジェット
class ThirdScreen extends StatelessWidget {
const ThirdScreen({super.key});
@override

Widget build(BuildContext context) {
return Scaffold(
appBar: AppBar(

title: const Text('ThirdScreen'),

),
body: Center(

child: Column(
mainAxisAlignment: MainAxisAlignment.center,
children: [
ElevatedButton(
child: const Text('戻る'),
onPressed: () {
Navigator.of(context).pop();
},
),
],

),

),

}

}

);

画面の遷移先と名前のマッピングは MaterialApp ウィジェットの引数で指
定します。
void main() {
runApp(
MaterialApp(
❶
initialRoute: '/',
routes: {
'/': (context) => const FirstScreen(),
'/second': (context) => const SecondScreen(),
'/second/third': (context) => const ThirdScreen(),
},
),
);
}

❷

routes パラメータ
（❷）は Map 型の引数でキーには String を、バリューには
163

第

5 テーマとルーティング
章

ウィジェットを戻り値とする関数型を渡します。このキーの文字列を画面遷
移先として指定することができます。initialRoute パラメータ（❶）
は最初に
表示する画面を指定します。
続いて、名前付きルートで画面遷移するコードを追加しましょう。
class FirstScreen extends StatelessWidget {
const FirstScreen({super.key});
@override

Widget build(BuildContext context) {
return Scaffold(
appBar: AppBar(

title: const Text('FirstScreen'),

),

body: Center(
child: Column(

mainAxisAlignment: MainAxisAlignment.center,

children: [
ElevatedButton(
child: const Text('FirstからSecondへ'),
onPressed: () {
❶
Navigator.of(context).pushNamed('/second');
},
),
ElevatedButton(
child: const Text('FirstからThirdへ'),
onPressed: () {
Navigator.of(context).pushNamed('/second/third');
},
),
],

),

),

}

}

);

class SecondScreen extends StatelessWidget {
const SecondScreen({super.key});
@override
Widget build(BuildContext context) {
return Scaffold(
appBar: AppBar(

title: const Text('SecondScreen'),
),
body: Center(

164

❷

ナビゲーションとルーティング ── 画面遷移を実現する3つの手法

5.2

child: Column(

mainAxisAlignment: MainAxisAlignment.center,
children: [
ElevatedButton(

child: const Text('SecondからThirdへ'),
onPressed: () {

Navigator.of(context).pushNamed('/second/third');

},

❸

),

ElevatedButton(
child: const Text('戻る'),
onPressed: () {

Navigator.of(context).pop();

},

),

],

),

),

}

}

);

class ThirdScreen extends StatelessWidget {
const ThirdScreen({super.key});
@override
Widget build(BuildContext context) {
return Scaffold(
appBar: AppBar(
title: const Text('ThirdScreen'),
),
body: Center(
child: Column(
mainAxisAlignment: MainAxisAlignment.center,
children: [
ElevatedButton(
child: const Text('戻る'),
onPressed: () {
Navigator.of(context).pop();
},
),
],
),
),
);
}

}

165

第

5 テーマとルーティング
章

NavigatorState クラスの pushNamed メソッドで画面遷移します。遷移先は
MaterialApp ウィジェットの routes パラメータに渡した Map のキーで指定し
ます
（❶〜❸）
。
MaterialApp ウィジェットの initialRoute パラメータは、デフォルト値が
/ となっています。initialRoute に渡された名前の画面が存在しない場合は
デフォルト値が採用されます。
先ほどのサンプルを以下のように変更してみましょう。
void main() {

runApp(
MaterialApp(

initialRoute: '/second/third',

❶

routes: {
'/': (context) => const FirstScreen(),

'/second': (context) => const SecondScreen(),

'/second/third': (context) => const ThirdScreen(),

},

),

}

);

initialRoute パラメータに /second/third を指定します
（❶）
。アプリを起動
するとThirdScreen 画面が表示され、
「戻る」
ボタンを押すとSecondScreen 画面
が表示されます。さらに「戻る」ボタンを押すとFirstScreen 画面が表示されま
す。このように、initialRoute に指定した画面の中間の画面も生成されます。
一方で、FirstScreen 画面から ThirdScreen 画面へ pushNamed 関数で遷移し
た場合は中間の SecondScreen 画面は生成されません。この違いに注意してく
ださい。
ElevatedButton(
child: const Text('FirstからThirdへ'),
onPressed: () {
// 中間のSecondScreenは生成されない
Navigator.of(context).pushNamed('/second/third');
},
),

名前付きルートの制限事項

/ から始まるルートはディープリンクとして扱われる特徴があります。ディ
ープリンクとは、ブラウザなどからアプリ内の特定の画面に遷移させるしくみ
です。名前付きルートをディープリンクとして利用した場合、常に同じ動作と
なり、たとえば
「ログイン状態によって遷移先を変える」
といったカスタマイズ
166

ナビゲーションとルーティング ── 画面遷移を実現する3つの手法

5.2

ができません。また、ディープリンクで中間の画面を生成すると、Web アプリ
として実行した際にブラウザの進む／戻るボタンの挙動が不自然になります。
そのため、Flutter は名前付きルートを推奨しないとしています。
なお、実際にディープリンクとして動作させるにはネイティブの設定や、構
成ファイルのホスティングが必要になります。

Routerウィジェットによる画面遷移 ── Navigator 2.0
続いて Router ウィジェットを使った画面遷移を見ていきましょう。いよい
よ Navigator 2.0 の登場です。画面履歴を一度に書き換えるような挙動を確認
することができます。Router ウィジェットを利用した実装は複雑になるため
ラップしたパッケージを使うのがよいでしょう。本書では go_router パッケー
ジを紹介します。先ほどの名前付きルートで画面遷移するサンプルを go_router
パッケージを使って書き換えてみましょう。
パッケージを導入するためにプロジェクトのディレクトリで、ターミナル
から以下のコマンドを実行してください。
# go_routerパッケージを導入
$ flutter pub add go_router

go_routerによる画面スタックの書き換えを体験する

次に MaterialApp ウィジェットのコンストラクタを修正します。
import 'package:flutter/material.dart';
import 'package:go_router/go_router.dart';
void main() {
runApp(
❶
MaterialApp.router(
routerConfig: _router,
),
);
}
final _router = GoRouter(
routes: [
❹
GoRoute(

❷

),

path: '/',
builder: (context, state) => const FirstScreen(),

❸

167

第

5 テーマとルーティング
章

GoRoute(

path: '/second',
builder: (context, state) => const SecondScreen(),

),

GoRoute(
path: '/third',

❸

builder: (context, state) => const ThirdScreen(),

),

],

);

MaterialApp ウィジェットの router という名前付きコンストラクタを利用
すると、内部で Router ウィジェットが生成されます
（❶）
。routerConfig パラ
メータは、Router ウィジェットを利用する際に必要な関連オブジェクトをバ
ンドルして渡すことのできる便利なパラメータです。
続いて、go_router パッケージを扱っていきましょう。似た名前のクラスが
連続するので注意してください。GoRouter クラス（❷）
は RouterConfig クラス
のサブクラスで、router コンストラクタ（❶）の routerConfig パラメータに渡
すことができます。GoRoute クラス（❹）は遷移先のパスや Page クラスの生成
方法を保持するクラスです。
GoRouter クラス（❷）の routes パラメータにリスト型で渡します（❸）
。path
パラメータには遷移先のパスを、builder パラメータにはウィジェットを生
成する関数型を渡します。
続いて、画面遷移の実装を修正します。
class FirstScreen extends StatelessWidget {
const FirstScreen({super.key});
@override
Widget build(BuildContext context) {
return Scaffold(
appBar: AppBar(
title: const Text('FirstScreen'),
),
body: Center(
child: Column(
mainAxisAlignment: MainAxisAlignment.center,
children: [
ElevatedButton(
child: const Text('FirstからSecondへ'),
onPressed: () {
// Navigator.of(context).pushNamed('/second');

168

ナビゲーションとルーティング ── 画面遷移を実現する3つの手法

GoRouter.of(context).go('/second');

},

5.2

❶

),

ElevatedButton(

child: const Text('FirstからThirdへ'),
onPressed: () {

// Navigator.of(context).pushNamed('/second/third');
❷
GoRouter.of(context).go('/third');

},

),

],

),

),

}

}

);

class SecondScreen extends StatelessWidget {
const SecondScreen({super.key});
@override
Widget build(BuildContext context) {
return Scaffold(
appBar: AppBar(
title: const Text('SecondScreen'),
),
body: Center(
child: Column(
mainAxisAlignment: MainAxisAlignment.center,
children: [
ElevatedButton(
child: const Text('SecondからThirdへ'),
onPressed: () {
// Navigator.of(context).pushNamed('/second/third');
❸
GoRouter.of(context).go('/third');
},
),
ElevatedButton(
child: const Text('戻る'),
onPressed: () {
Navigator.of(context).pop();
},
),

❹

],

),

),

);

169

第

5 テーマとルーティング
章

}

}

class ThirdScreen extends StatelessWidget {
const ThirdScreen({super.key});
@override

Widget build(BuildContext context) {
return Scaffold(

appBar: AppBar(
title: const Text('ThirdScreen'),
),

body: Center(

child: Column(
mainAxisAlignment: MainAxisAlignment.center,
children: [
ElevatedButton(

child: const Text('戻る'),
onPressed: () {
Navigator.of(context).pop();
},

❺

),

],

),

),

}

}

);

❶〜❸の部分を修正しました。GoRouter クラスの静的メソッド of からイン
スタンスを取り出し、go メソッドを呼び出して画面遷移します。go メソッド
の引数には遷移先のパスを渡します。さっそく、動作を確認してみましょう。
FirstScreen 画 面 か ら SecondScreen 画 面 へ、SecondScreen 画 面 か ら
ThirdScreen 画面へは問題なく遷移します。しかし、画面左上のバックボタ
ンが表示されません。また、SecondScreen 画面の「戻る」
ボタン、ThirdScreen
画面の
「戻る」
ボタンをタップするとアサーションエラーが発生します。
GoRouteで入れ子構造を作る

前項の動作は GoRouter クラスの go メソッドが画面スタックに新しい画面を
プッシュしているわけではなく、画面スタックを置き換えているためです。
FirstScreen 画面から SecondScreen 画面へ遷移（❶）した際に画面スタックは
FirstScreen 画面のみの状態から SecondScreen 画面のみへ書き換えられたの
170

ナビゲーションとルーティング ── 画面遷移を実現する3つの手法

5.2

です
（図 5.8）。
図 5.8

go メソッドでのスタックの変化
Second
Screen

Stack が空になってしまう！

First
Screen

First
Screen

pop

go
Second
Screen

go

Third
Screen

Stack が空になってしまう！
pop
Third
Screen

よって、NavigatorState クラスの pop メソッド（❹、❺）を実行すると戻る
画面が存在しないため、アサーションエラーが発生したのです。
この問題を解決するために、ルートの構成を変更します。
final _router = GoRouter(
routes: [
GoRoute(
path: '/',
builder: (context, state) => const FirstScreen(),
routes: [
GoRoute(
path: 'second',
builder: (context, state) => const SecondScreen(),
),
],
),
// GoRoute(
//
path: '/second',
//
builder: (context, state) => const SecondScreen(),
// ),
GoRoute(

❶

171

第

5 テーマとルーティング
章

path: '/third',

builder: (context, state) => const ThirdScreen(),

),

],

);

SecondScreen 画面への GoRoute を、FirstScreen 画面の GoRoute の routes パ
ラメータに移動しました（❶）。このように、GoRoute は入れ子構造にするこ
とができます。
同様に、ThirdScreen 画面への GoRoute も SecondScreen 画面の GoRoute の入
れ子にしましょう。
final _router = GoRouter(
routes: [
GoRoute(

path: '/',

builder: (context, state) => const FirstScreen(),
routes: [
GoRoute(
path: 'second',
builder: (context, state) => const SecondScreen(),
routes: [
GoRoute(
path: 'third',
builder: (context, state) => const ThirdScreen(),
),
],
),
],

),
// GoRoute(
//
path: '/third',
//
builder: (context, state) => const ThirdScreen(),
// ),

],

);

ThirdScreen 画面への GoRoute も移動しました。これによって、ThirdScreen
画面へのパスが変化しますので、画面遷移処理も修正します。
class FirstScreen extends StatelessWidget {
const FirstScreen({super.key});
@override
Widget build(BuildContext context) {
return Scaffold(

172

ナビゲーションとルーティング ── 画面遷移を実現する3つの手法

5.2

appBar: AppBar(

title: const Text('FirstScreen'),

),

body: Center(

child: Column(
mainAxisAlignment: MainAxisAlignment.center,
children: [

ElevatedButton(
child: const Text('FirstからSecondへ'),
onPressed: () {
GoRouter.of(context).go('/second');
},

),

ElevatedButton(
child: const Text('FirstからThirdへ'),

onPressed: () {
// GoRouter.of(context).go('/third');

GoRouter.of(context).go('/second/third');

},

❶

),

],

),

),

}

}

);

class SecondScreen extends StatelessWidget {
const SecondScreen({super.key});
@override
Widget build(BuildContext context) {
return Scaffold(
appBar: AppBar(
title: const Text('SecondScreen'),
),
body: Center(
child: Column(
mainAxisAlignment: MainAxisAlignment.center,
children: [
ElevatedButton(
child: const Text('SecondからThirdへ'),
onPressed: () {
// GoRouter.of(context).go('/third');
GoRouter.of(context).go('/second/third');
},

❷

),

173

第

5 テーマとルーティング
章

ElevatedButton(

child: const Text('戻る'),
onPressed: () {

// Navigator.of(context).pop();
GoRouter.of(context).pop();

},

❸

),

],

),

),

}

}

);

class ThirdScreen extends StatelessWidget {
const ThirdScreen({super.key});

@override
Widget build(BuildContext context) {
return Scaffold(
appBar: AppBar(
title: const Text('ThirdScreen'),
),
body: Center(
child: Column(
mainAxisAlignment: MainAxisAlignment.center,
children: [
ElevatedButton(
child: const Text('戻る'),
onPressed: () {
// Navigator.of(context).pop();
❹
GoRouter.of(context).pop();
},

),

],

),

),

}

}

);

ThirdScreen 画面への遷移処理を修正しました（❶、❷）
。それでは動作確
認してみましょう。
画面左上のバックボタンは表示され、SecondScreen 画面の「戻る」ボタン、
ThirdScreen 画面の「戻る」ボタンをタップしてもアサーションエラーは発生
しません。さらに、FirstScreen 画面から ThirdScreen 画面への遷移し、
「戻
174

ナビゲーションとルーティング ── 画面遷移を実現する3つの手法

5.2

る」
ボタンをタップすると SecondScreen 画面が表示されます。これは GoRouter
クラスの go メソッドが GoRoute クラスの入れ子構造をそのまま画面スタック
に再現するためです。ThirdScreen 画面の GoRoute は SecondScreen 画面の
GoRoute の routes に追加されていました。そのため、❶を実行すると、画面
スタックは図 5.9 のようになるのです。
図 5.9

go メソッドでのスタックの変化

Third
Screen

First
Screen

go
Third
Screen
Second
Screen
First
Screen

First
Screen

加えて、元の画面に戻る処理は GoRouter クラスの pop メソッドに書き換え
ました（❸、❹）。go_router パッケージでは、Navigator ウィジェットを入れ
子構造で利用する機能があり、この pop メソッドはそのようなケースを考慮
して実装されています。Navigator ウィジェットを入れ子構造にするには
ShellRoute 注 4 クラスを利用します。今回のサンプルでは ShellRoute クラスを
採用していないため GoRouter クラスの pop メソッド、NavigatorState クラス
の pop メソッド、どちらを使っても結果は同じになります。
goとpushの違い

先ほどの例では GoRouter クラスの go メソッドで画面遷移を行いましたが、
画面遷移の要件がより複雑な図 5.10 のような場合を考えてみましょう。

注4

https://pub.dev/documentation/go_router/latest/go_router/ShellRoute-class.html

175

第

5 テーマとルーティング
章

図 5.10

複雑な画面遷移の要件

∞

さらに
FirstScreenへ
SecondScreenへ

First
Screen

ThirdScreenへ

FirstScreenへ

First
Screen

Third
Screen

さらに
SecondScreenへ

Second
Screen

∞

ThirdScreenへ
Third
Screen

Second
Screenへ

Second
Screen

ThirdScreenへ

さらにSecondScreenへ

∞

ThirdScreenへ

Third
Screen

Third
Screen

これを GoRoute クラスの入れ子構造で表現するのは困難です。このような
ケースにも対応できるよう、go_router パッケージは画面スタックにプッシュ
するメソッドも提供しています。この機能を使い、図 5.10 のような画面遷移
を実現してみましょう。まずは、FirstScreen 画面から修正します。
class FirstScreen extends StatelessWidget {
const FirstScreen({super.key});
@override
Widget build(BuildContext context) {
return Scaffold(
appBar: AppBar(
title: const Text('FirstScreen'),
),
body: Center(
child: Column(
mainAxisAlignment: MainAxisAlignment.center,
children: [
ElevatedButton(
child: const Text('FirstからFirstへ'),
onPressed: () {
❶
GoRouter.of(context).push('/');
},
),

176

ナビゲーションとルーティング ── 画面遷移を実現する3つの手法

5.2

ElevatedButton(

child: const Text('FirstからSecondへ'),
onPressed: () {

// GoRouter.of(context).go('/second');
GoRouter.of(context).push('/second');

},

❷

),

ElevatedButton(
child: const Text('FirstからThirdへ'),

onPressed: () {
// GoRouter.of(context).go('/second/third');
GoRouter.of(context).push('/second/third');

},

❸

),

],

),

),

}

}

);

FirstScreen 画面から FirstScreen 画面へ遷移するボタンを追加しました
（❶）
。また SecondScreen 画面、ThirdScreen 画面への遷移処理を go メソッド
から push メソッドに変更しました（❷、❸）。
続いて、SecondScreen 画面を修正します。
class SecondScreen extends StatelessWidget {
const SecondScreen({super.key});
@override
Widget build(BuildContext context) {
return Scaffold(
appBar: AppBar(
title: const Text('SecondScreen'),
),
body: Center(
child: Column(
mainAxisAlignment: MainAxisAlignment.center,
children: [
ElevatedButton(
child: const Text('SecondからSecondへ'),
onPressed: () {
GoRouter.of(context).push('/second');
},
),
ElevatedButton(

❶

177

第

5 テーマとルーティング
章

child: const Text('SecondからThirdへ'),

onPressed: () {
// GoRouter.of(context).go('/second/third');
GoRouter.of(context).push('/second/third');

},

❷

),

ElevatedButton(

child: const Text('戻る'),
onPressed: () {

GoRouter.of(context).pop();

},

),

],

),

),

}

}

);

SecondScreen 画面から SecondScreen 画面へ遷移するボタンを追加しました
（❶）。ThirdScreen 画面への遷移処理を go メソッドから push メソッドに変更
しました（❷）
。
それでは動作を確認してみましょう。おおむね期待どおりに動作している
ように見えますが、FirstScreen 画面から ThirdScreen 画面へ遷移した際に中
間の SecondScreen 画面がスタックに積まれなくなってしまいました（図 5.11）
。
図 5.11

push メソッドでのスタックの変化

Third
Screen

First
Screen

push

Third
Screen
First
Screen

First
Screen

GoRouter クラスの push メソッドは Navigator 1.0 の push メソッドと同様に、

1 つ の Route ク ラ ス を ス タ ッ ク に プ ッ シ ュ す る こ と し か で き ま せ ん。
FirstScreen 画面から ThirdScreen 画面への遷移処理は、GoRouter クラスの
178

ナビゲーションとルーティング ── 画面遷移を実現する3つの手法

5.2

go メソッドに戻してみましょう。
class FirstScreen extends StatelessWidget {
const FirstScreen({super.key});
@override

Widget build(BuildContext context) {
return Scaffold(
appBar: AppBar(

title: const Text('FirstScreen'),

),

body: Center(
child: Column(

mainAxisAlignment: MainAxisAlignment.center,
children: [

ElevatedButton(
child: const Text('FirstからFirstへ'),
onPressed: () {
GoRouter.of(context).push('/');
},

),
ElevatedButton(
child: const Text('FirstからSecondへ'),
onPressed: () {
GoRouter.of(context).push('/second');
},
),
ElevatedButton(
child: const Text('FirstからThirdへ'),
onPressed: () {
// GoRouter.of(context).push('/second/third');
❶
GoRouter.of(context).go('/second/third');
},

),

],

),

),

}

}

);

FirstScreen 画面から ThirdScreen 画面への遷移処理を go メソッドに戻し
ました（❶）
。これで、ThirdScreen 画面へ遷移し、
「戻る」ボタンをタップす
ると SecondScreen 画面が表示されるようになりました。しかし、図 5.12 のよ
うに遷移すると一部の FirstScreen 画面がスタックから消えてしまいます。

179

第

5 テーマとルーティング
章

図 5.12

go メソッドでのスタックの変化

First
Screen

First
Screen

push

First
Screen

Third
Screen

First
Screen

push

go
First
Screen

Third
Screen

First
Screen

First
Screen

Second
Screen

First
Screen

First
Screen

First
Screen

go メソッドは GoRoute の入れ子構造をそのまま画面スタックに再現するの
でした。そのため、push メソッドで複数の FirstScreen 画面をスタックに積
んだとしても、その後 go メソッドで遷移するとスタックが書き換えられ、
FirstScreen 画面は 1 つしかスタックに残らないのです。
画面スタックをどのように変化させたいのかを意識して、適切なメソッド
を選択しましょう。

5.3
まとめ
Flutter フレームワークが提供する「テーマ」と「画面遷移」に関する機能を紹
介しました。
MaterialApp ウィジェットや ThemeData クラスを使うことで、マテリアルデ
ザインにのっとったアプリを簡単に作ることができます。ThemeData クラス
がテーマを自動計算してくれるので、テーマのカスタマイズやダークモード
対応も容易です。
アプリ独自のテーマ、世界観を演出するなら、Theme Extension を使うの
がよいでしょう。
アプリの画面遷移の実装方法を学ぶために、Navigator 1.0 と Navigator 2.0
の違いを確認しました。シンプルな画面遷移であれば Navigator 1.0 の push メ
ソッド、pop メソッドで対応できるケースも十分あるでしょう。複雑な画面
遷移を実装する場合は Navigator 2.0 が候補に挙がります。本章では、例とし
て go_router パッケージを使った画面遷移の実装を紹介しました。
180

第

6

章

実践ハンズオン❶
画像編集アプリを開発

181

第

6 実践ハンズオン❶
章

画像編集アプリを開発

本章では Flutter アプリをハンズオン形式で実装していきます。簡単な画像
編集アプリを作成する過程で、第 4 章や第 5 章で学んだ内容を実践します。本
章のハンズオンでは iOS Simulator を使用します。あわせてもらえばすべて
の工程を体験できます。なお、本章でも fvm コマンドを省略して flutter コマ
ンドを記載しています。ご自身の環境、コマンドを実行するディレクトリに
あわせて読み替えてください。
図 6.1 が完成イメージです。
図 6.1

アプリの完成イメージ
StartScreen
ウィジェット

SnapSelectScreen
ウィジェット

EditSnapScreen
ウィジェット

6.1
開発するアプリの概要
このハンズオンで実装するアプリの概要を説明します。スマートフォンの
画像ライブラリから取得した画像を回転、反転させて編集するアプリです。
画面は全部で 3 つあります。

スタート画面
アプリ起動後に表示される画面です
（図 6.2）。現在の日付が表示され、
「開
始する」
ボタンをタップすると画像選択画面に遷移します。
182

開発するアプリの概要

図 6.2

6.1

スタート画面

画像選択画面
スマートフォンの画像ライブラリから画像を選択する画面です（図 6.3）
。
「画
像を選ぶ」
ボタンをタップすると画像ライブラリから画像を選択でき、選択し
た画像はプレビューされます。画像ライブラリへのアクセスは image_picker
というパッケージを使用します。また、画像のプレビューのために image パ
ッケージを使用します。
「画像を編集する」ボタンをタップすると画像編集画
面に遷移します。

183

第

6 実践ハンズオン❶
章

画像編集アプリを開発

図 6.3

画像選択画面

画像編集画面
選択した画像を回転、反転させる画面です（図 6.4）
。画像の回転は 90 度単
位で行います。画像の回転、反転には image パッケージを使用します。
図 6.4

184

画像編集画面

プロジェクトを作成する

6.2

開発の土台づくり
第 4 章で解説した「開発の土台づくり」の要素です。アプリは日本語にロー
カライズし、アセットは flutter_gen パッケージを使用して管理します。環境
変数は特に設定しません。
導入するパッケージは表 6.1 のとおりです。
表 6.1

導入するパッケージ一覧

パッケージ名

用途

intl

アプリのローカライズ

image_picker

画像ライブラリへのアクセス

image

画像データの加工

flutter_svg

SVG 画像の表示

build_runner

flutter_gen のコード生成

flutter_gen_runner

アセットの管理

テーマと画面遷移の方針
テ ー マ は Material Design 3 の テ ー マ を 使 用 し ま す。テ ー マ の 変 更 は
ColorScheme クラスの seedColor のみを変更するにとどめます。
画面遷移は Navigator 1.0 の API のみを使用します。

6.2
プロジェクトを作成する
新たにプロジェクトを作成します。第 1 章の
「1.1 プロジェクトの作成」
で示
した手順に従って、プロジェクトを作成してください。プロジェクト名は
「edit_snap」としましょう。プロジェクト作成直後は lib/main.dart にテンプ
レートになるアプリコードが書かれていますので、不要なコードを削除して
しまいましょう。
./lib/main.dart

import 'package:flutter/material.dart';
void main() {

185

第

6 実践ハンズオン❶
章

画像編集アプリを開発

}

runApp(const MyApp());

class MyApp extends StatelessWidget {
const MyApp({super.key});
@override

Widget build(BuildContext context) {
return MaterialApp(

// Androidのタスクマネージャーに表示されるアプリ名
// iOSでは使用されません
title: 'Edit Snap',
theme: ThemeData(

colorScheme: ColorScheme.fromSeed(seedColor: Colors.deepPurple),
useMaterial3: true,

),
home: Container(),

}

}

);

開発の土台づくり
本来であれば、開発をスタートするこの段階でアプリのローカライズやア
セット管理のしくみを整えておくことが望ましいです。しかし、本章では各
種しくみの導入前後の違いを比較しやすいよう、後工程で導入することにし
ます。

6.3
アプリ起動後のスタート画面を作成する
アプリ起動後に表示されるスタート画面を作成します。スタート画面のコ
ードを記述するファイルを作成します。Android Studio の左側にある Project
ビューで lib フォルダを右クリックし、「New」➡「Dart File」
を選択します。フ
と入力して
ァイル名を入力するダイアログが表示されるので、「start_screen」
「OK」ボタンをクリックします。
ひとまず、スタート画面は中央に文字を表示するだけのシンプルなものに
しておきます。
186

アプリ起動後のスタート画面を作成する

6.3

./lib/start_screen.dart

import 'package:flutter/material.dart';
class StartScreen extends StatelessWidget {
const StartScreen({super.key});
@override

Widget build(BuildContext context) {
return Scaffold(
body: Center(

child: Text('Start Screen'),

),

}

}

);

続いて、アプリ起動後にスタート画面が表示されるように main.dart を修
正します。
./lib/main.dart

import 'package:edit_snap/start_screen.dart';
import 'package:flutter/material.dart';

❶

void main() {
runApp(const MyApp());
}
class MyApp extends StatelessWidget {
const MyApp({super.key});
@override
Widget build(BuildContext context) {
return MaterialApp(
// Androidのタスクマネージャーに表示されるアプリ名
// iOSでは使用されません
title: 'Edit Snap',
theme: ThemeData(
colorScheme: ColorScheme.fromSeed(seedColor: Colors.deepPurple),
useMaterial3: true,
),
❷
home: const StartScreen(),

}

}

);

先ほど実装した StartScreen ウィジェットを参照するため、start_screen.
187

第

6 実践ハンズオン❶
章

画像編集アプリを開発

dart をインポートしました（❶）。MaterialApp ウィジェットの home パラメー
タに StartScreen 画面を渡しました
（❷）。ここでアプリを実行すると、図 6.5
のようにスタート画面が表示されます。
図 6.5

スタート画面

レイアウトを作成する
スタート画面のレイアウトを作成していきます。Android Studio で start_
screen.dart を開き、StartScreen クラスの build メソッドを以下のように修
正します。
./lib/start_screen.dart

import 'package:flutter/material.dart';
class StartScreen extends StatelessWidget {
const StartScreen({super.key});
@override
Widget build(BuildContext context) {
return Scaffold(
appBar: AppBar(

backgroundColor: Theme.of(context).colorScheme.inversePrimary,
title: const Text('Edit Snap'),

),
body: Center(

188

❶

アプリ起動後のスタート画面を作成する

6.3

child: Column(

mainAxisAlignment: MainAxisAlignment.center,
children: [
Text(

'こんにちは！\n今日は${DateTime.now()}です。',
textAlign: TextAlign.center,

❷

),

ElevatedButton(
child: const Text('開始する'),
onPressed: () {},

❸

),

],

),

),

}

}

);

上 部 に AppBar ウ ィ ジ ェ ッ ト（❶）が あ り、Text ウ ィ ジ ェ ッ ト（❷）と
ElevatedButton ウィジェット
（❸）が垂直方向に並ぶ画面です。❷と❸を垂直
方向に並べるために Column ウィジェットで囲みました。これを実行すると、

iOS Simulator 上で図 6.6 のように表示されます。
図 6.6

レイアウト作成後のスタート画面

189

第

6 実践ハンズオン❶
章

画像編集アプリを開発

6.4
テーマをアレンジする
アプリのテーマを好みにアレンジしてみましょう。MaterialApp ウィジェ
ットに渡す theme パラメータを変更します。
./lib/main.dart

// 省略

class MyApp extends StatelessWidget {
const MyApp({super.key});
@override
Widget build(BuildContext context) {
return MaterialApp(

title: 'Edit Snap',
theme: ThemeData(
colorScheme: ColorScheme.fromSeed(seedColor: Colors.teal),
useMaterial3: true,
),
home: const StartScreen(),

}

}

❶

);

ColorScheme クラスのコンストラクタに渡す seedColor パラメータを変更し
ました（❶）
。再びアプリを実行するとテーマが変更され、AppBar ウィジェッ
トや ElevatedButton ウィジェットの色が変わります。

6.5
アプリを日本語化する
アプリ内で表示する文字列を日本語化し、arb ファイルでメッセージを管理
します。各コードのより詳しい説明は第 4 章を参照してください。

パッケージを導入する
まずはパッケージを 2 つ
（flutter_localizations と intl）
を導入します。プロジェ
クトのディレクトリで、ターミナルから以下のコマンドを実行してください。
190

アプリを日本語化する

6.5

# flutter_localizationsパッケージを導入

$ flutter pub add flutter_localizations --sdk=flutter
# intlパッケージを導入
$ flutter pub add intl:any

次に pubspec.yaml を開き、以下のように追記します。
./pubspec.yaml

＃ 省略
flutter:

uses-material-design: true
❶
generate: true

コードジェネレータの設定のため flutter キーの下に generate: true を追
加しました
（❶）
。生成されたコードをプロジェクトから参照できるように以
下のコマンドを実行します。
$ flutter pub get

ローカライズの構成ファイルを作成する
次にローカライズの構成ファイルを作成します。左側の Project ビューでプ
を選択します。ファイル名
ロジェクトルートを右クリックし、「New」➡「File」
と入力して
「OK」
ボタン
を入力するダイアログが表示されるので、「l10n.yaml」
をクリックします。
構成ファイルは以下のように記述します。各パラメータの詳細は第 4 章を
参照してください。
./l10n.yaml

template-arb-file: app_ja.arb
output-class: L10n
nullable-getter: false

arbファイルを作成する
メッセージを管理する arb ファイルを作成します。左側の Project ビューで
lib フォルダを右クリックし、「New」➡「Directory」を選択します。フォルダ
と入力して
「OK」
ボタンを
名を入力するダイアログが表示されるので、「l10n」
191

第

6 実践ハンズオン❶
章

画像編集アプリを開発

クリックします。
次に l10n フォルダを右クリックし、「New」➡「File」を選択します。ファイ
ル名を入力するダイアログが表示されるので、「app_ja.arb」と入力して「OK」
ボタンをクリックします。arb ファイルは以下のように記述します。
./lib/l10n/app_ja.arb

{

"startScreenTitle": "Edit Snap",
"helloWorldOn": "こんにちは！\n今日は{date}です",
"@helloWorldOn": {

"placeholders": {
"date": {

}

}

}

"type": "DateTime",
"format": "MEd"

❶

},
"start": "開始する"

スタート画面のメッセージには日付を埋め込みます。キーhelloWorldOn に
プレースホルダを設定し、日付のフォーマットを指定しました
（❶）
。type は
日付型として DateTime、format は MEd
（月、日、短縮系の曜日で構成されるフ
ォーマット）
です。

arb ファイルを作成したら、以下のコマンドでコードジェネレータを実行し
ます。
$ flutter gen-l10n

ローカライズされたメッセージを適用する
コードジェネレータが完了したら、生成されたメッセージをコードに反映
させましょう。main.dart を以下のように修正します。
./lib/main.dart

import 'package:edit_snap/start_screen.dart';
import 'package:flutter/material.dart';
import 'package:flutter_gen/gen_l10n/app_localizations.dart';
void main() {
runApp(const MyApp());

192

❶

アプリを日本語化する

6.5

}
class MyApp extends StatelessWidget {
const MyApp({super.key});
@override

Widget build(BuildContext context) {

return MaterialApp(
localizationsDelegates: L10n.localizationsDelegates,
❸
supportedLocales: L10n.supportedLocales,

❷

title: 'Edit Snap',
theme: ThemeData(

colorScheme: ColorScheme.fromSeed(seedColor: Colors.teal),
useMaterial3: true,

),

home: const StartScreen(),

}

}

);

生成されたコードをインポートし（❶）
、対応言語
（今回は日本語のみ）
の翻
訳データと対応言語のリストを渡します（❷、❸）
。
start_screen.dart は以下のように修正します。
./lib/start_screen.dart

import 'package:flutter/material.dart';
import 'package:flutter_gen/gen_l10n/app_localizations.dart';

❶

class StartScreen extends StatelessWidget {
const StartScreen({super.key});
@override
Widget build(BuildContext context) {
❷
final l10n = L10n.of(context);
return Scaffold(
appBar: AppBar(
backgroundColor: Theme.of(context).colorScheme.inversePrimary,
❸
title: Text(l10n.startScreenTitle),
),
body: Center(
child: Column(
mainAxisAlignment: MainAxisAlignment.center,
children: [
Text(
❹
l10n.helloWorldOn(DateTime.now()),
textAlign: TextAlign.center,

),

193

第

6 実践ハンズオン❶
章

画像編集アプリを開発

ElevatedButton( // 「開始する」ボタン
❺
child: Text(l10n.start),
onPressed: () {},

),

],

),

),

}

}

);

こちらも生成コードをインポートし（❶）、各メッセージを生成コードから
取得します
（❷、❸、❹、❺）。

App Storeでの表示言語を設定する
最後に iOS ネイティブの対応言語を設定します。これは App Store に表示さ
れ る ア プ リ の 対 応 言 語 に影 響 し ま す。ios/Runner/Info.plist を 開 き、
CFBundleLocalizations キーの下に ja を追加します。
./ios/Runner/Info.plist

<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/
PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
<!-- 省略 -->
<key>CFBundleLocalizations</key>
<array>
<string>ja</string>
</array>
</dict>
</plist>

これで日本語化が完了しました。アプリを実行してみましょう。図 6.7 の
ように日付のフォーマットが日本語になっていることが確認できます。

194

画像選択画面を作成する

図 6.7

6.6

日本語化したスタート画面

6.6
画像選択画面を作成する
スマートフォンの画像ライブラリから画像を選択する画面を作成します。

メッセージを追加する
画像選択画面で使用するメッセージを arb ファイルに追加します。
./lib/l10n/app_ja.arb

{

}

// 省略
// （一つ上の行の末尾にカンマを追加してください）
"imageSelectScreenTitle": "画像を選択",
"imageSelect": "画像を選ぶ",
"imageEdit": "画像を編集する"

arb ファイルに追加したらコードジェネレータを実行します。
$ flutter gen-l10n

195

第

6 実践ハンズオン❶
章

画像編集アプリを開発

レイアウトを作成する
次に画像選択画面のコードを記述するファイルを作成します。左側の Project
ビューで lib フォルダを右クリックし、「New」➡「Dart File」
を選択します。フ
ァイル名を入力するダイアログが表示されるので、「image_select_screen」と
ボタンをクリックします。
入力して「OK」
画像選択画面は StatefulWidget を継承したクラスで実装します。
./lib/image_select_screen.dart

import 'package:flutter/material.dart';

import 'package:flutter_gen/gen_l10n/app_localizations.dart';
class ImageSelectScreen extends StatefulWidget {
const ImageSelectScreen({super.key});

}

@override
State<ImageSelectScreen> createState() => _ImageSelectScreenState();

class _ImageSelectScreenState extends State<ImageSelectScreen> {
@override
Widget build(BuildContext context) {
final l10n = L10n.of(context);
return Scaffold(
appBar: AppBar(
backgroundColor: Theme.of(context).colorScheme.inversePrimary,
title: Text(l10n.imageSelectScreenTitle),
),
body: Center(
child: Column(
mainAxisAlignment: MainAxisAlignment.center,
children: [
ElevatedButton( // 「画像を選ぶ」ボタン
onPressed: () {},
child: Text(l10n.imageSelect),
),
ElevatedButton( // 「画像を編集する」ボタン
onPressed: () {
},
child: Text(l10n.imageEdit),
),
],
),
),

196

画像選択画面を作成する

}

}

6.6

);

レイアウトはスタート画面とおおむね同じです。上部に AppBar ウィジェッ
トがあり、「画像を選ぶ」ボタンと「画像を編集する」
ボタンが垂直方向に並び
ます。
続いて、スタート画面から画像選択画面に遷移する処理を実装します。
./lib/start_screen.dart

import 'package:edit_snap/image_select_screen.dart';

❶

import 'package:flutter/material.dart';
import 'package:flutter_gen/gen_l10n/app_localizations.dart';
class StartScreen extends StatelessWidget {
const StartScreen({super.key});
@override
Widget build(BuildContext context) {
final l10n = L10n.of(context);
return Scaffold(
appBar: AppBar(
backgroundColor: Theme.of(context).colorScheme.inversePrimary,
title: Text(l10n.startScreenTitle),
),
body: Center(
child: Column(
mainAxisAlignment: MainAxisAlignment.center,
children: [
Text(
l10n.helloWorldOn(DateTime.now()),
textAlign: TextAlign.center,
),
ElevatedButton( // 「開始する」ボタン
child: Text(l10n.start),
onPressed: () {
Navigator.of(context).push(
MaterialPageRoute(
builder: (context) => const ImageSelectScreen(),
❷
),
);
},
),
],
),
),

197

第

6 実践ハンズオン❶
章

画像編集アプリを開発

}

}

);

画像選択画面のクラスを参照するため image_select_screen.dart をインポ
ートしました（❶）
。
「開始する」ボタンの onPressed コールバックで画像選択
画面に遷移する処理を実装しました（❷）
。今回はシンプルに Navigator 1.0 の

API を採用し、MaterialPageRoute を使用した画面遷移です。
これで画像選択画面に遷移する処理が実装できました。アプリを実行し、
スタート画面の「開始する」ボタンをタップしてみましょう。図 6.8 のように
画像選択画面に遷移します。
図 6.8

画像選択画面

画像ライブラリから画像を取得する
スマートフォンの画像ライブラリから画像を取得する処理は、image_picker
パッケージを使用します。また画像データを取り扱うために image パッケー
ジも使用します。
パッケージを導入する

パッケージを導入するためにプロジェクトのディレクトリで、ターミナル
から以下のコマンドを実行してください。
198

画像選択画面を作成する

6.6

# imageパッケージとimage_pickerパッケージを導入
$ flutter pub add image image_picker

iOSネイティブの設定を行う

続いて iOS ネイティブの設定を行います。画像ライブラリにアクセスする

iOS アプリは、その用途を伝える説明文を記述する必要があります。ios/
Runner/Info.plist を開き、NSPhotoLibraryUsageDescription キーの下に説
明文を追加します。
./ios/Runner/Info.plist

<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/
PropertyList-1.0.dtd">
<plist version="1.0">

<!-- 省略 -->
<key>NSPhotoLibraryUsageDescription</key>
<string>編集する画像を選択します。</string>
</dict>
</plist>

画像を取得する処理を実装する

それでは画像を取得する処理を実装します。
./lib/image_select_screen.dart

❶
import 'package:flutter/foundation.dart';
import 'package:flutter/material.dart';
import 'package:flutter_gen/gen_l10n/app_localizations.dart';
❷
import 'package:image_picker/image_picker.dart';
❸
import 'package:image/image.dart' as image_lib;

class ImageSelectScreen extends StatefulWidget {
const ImageSelectScreen({super.key});

}

@override
State<ImageSelectScreen> createState() => _ImageSelectScreenState();

class _ImageSelectScreenState extends State<ImageSelectScreen> {
/* ◆ ImagePicker
image_pickerパッケージが提供するクラス
画像ライブラリやカメラにアクセスする機能を持つ */
❹
final ImagePicker _picker = ImagePicker();

199

第

6 実践ハンズオン❶
章

画像編集アプリを開発

/* ◆ Uint8List

8bit 符号なし整数のリスト */
❺
Uint8List? _imageBitmap;
Future<void> _selectImage() async {
/* ◆ XFile

❻

ファイルの抽象化クラス */

// 画像を選択する
final XFile? imageFile = await _picker.pickImage(source: ImageSource.gallery);
// ファイルオブジェクトから画像データを取得する

❼

❽

final imageBitmap = await imageFile?.readAsBytes();
assert(imageBitmap != null);

if (imageBitmap == null) return;
// 画像データをデコードする
final image = image_lib.decodeImage(imageBitmap);
assert(image != null);
if (image == null) return;

❾

/* ◆ Image
画像データとメタデータを内包したクラス */
final image_lib.Image resizedImage;
if (image.width > image.height) {
// 横長の画像なら横幅を500pxにリサイズする
resizedImage = image_lib.copyResize(image, width: 500);
} else {
// 縦長の画像なら縦幅を500pxにリサイズする
resizedImage = image_lib.copyResize(image, height: 500);
}

}

// 画像をエンコードして状態を更新する
setState(() {
_imageBitmap = image_lib.encodeBmp(resizedImage);
});

❿

⓫

@override
Widget build(BuildContext context) {
// 省略

まず、必要なパッケージ群をインポートします。flutter/foundation.dart
は、画像データとして Uint8List 型を使用するためにインポートしました（❶）
。
image_picker/image_picker.dart は画像ライブラリへのアクセスするパッケ
ージ、image/image.dart は画像データを扱うパッケージを使用するためにイ
ンポートしました（❷、❸）。image パッケージの Image クラスは、画像を表示
200

画像選択画面を作成する

6.6

する Image ウィジェットと名前が競合します。そのため as キーワードに続け
て image_lib という別名を付けています
（❸）。こうすると image_lib.Image と
記述すると image パッケージの Image クラスを参照できます。
_ImageSelectScreenState クラスでは、画像を取得するためにパッケージ

image_picker が提供する ImagePicker クラスをインスタンス化しました（❹）。
このクラスは画像ライブラリやカメラへアクセスする機能を提供します。実
際の画像選択処理は _selectImage メソッドで実装しました
（❻）
。
ImagePicker クラスにて画像を取得すると、画像データは XFile というファ
イルを抽象化したクラスで返されます（❼）。XFile クラスから画像のバイト
列を取得し（❽）、image パッケージの decodeImage メソッドで画像データをデ
コードします（❾）。iOS Simulator は初期状態で画像ライブラリにいくつか写
真が登録されていますが、これらの画像はサイズが大きいため、そのままで
は表示に時間がかかる場合があります。今回は❿でリサイズして扱いやすく
しています。
最後に画像データをバイト列に戻し、状態を更新します（⓫）
。
画像取得処理をWidgetに組み込む

前項で実装した画像取得処理を Widget と組み合わせてみましょう。
./lib/image_select_screen.dart

// 省略
class _ImageSelectScreenState extends State<ImageSelectScreen> {
final ImagePicker _picker = ImagePicker();
Uint8List? _imageBitmap;
Future<void> _selectImage() async {
// 省略
}
@override
Widget build(BuildContext context) {
final l10n = L10n.of(context);
final imageBitmap = _imageBitmap;

❶

return Scaffold(
appBar: AppBar(
backgroundColor: Theme.of(context).colorScheme.inversePrimary,
title: Text(l10n.imageSelectScreenTitle),

201

第

6 実践ハンズオン❶
章

画像編集アプリを開発

),

body: Center(
child: Column(

mainAxisAlignment: MainAxisAlignment.center,

children: [
if (imageBitmap != null) Image.memory(imageBitmap),
ElevatedButton( // 「画像を選ぶ」ボタン
❸
onPressed: () => _selectImage(),

❷

child: Text(l10n.imageSelect),

),
if (imageBitmap != null)

❹

ElevatedButton( // 「画像を編集する」ボタン
onPressed: () {

},
child: Text(l10n.imageEdit),

],

),

),

),

}

);

build メソッドでは、画像のバイト列を変数 imageBitmap に格納しました
（❶）。クラス変数の _imageBitmap は null 許容型です。一時変数に置き、if 文
で null チェックをすることでタイププロモーションが働き、非 null 許与型の
ように扱えるようになります（❷）。
imageBitmap が null でない、すなわち画像が選択されたあとであれば画像を
表示し
（❸）
、
「画像を編集する」ボタンを表示します（❹）
。
動作を確認してみましょう。画像を選択すると図 6.9 のように画像が表示
されます。

202

画像編集画面を作成する

図 6.9

6.7

画像選択後の画像選択画面

6.7
画像編集画面を作成する
画像を回転、反転させる編集画面を作成します。

メッセージを追加する
まず編集画面で使用する文字列を arb ファイルに追加します。
./lib/l10n/app_ja.arb

{

}

// 省略
// （一つ上の行の末尾にカンマを追加してください）
"imageEditScreenTitle": "画像を編集"

arb ファイルに追加したらコードジェネレータを実行します。
$ flutter gen-l10n

203

第

6 実践ハンズオン❶
章

画像編集アプリを開発

レイアウトを作成する
次にコードを記述するファイルを作成します。ファイル名は edit_snap_
screen.dart としましょう。画像編集画面も StatefulWidget を継承したクラス
で実装します。
./lib/edit_snap_screen.dart

import 'package:flutter/foundation.dart';

import 'package:flutter/material.dart';
import 'package:flutter_gen/gen_l10n/app_localizations.dart';
class ImageEditScreen extends StatefulWidget {
const ImageEditScreen({super.key, required this.imageBitmap});
final Uint8List imageBitmap;

}

❶

@override
State<ImageEditScreen> createState() => _ImageEditScreenState();

class _ImageEditScreenState extends State<ImageEditScreen> {
@override
Widget build(BuildContext context) {
final l10n = L10n.of(context);
return Scaffold(
appBar: AppBar(
backgroundColor: Theme.of(context).colorScheme.inversePrimary,
title: Text(l10n.imageEditScreenTitle),
),
body: Center(
child: Column(
mainAxisAlignment: MainAxisAlignment.center,
children: [
❷
Image.memory(widget.imageBitmap),

/* ◆ IconButton
アイコンを表示するボタン */
IconButton(
onPressed: () {},
icon: const Icon(Icons.rotate_left), // フレームワーク組み込みのア

イコンを設定

),
IconButton(
onPressed: () {},
icon: const Icon(Icons.flip), // フレームワーク組み込みのアイコンを設定
),

204

❸

画像編集画面を作成する

6.7

],

),

),

}

}

);

表示する画像はウィジェットのコンストラクタで受け取るようにしました
（❶）
。レイアウトは上部に AppBar ウィジェットがあり、画像を表示する Image
ウィジェット（❷）と IconButton ウィジェット（❸）が垂直方向に並びます。
IconButton ウィジェットには Flutter フレームワーク組み込みのアイコンを設
定しました。

画像編集画面への遷移を実装する
続いて、画像編集画面に遷移する処理を実装します。
./lib/image_select_screen.dart

import 'package:flutter/foundation.dart';
import 'package:flutter/material.dart';
import 'package:flutter_gen/gen_l10n/app_localizations.dart';
❶
import 'package:edit_snap/edit_snap_screen.dart';
// 省略
class _ImageSelectScreenState extends State<ImageSelectScreen> {
// 省略
@override
Widget build(BuildContext context) {
final l10n = L10n.of(context);
final imageBitmap = _imageBitmap;
return Scaffold(
appBar: AppBar(
backgroundColor: Theme.of(context).colorScheme.inversePrimary,
title: Text(l10n.imageSelectScreenTitle),
),
body: Center(
child: Column(
mainAxisAlignment: MainAxisAlignment.center,
children: [
if (imageBitmap != null) Image.memory(imageBitmap),
ElevatedButton( // 「画像を選ぶ」ボタン

205

第

6 実践ハンズオン❶
章

画像編集アプリを開発

onPressed: () => _selectImage(),
child: Text(l10n.imageSelect),

),

if (imageBitmap != null)

ElevatedButton( // 「画像を編集する」ボタン
onPressed: () {
Navigator.of(context).push(

MaterialPageRoute(
builder: (context) => ImageEditScreen(
imageBitmap: imageBitmap,

),

❷

),

);

},
child: Text(l10n.imageEdit),

],

),

),

),

}

}

);

ImageEditScreen 画面を参照するため image_select_screen.dart をインポ
ートしました（❶）
。
「画像を編集する」ボタンの onPressed コールバックで画
像編集画面に遷移する処理を実装しました（❷）。こちらも Navigator 1.0 の API
を採用し、MaterialPageRoute クラスを使用した画面遷移です。
これで画像編集画面に遷移する処理が実装できました。アプリを実行し、
画像編集画面へ遷移させてみましょう。図 6.10 のように表示されます。

206

画像編集画面を作成する

図 6.10

6.7

画像編集画面

アイコンを追加する ── flutter_genによるアセット管理
先ほど IconButton ウィジェットに Flutter フレームワーク組み込みのアイコ
ンを設定しましたが、アプリ独自のアイコンに置き換えてみましょう。
アセットを扱うために flutter_gen を利用します。パッケージを導入するた
めにプロジェクトのディレクトリで、ターミナルから以下のコマンドを実行
してください。
# build_runnerパッケージとflutter_gen_runnerパッケージを導入
$ flutter pub add --dev build_runner flutter_gen_runner
# flutter_svgパッケージを導入
$ flutter pub add flutter_svg

flutter_gen を使用するために flutter_gen_runner と build_runner パッケージを
導入しました。SVG ファイルを扱うために flutter_svg パッケージも導入しました。

flutter_gen で SVG ファイルを有効にするため、pubspec.yaml に以下の設定
を追加します。
./pubspec.yaml

# 省略
flutter_gen:
integrations:
flutter_svg: true

続いてプロジェクトに独自のアイコンをアセットとして追加します。今回
207

第

6 実践ハンズオン❶
章

画像編集アプリを開発

は iconmonstr というサイトからアイコンを利用させてもらいます。
・https://iconmonstr.com/

イメージを検索して、SVG ファイルをダウンロードします。今回は
「Refresh

- Lined」と「Layout Vertical - Lined」というアイコンをダウンロードし、それぞ
れ rotate_icon.svg と flip_icon.svg という名前で保存します。
ダウンロードしたファイルを以下のように assets フォルダに配置します。
~/project_root
└── assets
├── flip_icon.svg
└── rotate_icon.svg

pubspec.yaml にて、assets キーを追加します。
./pubspec.yaml

# 省略

flutter:
# 省略
assets:
- assets/

アセットの追加が完了したら、以下のコマンドを実行してアイコンを扱う
コードを生成します。
$ flutter packages pub run build_runner build

それでは追加したアイコンをコードに反映させましょう。
./lib/edit_snap_screen.dart

❶
import 'package:edit_snap/gen/assets.gen.dart';
// 省略
class _ImageEditScreenState extends State<ImageEditScreen> {

@override
Widget build(BuildContext context) {
final l10n = L10n.of(context);
return Scaffold(
appBar: AppBar(
backgroundColor: Theme.of(context).colorScheme.inversePrimary,
title: Text(l10n.imageEditScreenTitle),
),
body: Center(
child: Column(
mainAxisAlignment: MainAxisAlignment.center,

208

画像編集画面を作成する

6.7

children: [

Image.memory(widget.imageBitmap),
IconButton(
onPressed: () {},

icon: Assets.rotateIcon.svg(
width: 24,

❷

height: 24,

),

),

IconButton(
onPressed: () {},

icon: Assets.flipIcon.svg(
width: 24,

height: 24,

❸

),

),

],

),

),

}

}

);

flutter_gen が生成したコードをインポートし
（❶）
、IconButtonウィジェットの
（❷、
iconプロパティに flutter_gen で生成したコードからアイコンを設定しました
❸）
。アプリを実行してアイコンが変更されていることを確認しましょう
（図6.11）
。
図 6.11

アイコンを変更した画像編集画面

209

第

6 実践ハンズオン❶
章

画像編集アプリを開発

画像を編集する処理を実装する
画像を回転、反転させる処理を実装します。
./lib/edit_snap_screen.dart

// 省略

import 'package:image/image.dart' as image_lib;

❶

// 省略
class _ImageEditScreenState extends State<ImageEditScreen> {
late Uint8List _imageBitmap;

❷

@override

void initState() {
super.initState();
}

_imageBitmap = widget.imageBitmap;

❸

❹
void _rotateImage() {
// 画像データをデコードする
final image = image_lib.decodeImage(_imageBitmap);
if (image == null) return;
// 画像を時計回りに90°回転する
final rotateImage = image_lib.copyRotate(image, angle: 90);
// 画像をエンコードして状態を更新する
setState(() {
_imageBitmap = image_lib.encodeBmp(rotateImage);
});
}
❺
void _flipImage() {
// 画像データをデコードする
final image = image_lib.decodeImage(_imageBitmap);
if (image == null) return;
// 画像を水平方向に反転する
final flipImage = image_lib.copyFlip(
image,
direction: image_lib.FlipDirection.horizontal,
);
// 画像をエンコードして状態を更新する
setState(() {
_imageBitmap = image_lib.encodeBmp(flipImage);
});
}

210

画像編集画面を作成する

6.7

@override

Widget build(BuildContext context) {
final l10n = L10n.of(context);
return Scaffold(

appBar: AppBar(
backgroundColor: Theme.of(context).colorScheme.inversePrimary,
title: Text(l10n.imageEditScreenTitle),

),
body: Center(

child: Column(
mainAxisAlignment: MainAxisAlignment.center,
children: [

Image.memory(_imageBitmap),

❻

IconButton(
onPressed: () => _rotateImage(),

❼

icon: Assets.rotateIcon.svg(
width: 24,
height: 24,

),

),
IconButton(
onPressed: () => _flipImage(),
icon: Assets.flipIcon.svg(
width: 24,
height: 24,
),
),

❽

],

),

),

}

}

);

画像の加工処理を実装するために image パッケージをインポートしました
（❶）
。ここでも Image ウィジェットと名前が競合するため、as キーワードに
続けて image_lib という別名を付けています。
ウィジェットの State クラスである _ImageEditScreenState に、画像のバイ
ト列を格納するためのクラス変数 _imageBitmap を定義しました（❷）
。_
imageBitmap の初期化は initState メソッドにて ImageEditScreen 画面のフィ
ールド imageBitmap から画像のバイト列を取得することで行います（❸）
。
initState メソッドは StatefulWidget のライフサイクルメソッドの一つで、ウ
ィジェットが生成されたときに一度だけ呼び出されるメソッドなので State
クラスの初期化処理に適しています。
211

第

6 実践ハンズオン❶
章

画像編集アプリを開発

画像を回転させる処理（❹）と画像を反転させる処理（❺）はそれぞれ image
パッケージを利用して実装しました。加工済みの画像データを _imageBitmap
に格納し、setState メソッドを呼び出すことで画面を再描画します
（❻）
。そ
れぞれのメソッドはボタンがタップされたときに呼び出すようにしました
（❼、
❽）
。
これで画像を編集する処理が実装できました。アプリを実行し、画像を回
転、反転させてみましょう（図 6.12）。
図 6.12

画像を編集した様子

6.8
まとめ
画像ライブラリから取得した画像を回転、反転させて編集するアプリを作
成しました。画像の取得には image_picker パッケージを、画像の加工には

image パッケージを利用しました。
第 4 章で学んだアプリ開発の土台づくりを踏まえ、アプリをしっかりと日
本語化し、アプリ内のメッセージは arb ファイルに集約しました。アイコン
をアセットとしてプロジェクトに追加し、flutter_gen を利用して安全にアイ
コンを扱うコードを生成しました。
第 5 章で学んだ内容として、簡易的にテーマをアレンジすることにも挑戦
212

まとめ

6.8

しました。画面遷移はシンプルな要件のため、Navigator 1.0 の API で十分に
対応できました。

Tips WidgetとStateのライフサイクルについて
_ImageEditScreenState クラスでは、わざわざ ImageEditScreen ウィジェット

のフィールド imageBitmap から画像のバイト列を取得していました（❸）。この
_imageBitmap の初期化処理は、以下のように _ImageEditScreenState クラスの

コンストラクタで受け取る実装も考えられます。
./lib/edit_snap_screen.dart

class _ImageEditScreenState extends State {
_ImageEditScreenState(this._imageBitmap);
final Uint8List _imageBitmap;
// 省略

しかし、このように State クラスのコンストラクタでデータを受け取ること

は推奨されません。理由はウィジェットよりも State のライフサイクルが長い
ためです。ウィジェットが異なるパラメータで再生成されたときに、State は
再生成されずにそのまま使い回されることがあります。そのとき、ウィジェッ
トと State の間で状態の不一致が発生する可能性があります。詳しくは第 9 章を
ご覧ください。

213

第

7

章

状態管理とRiverpod

215

第

7 状態管理とRiverpod
章

本章では Riverpod 注 1 というパッケージについて解説します。国内ではこのパ
ッケージを中心にアプリを設計される例が多く、後述の状態管理パッケージと
してはスタンダードな存在です。本章では Flutter アプリを開発するうえで重要
な状態管理の考え方を解説したうえで、Riverpod の使い方を紹介します。

7.1
Flutterアプリにおける状態管理
Flutter アプリの設計やアーキテクチャの文脈で状態管理という言葉がよく
使われます。広い意味では StatefulWidget も状態管理の一つと言えます。State
クラスが状態を持ち、setState メソッドで状態を更新すると、ウィジェット
を再構築します。このように、状態を更新したり、その更新を契機にウィジ
ェットを再構築する戦略を状態管理と呼びます。
では、StatefulWidget だけですべての状態を管理することを考えてみましょ
う。次のような制約が発生します。
・状態を更新するロジックは State クラスを起点に実装しなければならない
・末端のウィジェットに状態を伝えるためには、コンストラクタの引数で状態を
バケツリレーしなければならない

その結果、コードの修正が困難になったり、パフォーマンスの問題が発生
したりする可能性が高まります（パフォーマンスに問題が発生する理由につい
ては第 10 章で解説します）。
そこで多くの場合は状態管理のしくみというと、ウィジェットとロジック
を分離させる設計が可能であったり、階層をまたいでウィジェットを再構築
する機能を持っているものを指すことが多いです。
あらためて整理すると、以下のような特徴を持つパッケージを状態管理パ
ッケージと呼びます。
・状態を更新するロジックとウィジェットを分離した設計が可能となる
・状態を更新すると、階層の位置に関係なくウィジェットを再構築することがで
きる

注1

216

https://riverpod.dev/

Riverpodとはどのようなパッケージか

7.2

7.2
Riverpodとはどのようなパッケージか
Riverpod の公式サイトは冒頭で「Riverpod は Flutter/Dart のリアクティブキャ
ッシュフレームワークである」と紹介しています。これは Riverpod の状態管理
パッケージとしての側面を表しています。状態変化に反応して
（リアクティブ）
ウィジェットを更新するしくみが提供されており、その状態を保持する
（キャッ
シュ）
という意味です。状態の保持
（キャッシュ）
に関してはウィジェットのライ
フサイクルに左右されず、破棄のタイミングをコントロールすることができま
す
（またはウィジェットのライフサイクルと合わせることも可能です）
。
また、状態管理パッケージとしての側面以外にも、クラスの依存関係を解
決するためのしくみを提供しています。依存性の注入（Dependency Injection）
、

Tips 宣言的UIとしてのFlutter
状態管理の重要性とともに、Flutter の大切な考え方を紹介します。
Flutter では、UI の設計図はウィジェットの親子関係であり、build メソッドの
実装そのものです。そして、それ以外の場所で UI を変更する手段はありません。
これらの特徴から、Flutter は宣言的 UIフレームワークの一つに数えられます。
宣言的 UI フレームワークは従来までの UI フレームワークと違い、簡潔で保
守性の高いコードを実現できます（しっかりと設計しなければこの限りではあり
ませんが）。iOS や Android のネイティブアプリ開発においても、宣言的 UI フレ
ームワークが台頭しています。
この宣言的 UI はしばしば以下のような式で表現されます。
UI = f(State)

これを Flutter に置き換えると、左辺の UI は画面の表示結果、右辺の f はウィ

ジェットの build メソッドです。build メソッドの中で参照する情報を State（状
態）ととらえてください。

ウィジェットを設計実装するときに、この式を意識してください。この式が
成立しないウィジェットは設計に問題があるサインです。f は関数なので、副
作用を持ちません。f に同じ State（状態）を与えると、必ず同じ UI になるとい
うことです。

たとえば、ウィジェットクラスが final 以外のフィールドを持っている場合

は、この式が成立しない可能性があります。

217

第

7 状態管理とRiverpod
章

とりわけサービスロケーターパターンに近いものと筆者は認識しています。
アプリの設計、アーキテクチャについて検討した経験のある読者の方は、こ
れだけで強力なパッケージであることがおわかりいただけるかと思います。

Riverpodの主要なクラス
Riverpod の主要なクラスを紹介します。
・Provider
・Ref と WidgetRef
・ConsumerWidget

この 3 つです。それぞれの役割と関係性をざっくりと説明します。

Provider が状態をキャッシュし、Ref や WidgetRef を介して状態を提供しま
す。ConsumerWidget はウィジェットのサブクラスです。ConsumerWidget の
build メソッドの引数には WidgetRef が渡され、それを介して状態を取得しウ
ィジェットを構築します。Provider の持つ状態が変化すると、build メソッド
が再度呼び出されます。
（Riverpod v2 の
また、Provider が提供するオブジェクトに大きな制限はない
時点ではジェネリックな型に制限があります）ので、扱い方によっては Ref を
介してクラスの依存関係を解決できるというわけです。

実装サンプル
Riverpod の実装例をお見せします。前項の 3 つのクラスの役割や関係性が
イメージできると思います。
（厳密にはこれだけでは動
以下の例が Provider を活用した最小の実装例です
作しません）
。
final greetProvider = Provider((ref) {
return 'Hello, Flutter!!';
});
class HomePage extends ConsumerWidget {
const HomePage({super.key});

❶

❷

@override
Widget build(BuildContext context, WidgetRef ref) {

218

Riverpodとはどのようなパッケージか

final greet = ref.watch(greetProvider);
return Center(
child: Text(greet)

}

}

7.2

❸

);

greetProvider は Hello, Flutter!! という文字列を提供する Provider です
（❶）
。クロージャ式の引数 ref は ProviderRef という Ref の実装クラスです。
他の Provider とやりとりする場合には、ここで受け取った ref を使います。
greetProvider が 提 供 す る 文 字 列 を ウ ィ ジ ェ ッ ト で 利 用 す る に は
ConsumerWidget クラスを継承します
（❷）。ConsumerWidget の build メソッド
には WidgetRef 型の引数が与えられ、この WidgetRef を通して Provider とやり
とりします（❸）。greetProvider から文字列を受け取り、Text ウィジェット
に渡しています。
次により実践的なサンプルを見てみましょう。Flutter のテンプレートプロ
ジェクトを Riverpod を使ってアレンジします。
テンプレートプロジェクトはボタンをタップすると数字がカウントアップ
するアプリでした。これを Riverpod で実現するため、int 型の数値を状態と
して提供し、かつその値を変更可能な Provider を実装します。
./lib/main.dart

// 省略
class CounterNotifier extends Notifier<int> {
@override
❷
int build() => 0;

}

void increment() {
state = state + 1;
}

❶

❸

final counterNotifierProvider = NotifierProvider<CounterNotifier, int>(() {
return CounterNotifier();
});
// 省略

❹

状態を変更可能な Provider は Notifier というクラスを使います。カウンタ
の値を保持し、インクリメントする CounterNotifier というクラスを実装し
ました（❶）。初期値は build メソッドで返します（❷）
。
Notifier クラスは自分の状態を state プロパティに保持しています。❶で
219

第

7 状態管理とRiverpod
章

Notifier<int> と渡している型パラメータが状態の型となります。increment
メソッドでは、その state プロパティにアクセスしてカウンタの値をインク
リ メ ン ト し ま す（❸）。こ う し て 実 装 し た CounterNotifier ク ラ ス を、
NotifierProvider で提供します（❹）。
続いてウィジェットの実装です。
./lib/main.dart

// 省略

❶
class MyHomePage extends ConsumerWidget {
const MyHomePage({super.key, required this.title});

final String title;
@override

Widget build(BuildContext context, WidgetRef ref) {
final counter = ref.watch(counterNotifierProvider);

❷

return Scaffold(
appBar: AppBar(
backgroundColor: Theme.of(context).colorScheme.inversePrimary,
title: Text(title),
),
body: Center(
child: Column(
mainAxisAlignment: MainAxisAlignment.center,
children: <Widget>[
const Text(
'You have pushed the button this many times:',
),
Text(
❸
'$counter',
style: Theme.of(context).textTheme.headlineMedium,

),

],

),

),
floatingActionButton: FloatingActionButton(
onPressed: () {
ref.read(counterNotifierProvider.notifier).increment();
},
tooltip: 'Increment',
child: const Icon(Icons.add),
),

}

);

}
// 省略

220

❹

Riverpodの関連パッケージ

7.3

StatefulWidget を継承した MyHomePage クラスを、ConsumerWidget を継承す
るように書き換えました（❶）。カウンタの値を counterNotifierProvider か
ら取得し
（❷）、Text ウィジェットに渡しています（❸）
。FloatingActionButton
ウィジェットのタップイベントでは、CounterNotifier を取得し increment メ
ソッドを呼び出しています（❹）。
❷のように WidgetRef の watch メソッドを使って状態を監視した場合、状態
が変化すると build メソッドが再び呼び出されます。ウィジェットからカウ
ンタをインクリメントするロジックがなくなり、シンプルになりました
（WidgetRef の watch メソッドと read メソッドを使い分けていますが、その詳
。
細は「Provider から値を取得する」で解説します）

7.3
Riverpodの関連パッケージ
Riverpod はいくつかのパッケージで構成されています。Riverpod の機能の
全体像を把握する意味でも、概要を知っておきましょう。
・基本機能を提供するパッケージ
・Provider のコードを生成するパッケージ
・静的解析を行うパッケージ

以上の 3 つに分けられます。

基本機能を提供するパッケージ
まずは Provider クラスなどの基本機能を提供するパッケージです。Riverpod
を利用するために必ず必要です。以下の 3 つの中から選択します。
・riverpod 注 2
・flutter_riverpod 注 3
・hooks_riverpod 注 4
注2

https://pub.dev/packages/riverpod

注3

https://pub.dev/packages/flutter_riverpod

注4

https://pub.dev/packages/hooks_riverpod

221

第

7 状態管理とRiverpod
章

最も基本的なパッケージは riverpod であり、Flutter に依存しません。

flutter_riverpod は riverpod をウィジェットなどと連携し、Flutter アプリで
利用するためのパッケージです。

hooks_riverpod は flutter_riverpod に加えて、flutter_hooks 注 5 というパッケ
ージと連携するためのパッケージです。flutter_hooks はウィジェットのライ
フサイクルに関連した実装を簡単に記述できるパッケージです。React の Hooks
をモチーフに実装されています。
通常、Flutter アプリ開発においては flutter_riverpod を、flutter_hooks が必
要な場合は hooks_riverpod を選択するとよいでしょう。

Providerのコードを生成するパッケージ
Riverpod を中心にアプリを開発していると、Provider に関連するコードを
ボイラープレートのように繰り返し記述することになります。そのため

Provider のコードを生成するためのパッケージを提供しています。これらの
パッケージは必須ではありませんが、利用することが推奨されています。
・riverpod_generator 注 6
・riverpod_annotation 注 7

riverpod_generator がコード生成を行うためのパッケージ、riverpod_annotation
はコード生成のためのアノテーションを提供します。実際には riverpod_generator
を利用するために build_runner パッケージも必要になります。
以下はコード生成を利用した場合と、利用しない場合の例です。
// コード生成を利用しない場合
final greetProvider = Provider((ref) {
return 'Hello, Flutter!!';
});
// コード生成を利用する場合
@riverpod
String greet(GreetRef ref) {
return 'Hello, Flutter!!';
};

222

注5

https://pub.dev/packages/flutter_hooks

注6

https://pub.dev/packages/riverpod_generator

注7

https://pub.dev/packages/riverpod_annotation

Riverpodの関連パッケージ

7.3

上記の例だけを見ると大きな変化はないように見えるかもしれませんが、
コード生成を利用するとさまざまなメリットがあります。
・Provider に関するコードを記述する際の意思決定が減る
・Provider へ渡すパラメータの制限がなくなる
・Provider の変更がホットリロードできる

本章冒頭のサンプルコードはコード生成を利用しないものになっています
が、以降はコード生成を利用する前提で解説していきます。

静的解析を行うパッケージ
Riverpod のコード特有の問題を静的解析で検出、自動修正するためのパッ
ケージが提供されています。パッケージは必須ではありませんが、利用する
ことが推奨されています。
・riverpod_lint 注 8

サードパーティパッケージが独自の Lint ルールを提供するためのツールと
して、custom_lint 注 9 というパッケージが提供されており、riverpod_lint はこ
の custom_lint を利用しています。そのため、riverpod_lint を利用するために
は custom_lint もインストールする必要があります。

riverpod_generator でコード生成を行う際の記述ミスを検出するルールがい
くつか用意されていますので、riverpod_generator と併せて利用することをお
勧めします。

関連パッケージまとめ
関連パッケージをいくつか紹介しました。結局、どれが必要でどれが不要
なのか迷った方は pubspec.yaml を以下の内容にして開始するとよいでしょう。

hooks パッケージは利用せず、コード生成と静的解析は利用する構成です。バ
ージョンの指定は割愛しています。

注8

https://pub.dev/packages/riverpod_lint

注9

https://pub.dev/packages/custom_lint

223

第

7 状態管理とRiverpod
章

./pubspec.yaml

dependencies:

# 省略
flutter_riverpod:

riverpod_annotation:
dev_dependencies:
# 省略

riverpod_generator:
build_runner:
custom_lint:
riverpod_lint:

コマンドラインから導入する場合は以下のコマンドを実行します。
$ flutter pub add flutter_riverpod riverpod_annotation

$ flutter pub add --dev riverpod_generator build_runner custom_lint riverpod_lint

7.4
Riverpodの使い方
それでは Riverpod の使い方をサンプルコードと併せて解説していきます。

Providerの種類
コード生成を利用する前提ですと、状態を外部から「変更不可能」
な関数ベ
ースの Provider と、状態を外部から「変更可能」なクラスベースの Provider の

2 つに分類することができます。
関数ベースのProvider

まずは関数ベースの Provider の使い方を解説します。本章の冒頭で紹介し
たサンプルの greetProvider をコード生成を利用して実装します。
./lib/main.dart

part 'main.g.dart';
@riverpod
String greet(GreetRef ref) {
return 'Hello World!!';
}

224

Riverpodの使い方

7.4

・@riverpod アノテーションを付与する
・第一引数に Ref 型のオブジェクトを受け取る

この 2 つのルールを守れば、関数ベースの Provider を実装できます。
@riverpod アノテーションを付与することで、コード生成の対象となりま
す。生成したコードを参照するために part 命令文を記述します。ファイル名
は編集したファイル名に .g.dart を付与します。たとえば、main.dart に

Provider を定義した場合は main.g.dart となります。生成される Provider の名
前 は、関 数 名 に Provider を 付 与 し た も の に な り ま す。今 回 の 例 で は
greetProvider という名前になります。
第一引数には Ref 型のオブジェクトを受け取ります。この Ref 型の名前はラ
ージキャメルケースの関数名に Ref を付与したものが生成されます。今回は
関数名が greet なので、GreetRef という名前になります。他に引数が必要な
場合は第二引数以降に記述します。
関数の戻り値の型は Provider が提供する型になります。
実装が完了したらのコード生成のために、以下のコマンドを実行します。
$ flutter packages pub run build_runner build

クラスベースのProvider

続いてクラスベースの Provider の使い方を解説します。本章の冒頭で紹介
したサンプルの CounterNotifier をコード生成を利用して実装します。
./lib/main.dart

// 省略

part 'main.g.dart';
@riverpod
class CounterNotifier extends _$CounterNotifier {
@override
int build() => 0;

}

void increment() {
state = state + 1;
}

クラスベースの Provider を実装する際のルールは以下の 3 つです。

225

第

7 状態管理とRiverpod
章

・@riverpod アノテーションを付与する
・_$ ＋クラス名の型を継承する
・初期値を build メソッドで返す

クラスベースの場合も @riverpod アノテーションを付与してコード生成の
対象とします。part 命令文が必要な点は関数ベースの場合と同じです。
Notifier クラスは、_$ ＋クラス名の型を継承します。このクラスはコード生
成によって作られます。今回の例では _$CounterNotifier というクラスにな
ります。初期値は build メソッドで返します。Notifier クラスの state プロ
パティには、この build メソッドの戻り値が設定されます。
実装が完了したらのコード生成のために、以下のコマンドを実行します。
$ flutter packages pub run build_runner build

Widget の実装をもう一度見てみましょう。
./lib/main.dart

// 省略

class MyHomePage extends ConsumerWidget {
const MyHomePage({super.key, required this.title});
final String title;
@override
Widget build(BuildContext context, WidgetRef ref) {
❶
final counter = ref.watch(counterNotifierProvider);
return Scaffold(
appBar: AppBar(
backgroundColor: Theme.of(context).colorScheme.inversePrimary,
title: Text(title),
),
body: Center(
child: Column(
mainAxisAlignment: MainAxisAlignment.center,
children: <Widget>[
const Text(
'You have pushed the button this many times:',
),
Text(
'$counter',
style: Theme.of(context).textTheme.headlineMedium,
),

226

Riverpodの使い方

7.4

],

),

),

floatingActionButton: FloatingActionButton(

onPressed: () {
ref.read(counterNotifierProvider.notifier).increment();
},

❷

tooltip: 'Increment',
child: const Icon(Icons.add),

),

}

}

);

CounterNotifier の状態、すなわちカウンタの値を取得する場合は counter
NotifierProviderを監視します（❶）
。CounterNotifier の状態を変更する場合
は、counterNotifierProvider のnotifierプロパティをrefに渡し、increment
メソッドを呼び出します
（❷）
（ここでは WidgetRefの watchメソッドとreadメソッ
で解説します）
。
ドを使い分けていますが、その詳細は
「Provider から値を取得する」

非同期処理を行うProvider
Future 型や Stream 型を提供する Provider について解説します。
@riverpod
Future<String> asyncGreet(AsyncGreetRef ref) async {
await Future.delayed(const Duration(seconds: 1));
return 'Hello World';
}

戻り値を Future 型とし、async キーワードを付ける以外は先ほどの関数ベ
ースの Provider と同じです。クラスベースの Provider の場合は build メソッ
ドの戻り値を Future 型とし、async キーワードを付けるだけです。
@riverpod
class CounterNotifier extends _$CounterNotifier {
@override
Future<int> build() async {
await Future.delayed(const Duration(seconds: 1));
return 0;
}
// 省略
}

このように Provider を生成すると、Provider が提供する型が AsyncValue と
227

第

7 状態管理とRiverpod
章

いう型になります。AsyncValue 型は Riverpod が提供するクラスで非同期の値
を安全に扱える便利クラスです。loading、error、data の 3 つの状態を表現
できます。非同期処理が実行中であったり、エラーが発生したりした場合な
ど、状態に応じて場合分けできて便利です。
asyncGreetProvider を監視するウィジェットの実装例を見てみましょう。
class HomePage extends ConsumerWidget {

const HomePage({Key? key}) : super(key: key);
@override

Widget build(BuildContext context, WidgetRef ref) {
final AsyncValue<String> greet = ref.watch(asyncGreetProvider);
return Center(
child: greet.when(

loading: () => const Text('Loading'),

❷

data: (greet) => Text(greet),

}

}

);

❶

error: (e, st) => Text(e.toString())),

❶でasyncGreetProviderの値を監視します。asyncGreetProviderの状態が変
化するたびにHomePageウィジェットのbuild メソッドが呼び出されます。Async
（❷）
。
Valueクラスの whenメソッド注 10 を活用して、状態別の UI を構築しています
クラスベースの Provider で、state を更新する際にも AyncValue 型を用いま
す。先ほどの CounterNotifier クラスを例に、非同期処理中でなければ値を
インクリメントするように実装してみましょう。
@riverpod
class CounterNotifier extends _$CounterNotifier {
@override
Future<int> build() async {
await Future<void>.delayed(const Duration(seconds: 1));
return 0;
}
void increment() async {
final currentValue = state.valueOrNull;
if (currentValue == null) {
return;
}

❶

注 10 今後は when メソッドではなく、Dart 3 にて導入された switch 式へ移行する方針が示されています。

228

Riverpodの使い方

state = const AsyncLoading();

}

}

7.4

❷

await Future<void>.delayed(const Duration(seconds: 1));
❸
state = AsyncValue.data(currentValue + 1);

state から現在の値を取得します
（❶）
。valueOrNull プロパティは AsyncValue
クラスの値を取得するメソッドです。AsyncValue が data の場合は値を取得で
（意図的に前回値
きますが、loading や error の場合は基本的に null が返ります
。ここ
をキャッシュさせておく方法もあり、null が返らないケースもあります）
では、AsyncValue が data 以外の場合は何もせずに処理を終了します。続いて
state を AsyncLoading に変更し
（❷）
、最後に state を AsyncValue.data に変更、
値をインクリメントします
（❸）
。
非同期なProviderとRaw型

AsyncValue でラップされた非同期処理が扱いづらい場合もあります。たと
えば、他の Provider の非同期処理の結果をもとに、データを処理する Provider
を実装する場合です。
@riverpod
Future<int> fakeFirstApi(FakeFirstApiRef ref) async {
await Future.delayed(const Duration(seconds: 1));
return 1;
}
@riverpod
Future<int> fakeSecondApi(FakeSecondApiRef ref) async {
await Future.delayed(const Duration(seconds: 1));
return 2;
}

❶

❷

@riverpod
❸
Future<int> fakeSumApi(FakeSumApiRef ref) async {
final AsyncValue<int> firstApiResult = ref.watch(fakeFirstApiProvider);
final AsyncValue<int> secondApiResult = ref.watch(fakeSecondApiProvider);
// 省略
}

❸ の fakeSumApi は、❶ と ❷ の 結 果 を 合 算 し て 返 す Provider で す。
fakeFirstApi と fakeSecondApi はともに非同期処理に結果を返す Provider で、
AsyncValue 型で値が提供されます。このような場合、AsyncValue 型をそのま
229

第

7 状態管理とRiverpod
章

ま扱うと、コードが複雑になります。fakeFirstApi と fakeSecondApi の結果
が Future 型であれば、await キーワードを使ってシンプルに実装できそうで
す。このような場合は Provider の提供する型を Raw 型でラップします。
@riverpod

Raw<Future<int>> fakeFirstApi(FakeFirstApiRef ref) async {
await Future.delayed(const Duration(seconds: 1));
}

return 1;

@riverpod
Raw<Future<int>> fakeSecondApi(FakeSecondApiRef ref) async {
await Future.delayed(const Duration(seconds: 1));

}

❶

❷

return 2;

@riverpod
Future<int> fakeSumApi(FakeSumApiRef ref) async {
final int firstApiResult = await ref.watch(fakeFirstApiProvider);
final int secondApiResult = await ref.watch(fakeSecondApiProvider);
return firstApiResult + secondApiResult;
}

❸

fakeFirstApi と fakeSecondApi の戻り値を Raw でラップしました
（❶、❷）
。
すると、fakeSumApi では await キーワードを使って結果を int 型で受け取り、
シンプルに実装できます
（❸）。

Providerから値を取得する
Provider から値を取得するには、WidgetRef の watch メソッドと read メソッ
ドを使います。watch メソッドは文字どおり Provider の値を監視します。ウィ
ジェットの build メソッドで監視した場合には、Provider の値が変化するとウ
ィジェットの build メソッドが再度呼び出されます。read メソッドはその時
点での Provider の値を取得するのみです。

Provider から値を取得する際は、可能な限り watch メソッドを利用すること
が推奨されています。watch メソッドを利用することで、アプリ全体が状態
変化に自動で反応し、メンテナンス性の高いアプリを実現できるとされてい
ます。
一方、値を監視する必要のないボタンのタップイベントや、State のライフ
サイクルイベントなどでは read メソッドを利用することが推奨されています。
230

Riverpodの使い方

7.4

先ほどのサンプルで、FloatingActionButton ウィジェットの onPressed イベ
ントでは watch を用いずに read メソッドを利用していたのはそのためです。
Providerの値をフィルタする

頻繁に値が更新され、ウィジェットの再構築が不必要に発生する場合は
select メソッドで値をフィルタすることもできます。たとえば、以下のよう
な Point クラスを提供する Provider があるとします。
class Point {

Point(this.x, this.y);
int x;

}

int y;

ウィジェットでは x の値のみが必要な場合、select メソッドを利用して x
の値のみを取得することができます。
final x = ref.watch(pointProvider.select((point) => point.x));

このように select メソッドを利用すると、y の値が変化しても値は通知さ
れません。ウィジェットの再構築を抑制したい場合などに便利です。

Providerのライフサイクル
コード生成を利用した場合、Provider は購読されなくなると自動的に破棄
されます。たとえば、あるダイアログの状態を管理する Provider は、ダイア
ログが閉じられると破棄され、再度開かれた際には状態がリセットされてい
ることになります。
ただ、時にはアプリの起動中は状態を保持したいケースや、複数の画面を
またいで状態を共有したいケースもあるでしょう。そのような場合は Provider
を自動で破棄させないようにすることも可能です。
@Riverpod(keepAlive: true)
class CounterNotifier extends _$CounterNotifier {
@override
int build() => 0;
void increment() {
state = state + 1;

231

第

7 状態管理とRiverpod
章

}

}

@riverpod アノテーションに代えて、@Riverpod にします。大文字から始ま
るアノテーションを利用し、keepAlive プロパティに true を設定します。こ
のようにすることで、Provider は自動的に破棄されなくなります。

Provider を任意のタイミングで再構築したい場合は、refresh メソッドを利
用します。
ref.refresh(counterNotifierProvider);

Providerにパラメータを渡す
Provider にパラメータを渡す方法を解説します。関数ベースの Provider の
場合は、第二引数以降にパラメータを記述します。
関数ベースの Provider は以下のようになります。
@riverpod
String greet(GreetRef ref, String str) {
return 'Hello $str';
}

Provider にアクセスする際は以下のようにパラメータを渡します。
@override
Widget build(BuildContext context, WidgetRef ref) {
final greet = ref.watch(greetProvider('Flutter'));

クラスベースの Provider の場合は、build メソッドの引数にパラメータを記
述します。
@riverpod
class CounterNotifier extends _$CounterNotifier {
@override
int build(int num) {
return num;
}

}

232

void increment() async {
state = state + 1;
}

Riverpodの使い方

7.4

こちらも Provider にアクセスする際は以下のようにパラメータを渡します。
class MyHomePage extends ConsumerWidget {

const MyHomePage({super.key, required this.title});
final String title;
@override

Widget build(BuildContext context, WidgetRef ref) {

final counterNotifier = counterNotifierProvider(3);
return Scaffold(

❶

appBar: AppBar(
backgroundColor: Theme.of(context).colorScheme.inversePrimary,
title: Text(title),

),

body: Center(
child: Column(

mainAxisAlignment: MainAxisAlignment.center,
children: <Widget>[
const Text(
'You have pushed the button this many times:',
),
Text(
❷
'${ref.watch(counterNotifier)}',

style: Theme.of(context).textTheme.headlineMedium,

),

],

),

),
floatingActionButton: FloatingActionButton(
onPressed: () {
ref.read(counterNotifier.notifier).increment();
},
tooltip: 'Increment',
child: const Icon(Icons.add),
),

}

}

❸

);

CounterNotifier の例では、値を監視するために Provider にアクセスする❷
と、カウンタをインクリメントするために Provider にアクセスする❸があり
ますので、❶でプロバイダに初期値を渡し変数に置きました。

233

第

7 状態管理とRiverpod
章

7.5
まとめ
本章では Flutter の状態管理の概念と、Riverpod の使い方を解説しました。

Riverpod の役割を理解するために、冒頭で Flutter における状態管理につい
て解説しました。Riverpod は強力なパッケージですが、初学者には概要がつ
かみづらいので
（筆者自身がそうでした）主要なクラスの役割と関係性、関連
パッケージを先に紹介し、Riverpod の全体像をつかんでもらうように解説を
進めました。

Riverpod は活発に開発が行われており、本章で紹介できなかった機能もあ
ります。より理解を深めるうえでは、村松龍之介さんの電子書籍『Flutter x

Riverpod でアプリ開発！実践入門』注 11 がお勧めです。Riverpod の更新に追従
しながら、新しい情報を、日本語で詳しく解説された貴重な書籍です。
次章では、Riverpod を状態管理に利用したアプリを実装していきます。

注 11 https://zenn.dev/riscait/books/flutter-riverpod-practical-introduction

234

第

8

章

実践ハンズオン❷
ひらがな変換アプリを開発

235

第

8 実践ハンズオン❷
章

ひらがな変換アプリを開発

本章では再びハンズオン形式でアプリの実装に挑戦します。入力したテキ
ストをひらがなに変換するアプリです。第 7 章で学んだ Riverpod を採用し、
状態管理を行います。なお、本章でも fvm コマンドを省略して flutter コマン
ドを記載しています。ご自身の環境、コマンドを実行するディレクトリにあ
わせて読み替えてください。
図 8.1 が完成イメージです。
図 8.1

アプリの完成イメージ

8.1
開発するアプリの概要
このハンズオンで実装するアプリの概要を説明します。公開された Web API
を利用し、入力したテキストをひらがなに変換します。文字入力とバリデー
ション、Web API のリクエストに JSON の取り扱いと実用的な機能を盛り込ん
でいます。

1 つの画面で状態により表示を切り替えるように実装します。入力状態で
変換ボタンをタップし
（図 8.1 の左）、API リクエストを実行するとインジケー
タを表示します
（図 8.1 の中央）。API のレスポンスが返ると結果を表示します
（図 8.1 の右）。再入力ボタンをタップすると、再び入力状態に戻ります。
236

開発するアプリの概要

8.1

入力状態
テキストを入力する状態です（図 8.2）。テキストはバリデーションチェッ
クを行い、空文字の場合はメッセージを表示します。
「変換」ボタンをタップ
すると、ひらがな変換のリクエストを行います。
図 8.2

入力状態

レスポンス待ち状態
Web API のレスポンス待ちの状態です（図 8.3）。インジケータを表示するこ
とで、ユーザーにリクエスト中であることを伝えます。

237

第

8 実践ハンズオン❷
章

ひらがな変換アプリを開発

図 8.3

レスポンス待ちの状態

変換完了状態
API リクエストが完了し、変換結果のある状態です（図 8.4）。「再入力」ボタ
ンをタップすると、再び入力状態に戻ります。
図 8.4

238

変換完了状態

プロジェクトを作成する

8.2

開発の土台づくり
第 4 章で解説した「開発の土台づくり」の要素です。アプリの日本語化など
第 6 章のハンズオンで実装した機能は省略します。Web API の呼び出しに必
要なアプリケーション ID を環境変数として扱います。
導入するパッケージは「8.3 アプリで使用するパッケージを導入する」で解
説します。

テーマと画面遷移の方針
テーマは Material Design 3 のテーマを使用し、すべてデフォルトのままに
します。画面遷移はありません。

8.2
プロジェクトを作成する
プロジェクトを作成します。第 1 章の
「1.1 プロジェクトの作成」
で示した手順
に従って、プロジェクトを作成してください。プロジェクト名は「hiragana_

converter」としましょう。プロジェクト作成直後は lib/main.dart にテンプレー
トになるアプリコードが書かれていますので、まずは以下のように修正します。
./lib/main.dart

import 'package:flutter/material.dart';
void main() {
runApp(const MyApp());
}
class MyApp extends StatelessWidget {
const MyApp({super.key});
@override
Widget build(BuildContext context) {
return MaterialApp(

title: 'Hiragana Converter',
theme: ThemeData(
colorScheme: ColorScheme.fromSeed(seedColor: Colors.deepPurple),
useMaterial3: true,

239

第

8 実践ハンズオン❷
章

ひらがな変換アプリを開発

),

home: const HomeScreen(),

}

}

);

class HomeScreen extends StatelessWidget {
const HomeScreen({super.key});

@override
Widget build(BuildContext context) {

}

}

return Container();

テンプレートプロジェクトの不要なコードを削除したこの状態から作業を
開始しましょう。

8.3
アプリで使用するパッケージを導入する
まずはじめに、アプリで使用するパッケージを一気に導入してしまいまし
ょう。
パッケージを導入するためにプロジェクトのディレクトリで、ターミナル
から以下のコマンドを実行してください。
# httpパッケージを導入❶
$ flutter pub add http
# JSONのシリアライズ、デシリアライズを行うパッケージを導入❷
$ flutter pub add json_annotation
$ flutter pub add --dev json_serializable
# Riverpodを導入❸
$ flutter pub add flutter_riverpod riverpod_annotation
$ flutter pub add --dev riverpod_generator custom_lint riverpod_lint
# コード生成のためにbuild_runnerを導入❹
$ flutter pub add --dev build_runner

Web API を呼び出すために http というパッケージを導入します（❶）。この
パッケージは HTTP リクエストを簡単に扱うことのできるパッケージです。

Web API のリクエストとレスポンスは JSON 形式でやりとりします。JSON
を取り扱うため、json_annotation と json_serializable パッケージを導入します
240

入力状態のウィジェットを実装する

8.4

（❷）
。これらのパッケージは Dart のオブジェクトと Map の相互変換を行うコ
ードを自動生成してくれるパッケージです。
そのほか、状態管理に Riverpod を採用するため❸を導入します。Riverpod
と json_serializable はコード生成を行うため、build_runner パッケージも導入
します（❹）
。

riverpod_lintを設定する
第 7 章で紹介した riverpod_lint の設定を行います。riverpod_lint は custom_

lint パッケージを利用して実現しています。以下のように analysis_options.
yaml へ custom_lint を有効化する記述を追加します。
./analysis_options.yaml

analyzer:

plugins:
- custom_lint

8.4
入力状態のウィジェットを実装する
第 5 章で作成したアプリは Navigation API を使っていくつかの画面を行き来
するアプリでした。本章のハンズオンは 1 つの画面で状態により表示を切り替
えるように実装していきます。上記の 2 つの違いは、プログラム上どちらが良
いということはなく、ユーザーにどのような体験を提供するかによります。

レイアウトを作成する
まずはテキストを入力するレイアウトを作成します。lib フォルダの配下
に input_form.dart という新しいファイルを追加し、以下のコードを記述し
ます。
./lib/input_form.dart

import 'package:flutter/material.dart';
class InputForm extends StatefulWidget {

241

第

8 実践ハンズオン❷
章

ひらがな変換アプリを開発

const InputForm({super.key});
@override
}

State<InputForm> createState() => _InputFormState();

class _InputFormState extends State<InputForm> {
@override
Widget build(BuildContext context) {

return Column(
mainAxisAlignment: MainAxisAlignment.center,
children: [

/* ◆ Padding

余白を与えて子要素を配置するWidget */
❶
Padding(

padding: const EdgeInsets.symmetric(horizontal: 16),
child: TextField(
maxLines: 5,
decoration: const InputDecoration(
hintText: '文章を入力してください',
),

),
),
/* ◆ SizedBox
サイズを指定できるWidget */
const SizedBox(height: 20),
ElevatedButton(
onPressed: () {},
child: const Text(
❹
'変換',
),
),

❷

❸

],

}

}

);

StatefulWidget を継承した InputForm クラスを実装しました。TextField ウ
ィジェット
（❷）
と ElevatedButton ウィジェット
（❹）を Column ウィジェットで
囲い、垂直にレイアウトしました。
TextField ウィジェットはユーザーが入力可能なテキストフィールドです。
maxLines プロパティは一度に表示する行数の指定です。今回は 5 を設定しま
したので 5 行分のテキストを表示し、それ以上入力するとスクロールします。
decoration プロパティは TextField ウィジェットのさまざまな装飾を指定す
るプロパティです。今回は未入力の場合に「文章を入力してください」
と表示
242

入力状態のウィジェットを実装する

8.4

するヒントテキストを指定しました。
TextField ウィジェットが横いっぱいに広がらないように、Paddingウィジェ
ットで余白を設けました（❶）
。現時点では Padding ウィジェットに constant コ
ンストラクタを使うようワーニングが表示されますが、のちほど修正します。
❸ の S i z e d B o x ウ ィ ジ ェ ッ ト は T e x t F i e l d ウ ィ ジ ェ ッ ト（❷）と
ElevatedButton ウィジェット
（❹）の間に余白を設けるために使用しています。

レイアウトを表示する
このままでは、アプリを実行しても InputForm ウィジェットは表示されま
せん。main.dart を以下のように修正します。
./lib/main.dart

import 'package:flutter/material.dart';

import 'package:hiragana_converter/input_form.dart';

❶

// 省略
class HomeScreen extends StatelessWidget {
const HomeScreen({super.key});

}

@override
Widget build(BuildContext context) {
return Scaffold(
appBar: AppBar(
backgroundColor: Theme.of(context).colorScheme.inversePrimary,
title: const Text('Hiragana Converter'),
),
body: const InputForm(),
);
}

❷

先ほど実装した InputForm ウィジェットを参照するため、input_form.dart
をインポートしました（❶）。HomeScreen 画面では Scaffold ウィジェットを返
すように修正しました（❷）。body には先ほど作成した InputForm ウィジェッ
トを指定しています。
これでアプリを実行すると、図 8.5 のように InputForm ウィジェットが表示
されます。

243

第

8 実践ハンズオン❷
章

ひらがな変換アプリを開発

図 8.5

InputForm Widget の表示（図 8.2 再掲）

入力値のバリデーションを行う
TextField ウィジェットに与えられた文字列が空でないことをバリデーシ
ョンします。こういったケースでは Form ウィジェットと FormField ウィジェ
ットを組み合わせて使うと便利です。
./lib/input_form.dart

import 'package:flutter/material.dart';
class InputForm extends StatefulWidget {
const InputForm({super.key});

}

@override
State<InputForm> createState() => _InputFormState();

class _InputFormState extends State<InputForm> {
final _formKey = GlobalKey<FormState>();
@override
Widget build(BuildContext context) {
/* ◆ Form
TextFormFieldやFormFieldを
グループ化して管理するWidget */
❷
return Form(

244

❶

入力状態のウィジェットを実装する

8.4

key: _formKey,

child: Column(
mainAxisAlignment: MainAxisAlignment.center,
children: [

Padding(
padding: const EdgeInsets.symmetric(horizontal: 16),
/* ◆ TextFormField

テキスト入力フォームを実現するWidget */
❸
child: TextFormField(
maxLines: 5,
decoration: const InputDecoration(

hintText: '文章を入力してください',

),

validator: (value) {
if (value == null || value.isEmpty) {
}

return '文章が入力されていません';

❹

return null;

},

),
),
const SizedBox(height: 20),
ElevatedButton(
onPressed: () {
final formState = _formKey.currentState!;
❺
formState.validate();
},
child: const Text(
'変換',
),

),

],

),

}

}

);

_InputFormState クラスの build メソッドで返すウィジェット全体を Form
ウィジェットで包み（❷）、Form ウィジェットの key プロパティには（❶）で用
意した GlobalKey を渡しています。また、TextField ウィジェットは FormField
ウィジェットのサブクラスである TextFormField ウィジェットに置き換えま
した（❸）
。TextFormField ウィジェットは constant コンストラクタを持ちませ
ん。よって、先ほどまで Padding ウィジェットの constant コンストラクタを
呼び出す旨のワーニングは解消されます。
Form ウィジェットに関する操作は Form ウィジェットの State を経由して行
245

第

8 実践ハンズオン❷
章

ひらがな変換アプリを開発

います（Form ウィジェットは StatefulWidget です）。ElevatedButton ウィジェ
ットの onPressed コールバックで、GlobalKey から Form ウィジェットの State
を取得し validate メソッドを呼び出しています（❺）。validate メソッドが呼
び出されると、Form ウィジェットの子孫にある FormField ウィジェットでバ
リ デ ー シ ョ ン が 行 わ れ ま す。ち ょ う ど、TextField ウ ィ ジ ェ ッ ト を
TextFormField ウィジェットに書き換えたところでした。
TextFormField ウィジェットは validator コールバックで文字の空チェック
を行っています
（❹）
。
以上のように Form ウィジェット、FormField ウィジェットを用いてバリデ
ーション機能を実装できます（図 8.6）。
図 8.6

バリデーションが機能している様子

8.5
入力文字を取得する
バリデーションを通過した入力文字を Web API のパラメータとして扱える
ように取得します。方法はいくつかありますが、今回は TextEditingController
を利用します。
./lib/input_form.dart

import 'package:flutter/material.dart';

246

入力文字を取得する

8.5

class InputForm extends StatefulWidget {
const InputForm({super.key});
@override
}

State<InputForm> createState() => _InputFormState();

class _InputFormState extends State<InputForm> {
final _formKey = GlobalKey<FormState>();
/* ◆ TextEditingController

TextField Widgetの入力文字や選択文字を取得、変更する機能を持つ */
❶
final _textEditingController = TextEditingController();
@override

Widget build(BuildContext context) {
return Form(
key: _formKey,
child: Column(
mainAxisAlignment: MainAxisAlignment.center,
children: [
Padding(
padding: const EdgeInsets.symmetric(horizontal: 16),
child: TextFormField(
❷
controller: _textEditingController,
maxLines: 5,
decoration: const InputDecoration(
hintText: '文章を入力してください',
),
validator: (value) {
if (value == null || value.isEmpty) {
return '文章が入力されていません';
}
return null;
},

),
),
const SizedBox(height: 20),
ElevatedButton(
onPressed: () {
final formState = _formKey.currentState!;
if (!formState.validate()) {
return;
}

debugPrint('text = ${_textEditingController.text}');

},

❸

247

第

8 実践ハンズオン❷
章

ひらがな変換アプリを開発

child: const Text(
'変換',

),

),

],

),

}

);

@override
void dispose() {

_textEditingController.dispose();

}

}

super.dispose();

❹

クラスメンバに TextEditingController を加え
（❶）、TextFormField ウィジ
ェットにパラメータとして渡しました（❷）。これで TextEditingController
から TextFormField ウィジェットの入力文字が取得できます。
バリデーションを通過した後、入力文字をログに出力するコードを追加し
ました（❸）
。
TextEditingController クラスは不要になったら忘れずに dispose メソッド
を呼び出します
（❹）
。これにより、メモリリークのリスクを回避します。
_InputFormState クラスの dispose メソッドは State のライフサイクルメソ
ッドの一つで、StatefulWidget が破棄されるときに呼び出されます。InputForm
ウィジェットは setState を呼び出して自身の状態を更新することはありませ
んが、dispose メソッドをオーバーライドして TextEditingController クラス
を破棄するために StatefulWidget を継承しました。

8.6
ひらがな化するWeb APIを呼び出す実装をする
入力文字のひらがな変換には goo ラボのひらがな化 API 注 1 を利用させてもら
います。API の利用には利用登録とアプリケーション ID の取得が必要になり

注1

248

https://labs.goo.ne.jp/api/jp/hiragana-translation/

ひらがな化するWeb APIを呼び出す実装をする

8.6

ます。詳しくは公式 Web サイト注 2 をご覧ください。

リクエスト、
レスポンスオブジェクトを定義する
API のリクエストパラメータは JSON 形式で送信します。json_serializable パ
ッケージを利用して、JSON を型安全に扱いやすくするためのデータ型を定義
します。lib フォルダの配下に data.dart という新しいファイルを追加し、以
下のコードを記述します。
./lib/data.dart

import 'package:json_annotation/json_annotation.dart';
part 'data.g.dart';

❶

❷

@JsonSerializable(fieldRename: FieldRename.snake)
❹
class Request {
const Request({
required this.appId,
required this.sentence,
❺
this.outputType = 'hiragana',

❸

});

final String appId;
final String sentence;
final String outputType;

}

Map<String, Object?> toJson() => _$RequestToJson(this);

❻

Request クラスを定義しました（❹）。@JsonSerializable アノテーションを
付与することで、json_serializable パッケージが JSON のシリアライズ、デシ
リアライズのコードを生成します（❸）。❶ではアノテーションを参照するた
め、json_annotation.dart をインポートしています。
Request クラスのフィールドは、appId、sentence、outputType と 3 つ定義
し、Dart の慣習にのっとってキャメルケースで命名しました。しかし、API
のリクエストパラメータはスネークケースです。@JsonSerializable アノテ
ーションの fieldRename プロパティに FieldRename.snake を指定することで、

JSON をシリアライズ、デシリアライズする際に、フィールド名をスネークケ
ースに変換するよう指定しています。
注2

https://labs.goo.ne.jp/apiusage/

249

第

8 実践ハンズオン❷
章

ひらがな変換アプリを開発

今回のアプリでは outputType は固定値なので、コンストラクタのデフォル
ト値を設定しました
（❺）。
Request クラスを Map 形式に変換するための toJson メソッドを定義しまし
た
（❻）
。メソッドの本体は json_serializable パッケージが生成し、_$ ＋クラス
名＋ ToJson という命名規則になります。このメソッドを参照するため、part
命令文で data.g.dart をインポートしています（❷）。
実装が完了したらコード生成のために、以下のコマンドを実行してくださ
い。
$ flutter packages pub run build_runner build

同じように、レスポンスオブジェクトも定義します。data.dart に以下の
コードを追加します。
./lib/data.dart

// 省略
@JsonSerializable(fieldRename: FieldRename.snake)
class Response {
const Response({
required this.converted,
});
final String converted;
factory Response.fromJson(Map<String, Object?> json) => _$ResponseFromJson(jso
❶
n);
}

Response クラスを定義しました。converted フィールドは変換後のひらが
な文字列が入ります。Response クラスのインスタンスを JSON から生成する
（❶）。こちらも json_serializable
ための factory コンストラクタを定義しました
パッケージが生成します。
実装が完了したらのコード生成のために、以下のコマンドを実行しておき
ましょう。
$ flutter packages pub run build_runner build

250

ひらがな化するWeb APIを呼び出す実装をする

8.6

アプリケーションIDを設定する
API のリクエストにはアプリケーション ID が必要です。goo ラボのひらが
な化 API 注 3 のページから利用登録を行い、アプリケーション ID を取得してく
ださい。今回はアプリケーション ID をハードコーディングせずに、環境変数
を利用する方法として第 4 章で解説した dart-define-from-file のしくみで扱
うことにします。
define/env.json という JSON ファイルを作成し、以下のようにアプリケー
。
ション ID を記述します（YOUR_APP_ID の代わりに取得した ID を入れる）
./define/env.json

{
}

"appId": "YOUR_APP_ID"

そして、アプリの実行引数に --dart-define-from-file=define/env.json
を指定します。詳しい方法は第 4 章をご覧ください。
なお、今回は設定とコードを分離する設計の観点で、dart-define-fromfile のしくみを利用しています。セキュリティの観点では、認証キーを dartdefine-from-file で扱うことがベストプラクティスとは言えません。アプリ
のセキュリティについてはリバースエンジニアリング、ルート化、中間者攻
撃による通信の改ざんなど、さまざまな脅威があります。どの程度コストを
かけてセキュアに扱うかは要件しだいと筆者は考えます。
本書ではこれ以上の解説は割愛しますが、少なくとも「認証キーは dartdefine-from-file で渡すのがベストプラクティス」という誤解を招かないよ
うに……という思いでここで補足しておきます。

Web APIを呼び出す
InputForm ウィジェットの「変換」ボタンをタップしたときに Web API を呼
び出すように実装します。
./lib/input_form.dart

import 'dart:convert';

❶

import 'package:flutter/material.dart';
注3

https://labs.goo.ne.jp/api/jp/hiragana-translation/

251

第

8 実践ハンズオン❷
章

ひらがな変換アプリを開発

import 'package:hiragana_converter/data.dart';
❸
import 'package:http/http.dart' as http;

❷

// 省略
ElevatedButton(

onPressed: () async {

❹

final formState = _formKey.currentState!;
if (!formState.validate()) {
return;

}

final url = Uri.parse('https://labs.goo.ne.jp/api/hiragana');
final headers = {'Content-Type': 'application/json'};
final request = Request(
appId: const String.fromEnvironment('appId'),
sentence: _textEditingController.text,

❺

❻

);

final result = await http.post(
url,
headers: headers,
body: jsonEncode(request.toJson()),
);

❼

final response = Response.fromJson(
jsonDecode(result.body) as Map<String, Object?>,
);
debugPrint('変換結果: ${response.converted}');

❽

},
child: const Text(
'変換',
),

),
// 省略

InputForm ウィジェットの「変換」ボタンをタップしたときに呼び出される
コールバックで、Web API を呼び出すコードを追加しました。最初に HTTP
リクエストの URL やリクエストヘッダを生成します（❺）
。次に先ほど定義し
たリクエストオブジェクトを生成します（❻）。Request クラスを参照するた
め、d a t a . d a r t を イ ン ポ ー ト し て い ま す（❷）。a p p I d は S t r i n g .
fromEnvironment を使って環境変数から取得しています。実行引数が設定さ
れていれば、環境変数には define/env.json の内容が反映されます。
続いて、http パッケージの post メソッドを呼び出して Web API を呼び出し
252

ひらがな化するWeb APIを呼び出す実装をする

8.6

ます
（❼）
。今回は http パッケージをインポートする際に as キーワードで http
という別名を付けています（❸）。request オブジェクトは toJson メソッドで

Map に変換し、そこからさらに jsonEncode 関数で JSON 文字列に変換してい
ます。jsonEncode 関数を参照するため、組み込みパッケージの dart:convert
をインポートしています
（❶）。post メソッドの戻り値は Future なので、await
キーワードを付けて非同期処理の完了を待ち、onPressed コールバックに async
を付与しています
（❹）。
最後に、API のレスポンスをデシリアライズして、変換結果をログに出力
しています（❽）。JSON 文字列を jsonDecode 関数で Map に変換し、そこから
Response オブジェクトを生成しています。
これでアプリを実行して、入力文字の変換結果をログに出力できるように
➡
「Tool Windows」
➡
「Run」
を選
なりました。Android Studio であれば、「View」
択し、ログを確認できます（図 8.7）。
図 8.7

変換結果をログに出力した様子

253

第

8 実践ハンズオン❷
章

ひらがな変換アプリを開発

8.7
アプリの状態を管理する
Web API のレスポンスを受け取り結果を表示したり、レスポンスを待つ間
にインジケータを表示したりと、アプリの表示切り替えのために状態を管理
します。

状態を表現するクラスを作成する
まずはアプリの状態を sealed class で表現してみましょう。lib フォルダの
配下に app_state.dart という新しいファイルを追加し、以下のコードを記述
します。
./lib/app_state.dart

sealed class AppState {
const AppState();
}

❶

class Input extends AppState {
const Input(): super();
}

❷

class Loading extends AppState {
const Loading(): super();
}
class Data extends AppState {
const Data(this.sentence);

}

❸

❹

final String sentence;

アプリの状態を表現する、AppState という sealed class を定義しました
（❶）
。
AppState を継承した Input、Loading、Data という 3 つのクラスを定義しまし
た
（❷、❸、❹）
。Input は入力状態、Loading は Web API のレスポンス待ちの
状態、Data は Web API のレスポンスを受け取った状態を表現します。
続いて、lib フォルダの配下に app_notifier_provider.dart という新しい
ファイルを追加し、以下のコードを記述します。

254

アプリの状態を管理する

8.7

./lib/app_notifier_provider.dart

import 'dart:convert';

import 'package:hiragana_converter/app_state.dart';
import 'package:hiragana_converter/data.dart';

import 'package:riverpod_annotation/riverpod_annotation.dart';
import 'package:http/http.dart' as http;

❶

part 'app_notifier_provider.g.dart';
❷
@riverpod
class AppNotifier extends _$AppNotifier {

@override

AppState build() {

return const Input();

❹

void reset() {
state = const Input();
}

❺

}

❸

Future<void> convert(String sentence) async {
❻
state = const Loading();
final url = Uri.parse('https://labs.goo.ne.jp/api/hiragana');
final headers = {'Content-Type': 'application/json'};
final request = Request(
appId: const String.fromEnvironment('appId'),
sentence: sentence,
);
final response = await http.post(
url,
headers: headers,
body: jsonEncode(request.toJson()),
);
final result = Response.fromJson(
jsonDecode(response.body) as Map<String, Object?>,
);

}

}

state = Data(result.converted);

❼

AppNotifier という名前の NotifierProvider を定義しました
（❸）
。Provider
の宣言部分は riverpod_generator パッケージに生成させるため、@riverpod ア
ノテーションを付与しています（❷）。また、アノテーションを参照するため
255

第

8 実践ハンズオン❷
章

ひらがな変換アプリを開発

riverpod_annotation パッケージをインポートしています（❶）。
初期状態を提供する build メソッドでは、Input オブジェクトを返すように
しました
（❹）
。これはアプリ起動時は入力状態であるためです。
reset メソッドでは、Input オブジェクトを state に代入しています（❺）
。
これは変換結果を表示した後、再度入力状態に戻すときに呼び出すことを想
定しています。
convert メソッドは InputForm ウィジェットの「変換」
ボタンをタップしたと
きに呼び出される処理を実装しています。❻で、state に Loading オブジェク
トを代入し、アプリの状態を Web API のレスポンス待ちに変更しています。
❼で、state に Data オブジェクトを代入し、アプリの状態を Web API のレス
ポンスを受け取った状態に変更しています。それ以外は先ほど InputForm ウ
ィジェットに直接実装したコードと同じです。
これでアプリの状態管理のしくみは整いました。

8.8
状態に応じて表示を切り替える
最後に、アプリの状態に応じて表示を切り替える実装をします。

レスポンス待ち状態のウィジェットを実装する
Web API のレスポンス待ちの表示レイアウトを作成します。lib フォルダの
配下に loading_indicator.dart という新しいファイルを追加し、以下のコー
ドを記述します。
./lib/loading_indicator.dart

import 'package:flutter/material.dart';
class LoadingIndicator extends StatelessWidget {
const LoadingIndicator({super.key});
@override
Widget build(BuildContext context) {
return const Center(
/* ◆ CircularProgressIndicator
回転アニメーションする円形のインジケータWidget */
child: CircularProgressIndicator(),

256

状態に応じて表示を切り替える

}

}

8.8

);

StatelessWidget を継承した LoadingIndicator ウィジェットを実装しました。
中央にインジケータを配置したシンプルなウィジェットです。

変換完了状態のウィジェットを実装する
次にひらがなへの変換結果を表示するためのウィジェットを実装します。
lib フォルダの配下に convert_result.dart という新しいファイルを追加し、
以下のコードを記述します。
./lib/convert_result.dart

import 'package:flutter/material.dart';

import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:hiragana_converter/app_notifier_provider.dart';
class ConvertResult extends ConsumerWidget {
const ConvertResult({
super.key,
❶
required this.sentence,
});

final String sentence;
@override
Widget build(BuildContext context, WidgetRef ref) {
final notifier = ref.watch(appNotifierProvider.notifier);
return Center(
child: Column(
mainAxisAlignment: MainAxisAlignment.center,
children: [
Padding(
padding: const EdgeInsets.symmetric(horizontal: 16),
❷
child: Text(sentence),
),
const SizedBox(height: 20),
ElevatedButton(

onPressed: notifier.reset,
child: const Text(
'再入力',
),

❹
❸

),

257

第

8 実践ハンズオン❷
章

ひらがな変換アプリを開発

],

),

}

}

);

ConsumerWidget を継承した ConvertResult ウィジェットを実装しました。
変換結果の文字列をコンストラクタ引数で受け取ります（❶）
。受け取った変
換結果の文字列は❷で表示します。また、テキスト入力画面に戻るためのボ
タンを配置しました（❸）。ボタンタップ時のコールバックは AppNotifier の
reset メソッドを呼び出しています（❹）。

画面の切り替えを行う
それでは、状態の変化にあわせて画面を切り替える挙動を実装していきま
しょう。
./lib/main.dart

import 'package:flutter/material.dart';
import 'package:hiragana_converter/app_state.dart';
import 'package:hiragana_converter/app_notifier_provider.dart';
import 'package:hiragana_converter/convert_result.dart';
import 'package:hiragana_converter/input_form.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:hiragana_converter/loading_indicator.dart';
void main() {
runApp(
const ProviderScope(
child: MyApp(),
❷
),
);
}

❶

❶

class MyApp extends StatelessWidget {
const MyApp({super.key});
@override
Widget build(BuildContext context) {
return MaterialApp(
title: 'Hiragana Converter',
theme: ThemeData(
colorScheme: ColorScheme.fromSeed(seedColor: Colors.deepPurple),
useMaterial3: true,
),

258

状態に応じて表示を切り替える

8.8

home: const HomeScreen(),

}

}

);

class HomeScreen extends ConsumerWidget {
const HomeScreen({super.key});

❸

@override

Widget build(BuildContext context, WidgetRef ref) {
final appState = ref.watch(appNotifierProvider);
return Scaffold(

❹

appBar: AppBar(

backgroundColor: Theme.of(context).colorScheme.inversePrimary,
title: const Text('Hiragana Converter'),

),
body: switch (appState) {

Loading() => const LoadingIndicator(),
Input() => const InputForm(),
Data(sentence: final sentence) => ConvertResult(sentence: sentence),

❺

},

}

}

);

まず必要なコードをインポートし
（❶）、Riverpod を利用するため、アプリ
のルートウィジェットを ProviderScope で包みました
（❷）
。
HomeScreen 画面を ConsumerWidget を継承するように修正しました（❸）
。
ConsumerWidget を継承することで、build メソッドの第二引数に WidgetRef を
受け取れるようになります。WidgetRef から appNotifierProvider を購読し
（❹）、状態に応じて表示を切り替えるようにしました（❺）
。表示の切り替え
は switch 式で行っています。

ひらがな変換処理の呼び出しを修正する
最後に、InputFormウィジェットの
「変換」
ボタンをタップしたときにAppNotifier
のconvertメソッドを呼び出すように修正します。

259

第

8 実践ハンズオン❷
章

ひらがな変換アプリを開発

./lib/input_form.dart

// import 'dart:convert';

import 'package:flutter/material.dart';
// import 'package:hiragana_converter/data.dart';

❶

// import 'package:http/http.dart' as http;

import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:hiragana_converter/app_notifier_provider.dart';
class InputForm extends ConsumerStatefulWidget {
const InputForm({super.key});

❷

@override
}

ConsumerState<InputForm> createState() => _InputFormState();

class _InputFormState extends ConsumerState<InputForm> {

❹

final _formKey = GlobalKey<FormState>();
final _textEditingController = TextEditingController();
@override
Widget build(BuildContext context) {
return Form(
key: _formKey,
child: Column(
mainAxisAlignment: MainAxisAlignment.center,
children: [
Padding(
padding: const EdgeInsets.symmetric(horizontal: 16),
child: TextFormField(
controller: _textEditingController,
maxLines: 5,
decoration: const InputDecoration(
hintText: '文章を入力してください',
),
validator: (value) {
if (value == null || value.isEmpty) {
return '文章が入力されていません';
}
return null;
},
),
),
const SizedBox(height: 20),
ElevatedButton(
onPressed: () async {
final formState = _formKey.currentState!;

260

❸

状態に応じて表示を切り替える

8.8

if (!formState.validate()) {
}

return;

final sentence = _textEditingController.text;
await ref
.read(appNotifierProvider.notifier)

❺

.convert(sentence);

},
child: const Text(
'変換',

),

),

],

),

}

}

);

@override
void dispose() {
_textEditingController.dispose();
super.dispose();
}

InputForm ウィジェットを ConsumerStatefulWidget を継承するように修正
しました
（❷）
。これに伴って、_InputFormState クラスを ConsumerState を継
承するように修正しました（❹）。InputForm ウィジェットの createState メソ
ッドの戻り値の型も変更します（❸）
。必要なコードをインポートし、不要に
なったインポートの削除も行っておきましょう（❶）
。
_InputFormState クラスが ConsumerState を継承したため、WidgetRef にア
クセスできるようになりました。
「変換」ボタンのタップ時に WidgetRef から
AppNotifier を取得し、convert メソッドを呼び出すように変更しました
（❺）
。
これでアプリの状態に応じて表示を切り替える挙動が実装できました。ア
プリを実行し、入力文字をひらがなに変換すると一覧の画面に遷移すること
を確認してください。

261

第

8 実践ハンズオン❷
章

ひらがな変換アプリを開発

8.9
まとめ
入力したテキストをひらがなに変換するアプリを開発しました。文字入力
とバリデーション、Web API のリクエストや JSON の取り扱いといった実践的
な機能を盛り込みました。
また、このハンズオンのポイントは次の 2 つです。
・アプリの状態を sealed class で実装し、簡潔にアプリの状態を表現した
・アプリの状態管理に Riverpod を利用し、ウィジェットとロジックを分離した

このハンズオンで採用したアプリの状態表現や状態管理は、筆者お勧めの
設計パターンの一つです。

262

第

9

章

フレームワークによる
パフォーマンスの最適化
BuildContext、Key

263

第

9 フレームワークによるパフォーマンスの最適化
章

BuildContext、Key

ウィジェットの build メソッドの引数に渡される BuildContext や、ウィジェ
ットのコンストラクタに渡される Key について、ここまで詳しい解説をしてき
ませんでした。本章ではいよいよ BuildContextと Key の役割を明らかにし、そ
れがアプリのパフォーマンス最適化につながっていることを解説します。

9.1
BuildContextは何者なのか ── Element
ウィジェットの build メソッドの引数には必ず BuildContext が渡されます。
この BuildContext は何者なのでしょうか。先に結論を言うと、Element（エ
レメント）
というクラスです。

祖先の情報にアクセスできるBuildContext
通常のアプリ開発で使う場面は少ないですが、BuildContext には興味深い

API が用意されています。
T? findAncestorWidgetOfExactType<T extends Widget>();

ウィジェットの親をたどり、ツリーの中で最も近い位置にある T 型のウィ
ジェットを探して返却するメソッドです。計算量は O(n) 注 1 です。実際に動作
を確認してみましょう。
./lib/main.dart

import 'package:flutter/material.dart';
void main() {
runApp(const MaterialApp(
home: HomeScreen(),
));
}
class HomeScreen extends StatelessWidget {
const HomeScreen({super.key});
@override
Widget build(BuildContext context) {
注1

264

ウィジェットの階層が深くなると、計算時間が線形に増えていくことを意味します。

BuildContextは何者なのか ── Element

final materialApp = context.findAncestorWidgetOfExactType<MaterialApp>();
print(materialApp);
// => MaterialApp

9.1

❶

return Scaffold(

appBar: AppBar(
title: const Text('Home Screen'),
),

body: const Center(
child: Text('Home Screen'),
),

}

}

);

❶ で findAncestorWidgetOfExactType メ ソ ッ ド を 呼 び 出 し、親 の
MaterialApp ウィジェットが取得できることが確認できます。
ウィジェットは親や子にアクセスする API を持ちませんし、内部でもその
情報は持っていません。しかし、BuildContext（Element）は親子関係をツリ
ー構造で管理しているので、このような API が実現できるのです。
ちなみに、似た API として、直近の祖先の State を取得する API があります。
T? findAncestorStateOfType<T extends State<StatefulWidget>>()

BuildContext を引数に NavigatorState を取得する Navigator.of メソッド
は、この API を使って実現されています。
Elementがツリーを構成していく工程

Flutter フレームワークの内部で Element がツリーを構成していく様子を図
で表します。次のように MaterialApp ウィジェット、その子に HomeScreen と
いうウィジェットがあるような状況を想定します。
./lib/main.dart

void main() {
runApp(
MaterialApp(
home: HomeScreen()
),
);
}

main 関数では runApp 関数が呼び出され、引数には MaterialApp ウィジェッ
トが渡されます。このとき、runApp 関数の内部では、ルートになる Element
265

第

9 フレームワークによるパフォーマンスの最適化
章

BuildContext、Key

とウィジェットが生成されます（図 9.1 の❶）。ルートの Element は MaterialApp
の Element 生成を命令します（図 9.1 の❷、❸）。
図 9.1

MaterialApp の Element が生成される様子
Frameworkが作る
ルートのElement

❶
createElement ❷

MaterialAppの
Element

❸

MaterialApp

MaterialApp の Element がツリーの一部として構成されます（図 9.2 の❶）
。
図 9.2

MaterialApp の Element がツリーの一部として構成される様子
Frameworkが作る
ルートのElement
❶
MaterialAppの
Element

MaterialApp

MaterialApp の Element が MaterialApp の build メソッドを呼び出します
（図
9.3 の❶）
。
図 9.3

MaterialApp の build メソッドが呼ばれる様子
Frameworkが作る
ルートのElement

MaterialAppの
Element

❶
build

MaterialApp

MaterialApp の build メソッドで、HomeScreen ウィジェットが返却されます
（図 9.4 の❶）
。

266

BuildContextは何者なのか ── Element

図 9.4

9.1

HomeScreen が生成される様子
Frameworkが作る
ルートのElement

MaterialAppの
Element

build

MaterialApp
❶
HomeScreen

MaterialApp の Element が HomeScreen の Element 生成を命令します（図 9.5
の❶）
。
図 9.5

HomeScreen の Element が生成される様子
Frameworkが作る
ルートのElement

MaterialAppの
Element

MaterialApp

createElement
HomeScreenの
Element

❶

HomeScreen

HomeScreen の Element がツリーの一部として構成されます
（図 9.6 の❶）
。

267

第

9 フレームワークによるパフォーマンスの最適化
章

BuildContext、Key

図 9.6

HomeScreen の Element がツリーの一部として構成される様子
Frameworkが作る
ルートのElement

MaterialAppの
Element

MaterialApp

❶
HomeScreenの
Element

HomeScreen

以上を末端のウィジェットまで繰り返し、Element のツリーを構成してい
きます。

StatefulWidgetの状態を保持する役割
次は別の視点から BuildContext を見てみましょう。StatefulWidget の State
は、誰が管理しているのでしょうか？ライフサイクルは StatefulWidget と同じ
でしょうか？

StatefulWidget を入れ子構造にしたサンプルを用意しました。
./lib/main.dart

import 'package:flutter/material.dart';
void main() {
runApp(
MaterialApp(
home: HomeScreen(),
),
);
}
// HomeScreenはStatefulWidget
class HomeScreen extends StatefulWidget {
HomeScreen({super.key}) {
debugPrint('HomeScreen constructor');
}

}

268

@override
State createState() => _HomeScreenState();

BuildContextは何者なのか ── Element

9.1

class _HomeScreenState extends State<HomeScreen> {
❶
int _counter = 0;
@override

Widget build(BuildContext context) {
debugPrint('CounterButton build');
return Scaffold(

appBar: AppBar(
title: const Text('Home Screen'),
),
body: Center(

child: Column(

mainAxisAlignment: MainAxisAlignment.center,
children: [
// ボタンをタップするとカウントアップする

ElevatedButton(
child: Text('Home Screen Count: ($_counter)'),
onPressed: () {
setState(() {
❸
_counter++;

❷

});

},

),
CounterButton(),

],

❹

),

),

}

}

);

// CounterButtonはStatefulWidget
class CounterButton extends StatefulWidget {
CounterButton({super.key}) {
debugPrint('CounterButton constructor');
}

}

@override
State createState() => _CounterButtonState();

class _CounterButtonState extends State<CounterButton> {
❺
int _counter = 0;
@override
Widget build(BuildContext context) {

269

第

9 フレームワークによるパフォーマンスの最適化
章

BuildContext、Key

debugPrint('CounterButton build');

// ボタンをタップするとカウントアップする
return ElevatedButton(
onPressed: () {
setState(() {
_counter++;
});

❻

},
child: Text('Counter Button Count: ($_counter)'),

}

}

);

❼

HomeScreen 画面は StatefulWidget です。内部でカウンタを持っており（❶）
、
ボタンをタップするとカウントアップします（❷、❸）。さらに、CounterButton
という StatefulWidget を並べました（❹）。CounterButton ウィジェットも同様
にカウンタを持っており（❺）、ボタンをタップするとカウントアップします
（❻、❼）
。
アプリを実行し、それぞれのボタンをタップするとカウンタがインクリメ
ントされ、期待どおりに動作します。しかし、不思議なところはないでしょ
うか？ HomeScreen 画面のカウンタをインクリメントする、すなわち setState
メソッドを呼び出すと、build メソッドが呼ばれ CounterButton ウィジェット
が新しく作られるハズです。なのに、CounterButton ウィジェットのカウン
タはリセットされずに状態を保持しています。
図 9.7

「Home Screen Count」ボタンの押下前後

Home Screen Count
ボタンをタップ

270

BuildContextは何者なのか ── Element

9.1

図 9.7 は
「Home Screen Count」をタップする前後の様子です。
「Home Screen

Count」は 2 から 3 に変化しました。これは HomeScreen 画面の build メソッド
は 1 の状態を
が呼ばれたことを意味します。しかし、「Counter Button Count」
維持しています。この動きから、StatefulWidget の State は、StatefulWidget
よりも長いライフサイクルを持っていることがわかります（図 9.8）
。
図 9.8

State のライフサイクルが Widget のライフサイクルよりも長いイメージ図
StatefulWidget

State

StatefulWidget

続いて StatefulWidget が生成する Element
（StatefulElement）
のソースコード
を一部見てみましょう。
./flutter/packages/flutter/lib/src/widgets/framework.dart

class StatefulElement extends ComponentElement {
StatefulElement(StatefulWidget widget)
: _state = widget.createState(),
super(widget) {

このように Element のコンストラクタで StatefulWidget の createState メソ
ッドを呼び出しています。また別のコードも見てみましょう。以下は Element
が破棄されるときに呼ばれる unmount メソッドです。
./flutter/packages/flutter/lib/src/widgets/framework.dart

void unmount() {
super.unmount();
state.dispose();

271

第

9 フレームワークによるパフォーマンスの最適化
章

BuildContext、Key

// 省略

}

state._element = null;
_state = null;

Element が破棄されるときに、State クラスの dispose メソッドが呼ばれて
います。これらのコードから Element と State はライフサイクルが一致して
いることがわかります。
これまでわかったことを振り返ってみます。
・StatefulWidget の State は StatefulWidget よりもライフサイクルが長い
・State は Element とライフサイクルが一致している

つまり、StatefulWidget よりも Element のほうがライフサイクルが長いこと
になります
（図 9.9）
。
図 9.9

Element のライフサイクルが Widget のライフサイクルよりも長いイメージ図
StatefulWidget

Element

StatefulWidget

また一方で、先ほど Element がツリーを構成していく過程を解説しました。

StatefulWidget よりも Element のほうがライフサイクルが長いことを念頭に、
この過程を再度見てみます。
❶ Element から build メソッドが呼ばれ、子ウィジェットのインスタンスが作ら
れる
❷子ウィジェットから子 Element が作られ、ツリーに組み込まれる

272

Elementの再利用とパフォーマンス ── RenderObject

9.2

❸子 Element から子 build メソッドが呼ばれ、孫ウィジェットのインスタンスが
作られる
❹孫ウィジェットから孫 Element が作られ、ツリーに組み込まれる

StatefulWidget で setState メソッドを呼び出した場合に当てはめてみまし
ょう。ウィジェットの build メソッドが呼び出され、その中で新しい子ウィ
ジェットのインスタンスが作られます（❶）。次の工程
（❷）
で子ウィジェット
が子 Element を作ってしまうと、ウィジェットと Element のライフサイクル
が同じになってしまい、辻褄が合いません。
実はフレームワークの内部で、Element を再利用するしくみがあり、常に
新しい Element を作るわけではないのです。これまで解説してきたことをあ
らためて整理します。
・StatefulWidget よりも Element のほうがライフサイクルが長い
・Element は再利用されるしくみがある

Tips 宣言的UIとElementの再利用
第 7 章で状態管理の解説をする際に、宣言的 UI について触れました。
UI = f(State)

右 辺 の f は ウ ィ ジ ェ ッ ト の build メ ソ ッ ド で し た。そ し て、先 ほ ど

StatefulWidget の State を管理しているのは Element だということを解説しま
した。つまり、Flutter は次のような式ととらえることもできそうです。
UI = Widget.build(Element.state)

UI の設計図を提供するウィジェットと、それを実体化するための状態を持つ
Element、責務を分けることで宣言的 UI を実現していると言えます。

9.2
Elementの再利用とパフォーマンス ── RenderObject
Element の中には RenderObjectElement というクラスがあり、RenderObject
というクラスを管理しています。この RenderObject は Element と同様に独自
のツリー構造を持ちます。
273

第

9 フレームワークによるパフォーマンスの最適化
章

BuildContext、Key

RenderObjectは高コストな計算を行う
RenderObject はウィジェットのレイアウト計算を行います。RenderObject
の親から子へ、サイズ制約を渡し、子のサイズが決まったら自身とのオフセ
ット量を計算します。この操作をツリーの末端まで繰り返します。この処理
はコストの高いものになります。
レ イ ア ウ ト が 決 定 し た の ち、RenderObject は 描 画 処 理 を 行 い ま す。
RenderObject は描画命令を発行し Flutter フレームワークよりも下層の Flutter

Engine に対して描画を依頼します。この描画処理もまた、ツリーの末端まで
繰り返すことになり、やはりコストの高いものになります。

RenderObjectは状態を持つ
RenderObject は描画に必要な状態を保持します。色のついた矩形を表現す
る ColoredBox ウィジェットを例にとってみましょう。ColoredBox ウィジェッ
トは、color というプロパティを持ちます。
以下は、ColoredBox ウィジェットの実装を簡略化したものです。
./flutter/packages/flutter/lib/src/widgets/basic.dart

class ColoredBox extends SingleChildRenderObjectWidget {
const ColoredBox({ required this.color, super.child, super.key })
final Color color;

ColoredBox ウィジェットは、RenderObjectWidget を継承しており、_
RenderColoredBox という RenderObject を生成します。_RenderColoredBox も
また、color というプロパティを持ちます。
以下は _RenderColoredBox の実装を簡略化したものです。
./flutter/packages/flutter/lib/src/widgets/basic.dart

class _RenderColoredBox extends RenderProxyBoxWithHitTestBehavior {
_RenderColoredBox({ required Color color })
: _color = color;
Color _color;

そして、_color のカスタムセッタが重要な役割を果たします。
./flutter/packages/flutter/lib/src/widgets/basic.dart

Color get color => _color;

274

Keyは何に使うのか

9.3

set color(Color value) {
if (_color == value)
return;
_color = value;
}

markNeedsPaint();

新しい color が現在の color と一致する場合は何もせずに終了します。一致
しない場合は、_color に新しい値をセットし、markNeedsPaint() を呼び出し
ます。この markNeedsPaint() は、次の描画タイミングで自身が再描画を行う
ようにフレームワークに予約するメソッドです。このように RenderObject は
描画に必要な状態を保持し、コストの高い処理をスキップするかどうかの判
断を行っているのです。

Elementの再利用はパフォーマンスに影響する
ここまでの RenderObject についての解説をまとめます。
・RenderObject は Element によって管理されており、Element の再利用は
RenderObject の再利用につながる
・RenderObject はレイアウト計算や描画といったコストの高い処理を行う
・RenderObject はレイアウト計算や描画に必要な情報を保持しており、更新が不
要な場合はスキップする

つまりは、Element の再利用は RenderObject が行うコストが高い処理をス
キップする可能性をあげることにつながります。

9.3
Keyは何に使うのか
BuildContext に加えて、掘り下げてこなかったものに Key クラスがありま
す。ウィジェットのコンストラクタ引数には、いつも Key がありますよね。こ
の Key は何者で、何に使われるのでしょうか。

275

第

9 フレームワークによるパフォーマンスの最適化
章

BuildContext、Key

Elementが再利用される条件
先ほど Element は適宜再利用されると説明しました。この Element の再利
用と Key は密接な関係があります。ここで Element が再利用される条件を列
挙します。
❶ウィジェットのインスタンスが同じ
❷ウィジェットの型が同じかつ Key が同じ
❸ GlobalKey が同じ

これだけだとイメージしづらいので、Key を利用して Element を再利用する
例を見てみましょう。

Elementが再利用される様子を見てみよう
先ほど Element が再利用される条件に、ウィジェットの型が同じかつ Key が
同じというものがありました。この動作を確認するために、以下のようなサ
ンプルを用意しました。再利用の様子を確認するために、少々強引なコード
になっていますが、ご容赦ください。

5 つの要素を並べたリストを並べ替えるサンプルです。FloatingActionButton
ウィジェットをタップすると先頭の要素が末尾に移動します
（図 9.10）
。
図 9.10

リストを並べ替えるサンプル

FroatingActionButton
をタップ

276

先頭のアイテムが
末尾に移動

Keyは何に使うのか

9.3

./lib/main.dart

import 'package:flutter/material.dart';
void main() {
runApp(

const MaterialApp(
home: HomeScreen(),
),

}

);

class HomeScreen extends StatefulWidget {
const HomeScreen({super.key});

}

@override
State createState() => _HomeScreenState();

class _HomeScreenState extends State<HomeScreen> {
final list = List.generate(5, (index) => index);

❶

@override
Widget build(BuildContext context) {
return Scaffold(
appBar: AppBar(
title: const Text('Home Screen'),
),
body: Column(
children: list.map((element) {
return ListItem(
widgetIndex: element,
❷
);
}).toList(),
),
floatingActionButton: FloatingActionButton(
onPressed: () {
setState(() {
debugPrint('Swap first and last element');
final value = list.removeAt(0);
❸
list.add(value);
});
},
child: const Icon(Icons.swap_vert),
),
);
}

}

277

第

9 フレームワークによるパフォーマンスの最適化
章

BuildContext、Key

class ListItem extends StatefulWidget {

const ListItem({super.key, required this.widgetIndex});
final int widgetIndex;

❹

@override
}

State createState() => _ListItemState();

class _ListItemState extends State<ListItem> {
static int counter = 0;
final int _stateIndex = counter++;

❺

@override

Widget build(BuildContext context) {
return ListTile(
title: Text(
'Widget index ${widget.widgetIndex}, '
❼
'State index $_stateIndex',

❻

),

}

}

);

❶では、0 から 4 までの整数を要素とするリストを作成しています。リスト
の要素を❷で並べて表示しています。このリストを❸で並べ替えています。
FloadingActionButton ウィジェットをタップすると、リストの先頭の要素を
末尾に移動させます。この操作は setState 引数の中で行っているので表示は
更新されます。
リストの要素は独自に実装した ListItem ウィジェットです。ListItem ウィ
ジェットは widgetIndex というプロパティ（❹）を持ち、❶のインデックスが
渡ります。また、State（_ListItemState クラス）は _stateIndex というプロパ
ティを持ち（❺）
、こちらは State のインスタンスが作られた順にインデックス
を保持します。それぞれ❻と❼でウィジェットのインデックス、State のイン
デックスとして表示しています。
このサンプルを実行し FloatingActionButton ウィジェットをタップすると、
ウィジェットのインデックスは変化しますが State のインデックスは変化しま
せん
（図 9.11）
。

278

Keyは何に使うのか

図 9.11

9.3

State のインデックスが変化しない様子

FroatingActionButton
をタップ
Stateのインデックスが
変化していない

ウィジェットのインデックスを表示するための情報はウィジェット
（ListItem）が保持しています。ウィジェットは build メソッドが実行される
たびに作りなおされます。一方で、State のインデックスを表示するための情
報は State が保持しています。そして、State は Element が参照を保持してい
るのでした。

Element が再利用される条件に、ウィジェットの型が同じかつ Key が同じと
いうものがありました。今回は ListItem ウィジェットのインスタンスは同じ
ですし、Key も特に指定していない（null どうしを比較して一致した）ため

Element は上から順番に再利用されたのです（図 9.12）。
図 9.12

Element が上から順に再利用されたイメージ図
Widget (index 1), Key (null)
Widget (index 2), Key (null)

型もKeyも
一致している

Element (index 0), Key (null)
Element (index 1), Key (null)

Widget (index 3), Key (null)

Element (index 2), Key (null)

Widget (index 4), Key (null)

Element (index 3), Key (null)

Widget (index 0), Key (null)

Element (index 4), Key (null)

Keyを利用したElementの再利用

先ほどのサンプル、State のインデックスを並べ替えるには Key を利用しま
279

第

9 フレームワークによるパフォーマンスの最適化
章

BuildContext、Key

す。ListItem ウィジェットのコンストラクタに Key を渡します。
./lib/main.dart

// 省略

body: Column(
children: list.map((element) {
return ListItem(

key: ValueKey(element),
widgetIndex: element,

❶

);
}).toList(),

),

// 省略

ValueKey とは、コンストラクタ引数に与えられた値で識別する Key です。
これを実行すると、State のインデックスも並べ替えられることが確認できま
す
（図 9.13）
。
図 9.13

State のインデックスが並び替えられる様子

FroatingActionButton
をタップ
Stateのインデックスが
変化する

Element のツリー構造から Key が一致する Element を探し出します。このと
き Key は❶に与えられた ValueKey です。ValueKey はウィジェットのインデッ
クスで一意に識別されます。この ValueKey が一致するように Element を再利
。
用するので、State のインデックスも一緒に並べ替えられるのです（図 9.14）

280

Keyは何に使うのか

図 9.14

9.3

Key によって Element が並び替えられるイメージ図
Widget (index 1), Key (1)
Widget (index 2), Key (2)

Keyが一致しない

Keyが

一致

する

Element (index 0), Key (0)
Element (index 1), Key (1)

Widget (index 3), Key (3)

Element (index 2), Key (2)

Widget (index 4), Key (4)

Element (index 3), Key (3)

Widget (index 0), Key (0)

Element (index 4), Key (4)

以上のように、Element の再利用により意図しないウィジェットと紐付い
てしまうケースなどに Key を利用します。

Keyの種類
Key にはいくつか種類があります。表 9.1 に代表的なものを 4 つ紹介します。
表 9.1

代表的な Key の種類

Key の種類

特徴

ValueKey

コンストラクタ引数に与えられた値で識別する Key

ObjectKey

コンストラクタ引数に与えられたオブジェクトで識別する Key

UniqueKey

インスタンスごとに一意に識別する Key

GlobalKey

ウィジェットの階層を越えて一意に識別する Key

前項の例では int 型のインデックスで一意に識別するため、ValueKey を利
用しました。ObjectKey はコンストラクタ引数に与えられたオブジェクトで
一意に識別します。引数を取らない UniqueKey はインスタンスごとに一意に
識別します。これら 3 つの Key は同一階層のウィジェットから一致する Key を
探します。前項の例のようにリストの要素などを識別するのに利用します。
GlobalKey はウィジェットの階層を越えて一意に識別します。異なる画面
で特定のウィジェットの状態を一致させる場合や、アニメーションなどに利
用します。

281

第

9 フレームワークによるパフォーマンスの最適化
章

BuildContext、Key

9.4
局所的にWidgetを更新するしくみ ── InheritedWidget
フレームワークが持つ最適化のしくみの一つとして、InheritedWidget につ
いても触れておきます。

InheritedWidget は階層を越えてデータを渡すことのできるウィジェットで
す。身近な例では Theme ウィジェットが内部で生成している _InheritedTheme
ウィジェットが InheritedWidget です。MaterialApp ウィジェットの配下であ
れば、Theme.of メソッドから階層のどこからでも ThemeData を取得できるの
でした。
./lib/main.dart

import 'package:flutter/material.dart';
void main() {
runApp(const MaterialApp(
home: HomeScreen(),
));
}
class HomeScreen extends StatelessWidget {
const HomeScreen({super.key});

}

@override
Widget build(BuildContext context) {
final theme = Theme.of(context); // ThemeDataを取得
return Scaffold(
backgroundColor: theme.backgroundColor,
appBar: AppBar(
title: const Text('Home Screen'),
),
body: const Center(
child: Text('Home Screen'),
),
);
}

先ほど、祖先のウィジェットを検索するBuildContext の API を紹介しました。
T? findAncestorWidgetOfExactType<T extends Widget>();

282

局所的にWidgetを更新するしくみ ── InheritedWidget

9.4

これに対して、祖先の InheritedWidget を検索する API も提供されており、

2 つの特徴を持っています。
T? dependOnInheritedWidgetOfExactType<T extends InheritedWidget>();

まず 1 つ目は計算量です。InheritedWidget を検索する API は、O(1) 注 2 の計
算量です。フレームワークが提供するウィジェットの多くは ThemeData を参
照していますが、計算量が小さいので大きな問題にはなりません。
も う 一 つ は InheritedWidget の 更 新 を 購 読 す る 効 果 が あ る こ と で す。

InheritedWidget は、提供するデータが更新されたことを子孫に通知すること
ができます。dependOnInheritedWidgetOfExactType を呼び出したウィジェッ
トは、通知を受けると build メソッドが呼び出されます。Theme ウィジェット
の例で言えば、ThemeData が更新されると ThemeData を参照するウィジェット
が再構築され、新しい ThemeData に合わせて UI が更新されます。このしくみ
を用いると、StatelessWidget であっても build メソッドが複数回呼ばれる可
能性があります。

InheritedWidget の機能をまとめると、
・InheritedWidget はウィジェットの階層を越えてデータを提供することができる
・階層を越えてウィジェットの再構築をトリガすることができる

となります。第 7 章で解説した状態管理の概念と一致していますよね。

InheritedWidget はフレームワークが提供する状態管理のしくみの一つです。
Theme ウィジェットのように上位に配置されるウィジェットが StatefulWidget
として実装されていたとしたら、ThemeData が更新されるとその配下すべて
を再構築する必要があります。一方、InheritedWidget は情報を必要とするウ
ィジェットを局所的に再構築することができ、パフォーマンスへの影響を抑
えることができるのです。

注2

ウィジェットの階層が深くなっても、計算時間が一定であることを意味します。

283

第

9 フレームワークによるパフォーマンスの最適化
章

BuildContext、Key

9.5
まとめ
Element を起点に、フレームワークが内部で行っている最適化について解
（なる場合
説しました。Element はウィジェットよりもライフサイクルが長く
がある）
、その Element は RenderObject を管理しています。この RenderObject
はレイアウト計算や描画といったコストの高い処理を行います。また、

RenderObject は状態を持ち、更新が不要な場合はスキップするしくみになっ
ています。この RenderObject を管理する Element の再利用は、このコストの
高い処理をスキップする可能性をあげることにつながります。
また、Element 再利用の条件には、Key というクラスが密接に関わっている
ことを解説しました。Element の再利用は、時として意図しない表示結果の
原因につながることがあり、Key を利用することで解決することができます。
最 後 に、フ レ ー ム ワ ー ク が 提 供 す る 最 適 化 の し く み の 一 つ で あ る

InheritedWidget にも触れました。
本章ではフレームワークの最適化により、アプリのパフォーマンスが高め
られていることがわかりました。次章では私たちエンジニアがパフォーマン
スを意識してどのようにコーディングすべきかを解説します。

284

第

10

章

高速で保守性の高い
アプリを開発するためのコツ

285

第

10 高速で保守性の高いアプリを開発するためのコツ
章

第 9 章ではフレームワークが内部で行っているパフォーマンスの最適化を
解説しました。本章も同じくパフォーマンスをテーマに、コードを書く際に
考慮すべきポイントを紹介します。

10.1
パフォーマンスと保守性、
どちらを優先すべきか
一般に、高速な
（パフォーマンスを最優先した）実装と、保守性を意識した
実装は、相反する場合があります。Flutter のパフォーマンスを最大限に引き
出す実装は、時にソースコードの可読性や保守性を低下させます。
では、パフォーマンスと保守性はどのようなバランスでアプリを開発すれ
ばよいのでしょうか。基本的には保守性を第一に実装を進めるのが良いと筆
者は考えます。前章で解説したとおり、Flutter にはパフォーマンスを意識し
た Element の再利用など、最適化のしくみがあります。それらのしくみによ
り、パフォーマンスに深刻な問題が起こることは多くないからです。
上記の前提はありますが、パフォーマンスを意識した実装と、保守性を意
識した実装が必ずしも両立しないわけではありません。本章では、パフォー
マンスに寄与しつつも保守性が高まるような実装の考え方を紹介します。意
識すべきポイントとして、常に頭の片隅に置いておいてください。

高速でないアプリとは
前項では
「高速な」
という言葉を使いましたが、本章で示す
「高速な」
アプリとは
表示がカクカクしないアプリ、画面がフリーズしないアプリのことを指します。

Flutter は 60fps（毎秒 60 フレーム）または対応デバイスでは 120fps で描画を
行うことを目標にしています。毎秒 60 フレームの場合ですと 1 フレームあた
り約 16 ミリ秒、この間に次のフレームの準備が整わなければ、表示がカクカ
クしたり、画面がフリーズしたように見えたりします。

高速だが保守性が低い実装
パフォーマンスを優先した結果、保守性が下がる実装の一例を紹介しまし
286

高速で保守性の高い実装

10.2

ょう。
「ウィジェットの build メソッドが生成するウィジェット階層は、少な
いほど効率が良い」とされ、Flutter の公式リファレンスに記載されています。
・StatelessWidget class - Performance considerations 注 1
・StatefulWidget class - Performance considerations 注 2

これを素直に受け取り、すべてのウィジェットの build メソッドで 1 つのウ
ィジェットを生成するように実装すると、細かなウィジェットクラスが増え
てしまい、保守性が低下します。

10.2
高速で保守性の高い実装
パフォーマンスにも寄与しながら、保守性の向上にもつながる実装を紹介し
ます。なお、本章では解説に重きを置くため、関連したコードの断片を掲載し
ている場合があります。省略されている部分がある点に留意してください。

buildメソッドで高コストな計算をしない
build メソッドは表示更新が必要なたびに繰り返し呼び出されます。この
中でコストのかかる処理は避けるべきです。たとえば、巨大なリストから要
素を検索するような処理です。画面遷移のために NavigatorState クラスを取
得する Navigator.of メソッドはウィジェットの階層によっては計算量の大き
な処理になり得ます。
class HomeScreen extends StatelessWidget {
const HomeScreen({super.key});
@override
Widget build(BuildContext context) {
// final navigator = Navigator.of(context);
return Scaffold(
appBar: AppBar(
title: const Text('Home Screen'),
),

❶

注1

https://api.flutter.dev/flutter/widgets/StatelessWidget-class.html#performance-considerations

注2

https://api.flutter.dev/flutter/widgets/StatefulWidget-class.html#performance-considerations

287

第

10 高速で保守性の高いアプリを開発するためのコツ
章

body: Center(

child: ElevatedButton(
onPressed: (() {

final navigator = Navigator.of(context);

❷

navigator.push(
MaterialPageRoute(builder: (context) => const DetailScreen()));

}),

child: const Text('Go to detail'),

),

),

}

}

);

build メソッドの中で❶のように NavigatorState を取得すると、build メソ
ッドが実行されるたびに NavigatorState を検索することになり無駄が多いで
す。この場合は❷のようにボタンがタップされたときにのみ NavigatorState
を取得するのが好ましい実装と言えます。
また、次の例では ListView ウィジェットでデータをリスト表示しています
が、表示するリストの要素を build メソッド内でフィルタリングしています。
class HomeScreen extends StatelessWidget {
const HomeScreen({super.key});

}

@override
Widget build(BuildContext context) {
// buildメソッド内で要素をフィルタリング
final filteredItems = items.where((item) => /* itemのフィルタ条件 */).toList();
return Scaffold(
body: ListView.builder(
itemCount: filteredItems.length,
itemBuilder: (context, index) {
return ListTile(
title: Text(filteredItems[index]),
);
},
),
);
}

これでは、build メソッドが実行されるたびにリストのフィルタリングが
行われてしまいます。あらかじめフィルタリングしたリストをウィジェット
に渡すことで、build メソッドの実行コストを下げられるでしょう。build メ
ソッドにロジックがなくなり可読性や再利用性も向上します。
288

高速で保守性の高い実装

10.2

class HomeScreen extends StatelessWidget {

const HomeScreen({super.key, required this.filteredItems});
final filteredItems; // フィルタリング済みのリストを受け取る
@override

Widget build(BuildContext context) {
return Scaffold(
body: ListView.builder(

itemCount: filteredItems.length,
itemBuilder: (context, index) {
return ListTile(

title: Text(filteredItems[index]),

);

},

),

}

}

);

buildメソッドで大きなウィジェットツリーを構築しない
build メソッドで構築するウィジェットツリーを小さくすることを意識し
ましょう。StatefulWidget の setState メソッドの呼び出し、Provider の状態更
新など、build メソッドが繰り返し呼び出されるケースがあります。このと
きに再構築するウィジェットを少なくすることで、Element の再利用判定な
どのコストを減らすことができます。
ウィジェットツリーを小さくといっても、常に 1 つのウィジェットだけを構築す
るところまで小さくすると逆に保守性に難が出てしまいます。たとえば、ウィジェ
ットの選択を見なおすことで、ウィジェットツリーを小さくすることができます。
ウィジェットツリーの階層が浅くなるようウィジェットの選択を見なおす

ウィジェットの選択を見なおすことで階層を浅くすることができます。ウ
ィジェットを右下に配置したい場合、Row ウィジェットと Column ウィジェッ
トを組み合わせて構築することができます。
class HomeScreen extends StatelessWidget {
const HomeScreen({super.key});
@override

289

第

10 高速で保守性の高いアプリを開発するためのコツ
章

Widget build(BuildContext context) {
return Scaffold(
appBar: AppBar(

title: const Text('Home Screen'),

),
/* ◆ Row

子ウィジェットを水平方向に並べる */

body: Row( // Row
mainAxisAlignment: MainAxisAlignment.end, // 右寄せ
children: [
Column( // Column

mainAxisAlignment: MainAxisAlignment.end, // 下寄せ
children: [

ElevatedButton(
onPressed: (() {

Navigator.of(context).push(MaterialPageRoute(
builder: (context) => const DetailScreen()));

}),
child: const Text('Go to detail'),

),

],

),

],

),

}

}

);

同様のレイアウトを Align ウィジェット 1 つで実現できます。
class HomeScreen extends StatelessWidget {
const HomeScreen({super.key});
@override
Widget build(BuildContext context) {
return Scaffold(
appBar: AppBar(
title: const Text('Home Screen'),
),
/* ◆ Align
alignmentパラメータに応じて子ウィジェットを配置するWidget */
body: Align( // Align
alignment: Alignment.bottomRight, // 右下寄せ
child: ElevatedButton(
onPressed: (() {
Navigator.of(context).push(MaterialPageRoute(
builder: (context) => const DetailScreen()));

290

高速で保守性の高い実装

10.2

}),

child: const Text('Go to detail'),

),

),

}

}

);

ウィジェットの階層が減り、可読性向上にもつながります。

const修飾子を付与する
const 修飾子を付与することで、ウィジェットがコンパイル時定数として扱わ
れ、常に同じインスタンスが使われるようになります。そのため、buildメソッド
が実行されてもconst 修飾子が付与されているウィジェットは再構築されません。
以下の例を見てみましょう。
class HomeScreen extends StatelessWidget {
const HomeScreen({super.key});

}

@override
Widget build(BuildContext context) {
return Column(
children: [
A(
child: Text('A'),
),
B(
child: Text('B'),
),
const C(
child: Text('C'),
),
],
);
}

Column ウィジェットの子ウィジェットに注目してください。const 修飾子
が付与されていないウィジェットとして A と B、const 修飾子が付与されてい
るウィジェットとして C があります。
この build メソッドが実行されるたびに A と B、さらにその子の Text ウィジ
ェットも再構築されます。一方、C とその子である Text ウィジェットは再構
291

第

10 高速で保守性の高いアプリを開発するためのコツ
章

築されません。Dart の最適化により、const 修飾子が付与されている C ウィジ
ェットは常に同じインスタンスが使われるためです。
では、この C ウィジェット配下は表示更新をすることができないのでしょ
うか。そんなことはありません。ウィジェットが StatefulWidget であれば状態
を更新することができますし、InheritedWidget の更新を購読することで表示
。
更新を行うこともできます
（第 9 章参照）
const 修飾子はそのウィジェット以下を更新不可にするのではなく、先祖
の再構築の影響を受けない効果があると覚えておきましょう。
const修飾子が使えるようウィジェットの選択を見なおす

Flutter が提供するウィジェットの中には constant コンストラクタを持たな
いものがあります。必要に応じて、constant コンストラクタを持つウィジェ
ットに置き換えることを検討しましょう。
たとえば、背景色を指定可能なウィジェットとして Container ウィジェッ
トと ColoredBox ウィジェットがあります。
ListView(
children: [
Container(
color: Colors.green,
child: const Text('Container'),
),
const ColoredBox(
color: Colors.green,
❷
child: Text('ColoredBox'),
)
],
)

❶

Container ウィジェットを使い背景色を指定した例（❶）と、ColoredBox ウ
ィジェットを使い背景色を指定した例（❷）です。どちらも結果は同じですが、
Container ウィジェットは constant コンストラクタを持たないため、この場
合は ColoredBox ウィジェットを使用するのがよいでしょう。
独自のウィジェットクラスにconstantコンストラクタを実装する

独自のウィジェットクラスを実装する場合は、constant コンストラクタを
実装しましょう。これには 2 つの効果があります。1 つ目は、const 修飾子を
付与することで祖先の再構築の影響を受けなくなることです。2 つ目は、

constant コンストラクタを実装するためにウィジェットクラスをイミュータブ
292

高速で保守性の高い実装

10.2

ルにする必要があり、ウィジェットが状態を持たないようになることです。
ウィジェットクラスの堅牢性が高まります。

Flutter のテンプレートプロジェクトをベースにしたサンプルを用意しました。
import 'package:flutter/material.dart';
void main() {
runApp(

const MaterialApp(
home: HomeScreen(),
),

}

);

class HomeScreen extends StatefulWidget {
const HomeScreen({super.key});
@override
}

State<HomeScreen> createState() => _HomeScreenState();

class _HomeScreenState extends State<HomeScreen> {
int _counter = 0;
void _incrementCounter() {
setState(() {
_counter++;
});
}
@override
Widget build(BuildContext context) {
return Scaffold(
appBar: AppBar(
title: const Text('Home Screen'),
),
body: Center(
child: Column(
mainAxisAlignment: MainAxisAlignment.center,
children: [
ColoredBox(
color: Colors.blueGrey,
child: Text(
'You have pushed the button\nthis many times:',

style: Theme.of(context).textTheme.headlineSmall,

❶

),

),

293

第

10 高速で保守性の高いアプリを開発するためのコツ
章

Text(

'$_counter',
style: Theme.of(context).textTheme.headlineMedium,

),

],

),

),

floatingActionButton: FloatingActionButton(
onPressed: _incrementCounter,
tooltip: 'Increment',
child: const Icon(Icons.add),

),

}

}

);

FloadingActionButton ウィジェットをタップするとカウントアップする、

Flutter のテンプレートプロジェクトをベースにしました。変更点は、❶で囲
まれた ColoredBox ウィジェットを追加したことです。文字列 You have pushed
the button\nthis many times: の表示部分に背景色をつけ、少しリッチな見
た目にしてみました。
このサンプルは、FloadingActionButton ウィジェットをタップすると
HomeScreen 画面全体が再構築されます。続いて、ColoredBox ウィジェット以
下を別のウィジェットクラスに分割してみましょう。
import 'package:flutter/material.dart';
void main() {
runApp(
const MaterialApp(
home: HomeScreen(),
),
);
}
class HomeScreen extends StatefulWidget {
const HomeScreen({super.key});
@override
State<HomeScreen> createState() => _HomeScreenState();
}
class _HomeScreenState extends State<HomeScreen> {
int _counter = 0;

294

高速で保守性の高い実装

10.2

void _incrementCounter() {
setState(() {
_counter++;

}

});

@override

Widget build(BuildContext context) {
return Scaffold(

appBar: AppBar(
title: const Text('Home Screen'),
),

body: Center(

child: Column(
mainAxisAlignment: MainAxisAlignment.center,

children: [
const ColoredText(
text: 'You have pushed the button\nthis many times:',
color: Colors.blueGrey,
),
Text(
'$_counter',
style: Theme.of(context).textTheme.headlineMedium,
),
],

❶

),
),
floatingActionButton: FloatingActionButton(
onPressed: _incrementCounter,
tooltip: 'Increment',
child: const Icon(Icons.add),
),

}

}

);

class ColoredText extends StatelessWidget {
const ColoredText({super.key, required this.text, required this.color});
final String text;
final Color color;
@override

❷

Widget build(BuildContext context) {
❸
print('ColoredText build');

295

第

10 高速で保守性の高いアプリを開発するためのコツ
章

return ColoredBox(
color: color,
child: Text(

❷

text,

style: Theme.of(context).textTheme.headlineSmall,

),

}

}

);

ColoredBox ウィジェットを構築していた部分を、ColoredText ウィジェッ
トとして切り出しました
（❷）。ColoredText ウィジェットは constant コンスト
ラクタを実装しています。また、ColoredText ウィジェットを生成している
箇所は、const 修飾子を付与しています（❶）。これで、ColoredText ウィジェ
ットは祖先の再構築の影響を受けなくなります。
このサンプルを実行すると、FloadingActionButton ウィジェットをタップ
しても ColoredText ウィジェットは再構築されず、❸で出力しているログは
アプリ起動時の一度しか出力されません。
また、ColoredText ウィジェットは constant コンストラクタを実装している
ため、状態の変化しないイミュータブルなクラスとして実装され副作用を持
ちません。プログラムの堅牢性が高まります。
一方、以下のような実装方法も考えられますが、お勧めしません。ウィジ
ェットをクラスではなく、ヘルパメソッドで実装する方法です。
class _MyHomeScreenState extends State<HomeScreen> {
int _counter = 0;
void _incrementCounter() {
setState(() {
_counter++;
});
}
@override
Widget build(BuildContext context) {
return Scaffold(
appBar: AppBar(
title: const Text('Home Screen'),
),
body: Center(
child: Column(
mainAxisAlignment: MainAxisAlignment.center,
children: [

296

高速で保守性の高い実装

10.2

_colordText(

text: 'You have pushed the button\nthis many times:',
color: Colors.blueGrey,

❶

),

Text(
'$_counter',

style: Theme.of(context).textTheme.headlineMedium,

),

],

),

),

floatingActionButton: FloatingActionButton(
onPressed: _incrementCounter,
tooltip: 'Increment',
child: const Icon(Icons.add),

),

}

}

);

Widget _colordText({required String text, required Color color}) {
return ColoredBox(
color: color,
child: Text(
text,
style: Theme.of(context).textTheme.headlineSmall,
),
);
}

❷

この例では先ほどの ColorText ウィジェットを関数として実装しました（❶、
❷）
。同じ UI は実現可能ですが、ウィジェットの再構築を抑える効果はあり
ません。

状態を末端のウィジェットに移す
状態を末端のウィジェットに移すことで、ウィジェットが再構築される範
囲を小さくすることができます。タップすると数字がカウントアップするボ
タンを例に考えてみましょう。
import 'package:flutter/material.dart';
void main() {
runApp(const MaterialApp(

297

第

10 高速で保守性の高いアプリを開発するためのコツ
章

home: HomeScreen(),

}

));

class HomeScreen extends StatefulWidget {
const HomeScreen({super.key});

}

@override
State createState() => _HomeScreenState();

class _HomeScreenState extends State<HomeScreen> {
int _counter = 0;

void _increment() {
setState(() {
_counter += 1;

}

}

});

@override
Widget build(BuildContext context) {
return Scaffold(
appBar: AppBar(
title: const Text('Home Screen'),
),
body: Center(
child: ElevatedButton(
child: Text('count = $_counter'),
onPressed: () => _increment(),
),
),
);
}

❶

画面中央のボタンがカウント数を表示しており、タップするとカウントア
ップします。このサンプルでは、❶のボタンをタップするたびに Scaffold や
AppBar ウィジェットも含めて再構築されます。実際に表示更新を行うのは
Text ウィジェットのみです。
そこで、このアプリの状態である _counter を持つウィジェットを末端に移
動させてみましょう。
import 'package:flutter/material.dart';

298

高速で保守性の高い実装

10.2

void main() {

runApp(const MaterialApp(
home: HomeScreen(),

}

));

class HomeScreen extends StatelessWidget {
const HomeScreen({super.key});

@override
Widget build(BuildContext context) {
return Scaffold(

appBar: AppBar(

title: const Text('Home Screen'),

),

body: const Center(
child: CountButton(),
),

}

}

);

class CountButton extends StatefulWidget {
const CountButton({super.key});

}

@override
State createState() => _CountButtonState();

class _CountButtonState extends State<CountButton> {
int _counter = 0;
void _increment() {
setState(() {
_counter += 1;
});
}

}

@override
Widget build(BuildContext context) {
return ElevatedButton(
child: Text('count = $_counter'),
onPressed: () => _increment(),
);
}

299

第

10 高速で保守性の高いアプリを開発するためのコツ
章

タップするとカウントアップするボタンを CountButton ウィジェットとし
て切り出しました。アプリの状態である _counter は CountButton ウィジェッ
トが持つようになりました。ボタンをタップして再構築されるのは CountButton
ウィジェットのみになり不必要な再構築が行われなくなりました。
また、関心事を分けることにもつながり、HomeScreen 画面のコードからカ
ウントアップのロジックを分離することができました。保守性が高まり、
CountButton ウィジェットは再利用性も確保されています。

Riverpodの状態監視は末端のウィジェットで行う
Riverpod の状態監視を末端のウィジェットで行うことで、ウィジェットの
再構築範囲を小さくすることができます。StatefulWidget の状態を末端に移動
することと同じ考え方です。Flutter のテンプレートプロジェクトを Riverpod
で書き換えた例を見てみましょう。
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:riverpod_annotation/riverpod_annotation.dart';
part 'main.g.dart';
@riverpod
class Counter extends _$Counter {
@override
int build() => 0;

}

❶

void increment() => state++;

void main() {
runApp(
const ProviderScope(
child: MaterialApp(
home: HomeScreen(),
),
),
);
}
class HomeScreen extends ConsumerWidget {
const HomeScreen({super.key});
@override

300

高速で保守性の高い実装

10.2

Widget build(BuildContext context, WidgetRef ref) {
return Scaffold(
appBar: AppBar(

title: const Text('Home Screen'),

),
body: Center(

child: Column(

mainAxisAlignment: MainAxisAlignment.center,
children: <Widget>[

const Text(
'You have pushed the button this many times:',
),

Text(

❷
'${ref.watch(counterProvider)}',
style: Theme.of(context).textTheme.headlineMedium,

),

],

),

),
floatingActionButton: FloatingActionButton(
onPressed: () {
ref.read(counterProvider.notifier).increment();
},
tooltip: 'Increment',
child: const Icon(Icons.add),
),

}

}

❸

);

カウンタを Riverpod のクラスベースの Provider で実装しました
（❶）
。カウン
タの状態は❷の箇所で監視、FloatingActionButtonウィジェットの onPressed
コールバックでは❸のようにカウンタをインクリメントしています。
この例では、カウンタをインクリメントすると、HomeScreen 画面の build
メソッドが呼ばれウィジェットが再構築されます。実際に更新が必要なのは
カウンタの状態を表示する Text ウィジェットのみですので、別のウィジェッ
トクラスに切り出してしまいましょう。
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:riverpod_annotation/riverpod_annotation.dart';
part 'main.g.dart';
@riverpod

301

第

10 高速で保守性の高いアプリを開発するためのコツ
章

class Counter extends _$Counter {
@override
int build() => 0;

}

void increment() => state++;

void main() {
runApp(

const ProviderScope(
child: MaterialApp(

home: HomeScreen(),

),

),

}

);

class HomeScreen extends ConsumerWidget {
const HomeScreen({super.key});
@override
Widget build(BuildContext context, WidgetRef ref) {
return Scaffold(
appBar: AppBar(
title: const Text('Home Screen'),
),
body: Center(
child: Column(
mainAxisAlignment: MainAxisAlignment.center,
children: const [
Text(
'You have pushed the button this many times:',
),
❶
CounterText(),
],

),

),
floatingActionButton: FloatingActionButton(
onPressed: () {
ref.read(counterProvider.notifier).increment();
},
tooltip: 'Increment',
child: const Icon(Icons.add),
),

}

302

}

);

高速で保守性の高い実装

10.2

class CounterText extends ConsumerWidget {
const CounterText({super.key});
@override

Widget build(BuildContext context, WidgetRef ref) {
final counter = ref.watch(counterProvider);
return Text(
'$counter',

❷

style: Theme.of(context).textTheme.headlineMedium,

}

}

);

カウンタの状態を表示するウィジェットを CounterText ウィジェットとし
て切り出しました（❷）。HomeScreen 画面の build メソッドではカウンタの監
視は行われなくなりました（❶）。
このサンプルを実行すると、カウンタをインクリメントすると HomeScreen
画面の build メソッドは呼ばれず、CounterText ウィジェットの build メソッ
ドのみが呼ばれることが確認できます。ウィジェットの再構築範囲が小さく
なり、カウンタの値を表示するウィジェットとして CounterText ウィジェッ
トは再利用性のあるクラスとなりました。

Tips アプリのパフォーマンスを計測する
高速なアプリに仕上がっているかどうかを確認する際は以下の点に注意しま
しょう。
・Profile モードでアプリを実行すること

・シミュレータなどは使用せず、実機でアプリを実行すること
Debug ビルドした Flutter アプリはアサーションの処理が含まれています。ま
た、ビルド方式もまったく異なるため Release ビルドしたアプリよりも遅い可
能性が高いです。Profile モードはほぼ Release ビルドと同等のパフォーマンス
を発揮し、さらに最低限のデバッグ情報を含んでいるため、パフォーマンス計
測に適しています。
シミュレータやエミュレータもパフォーマンスの特性が異なるため計測には
向きません。サポート対象とする端末の中でも、性能の低いものを選択し、実
機計測するのが良いとされています。

303

第

10 高速で保守性の高いアプリを開発するためのコツ
章

10.3
まとめ
パフォーマンスを意識した実装は、ときとして保守性を下げることにつな
がります。本章ではアプリのパフォーマンスとプログラムの保守性、どちら
も両立させるポイントに絞って紹介しました。Flutter アプリを開発する際は、
本章の内容をいつも頭の片隅に置いて設計を行ってみてください。

304

第

11

章

Flutterアプリ開発に
必要なネイティブの知識

305

第

11 Flutterアプリ開発に必要なネイティブの知識
章

Flutter でのアプリ開発において、欠かせない iOS/Android ネイティブの知
識を紹介します。アプリの ID 設定、ビルド署名などは一度設定してしまうと
繰り返し触れることはないので、知識として定着しづらい部分かもしれませ
ん。困ったときに本章が参考になれば幸いです。

11.1
ネイティブAPIのバージョンと
最低サポートOSのバージョン
Flutter を iOS アプリ、Android アプリとしてビルドする際に、ネイティブ側
で指定する OS や SDK バージョンによって挙動が変わることがあります。少々
ややこしいので、この部分を整理しておきます。
あります。
指定する OS と SDK のバージョンは大きく 2 つ（Android は 3 つ）
・最低サポート OS のバージョン
・ビルド SDK バージョン
・ターゲット SDK バージョン
（Android のみ）

最低サポートOSのバージョン
最低サポート OS のバージョンは、アプリをインストールできる最低の OS
バージョンです。このバージョンを低く保つことでより多くのユーザーがア
プリを利用できることになりますが、その分古い OS での挙動についても考慮
する必要があります。

iOS については Apple のデベロッパーサイト注 1 にてバージョン別のシェアが
公開されており、この数値を参考にするとよいでしょう。

Android については Android Studio の新規プロジェクト作成時にバージョン
別のシェアを確認することができます。アプリケーションメニューから「File」
➡
「New Project」を選択します。テンプレートの選択画面は何を選ん
➡
「New」
でもかまいません（図 11.1）。ここでは「No Activity」を選択し「Next」をクリッ
クします。
注1

306

https://developer.apple.com/support/app-store/

ネイティブAPIのバージョンと最低サポートOSのバージョン

図 11.1

11.1

テンプレート選択画面

プロジェクトの設定画面にて、「Help me choose」をクリックします（図
11.2）
。
図 11.2

新規プロジェクトの設定画面

307

第

11 Flutterアプリ開発に必要なネイティブの知識
章

すると、Android の OS バージョン別のシェアが表示されます（図 11.3）
。
図 11.3

Android のバージョン別シェア画面（2023 年 7 月時点）

iOSの最低サポートOSバージョンを設定する

iOS アプリの最低サポート OS バージョンを設定する際は Xcode で行うのが
よいでしょう。ios/Runner.xcworkspace を Xcode で開きます。左側のナビゲ
を選択し、「Runner」プロジェクトを選択します。
「Build
ーターから「Runner」

Settings」タブを選択し、「iOS Deployment Target」を変更します。

Tips XcodeのBuild Settings
Xcode プロジェクトの Build Settings は階層構造になっています。具体的に
はプロジェクト全体の設定と、アプリ側の設定があり継承関係にあります。プ
ロジェクト全体設定を変更しても、アプリ側でオーバーライドされていると、
変更は反映されません。図 A の「PROJECT」と「TARGETS」がそれぞれプロジェ
クト全体の設定とアプリ側の設定になります。

308

ネイティブAPIのバージョンと最低サポートOSのバージョン

図A

11.1

プロジェクトの設定とアプリの設定

●プロジェクト全体の設定

●アプリの設定

Build Settings のところで太字になっているものが明示的に指定されている
ものになります。図 A では、プロジェクト全体の iOS Deployment Target（図 A
309

第

11 Flutterアプリ開発に必要なネイティブの知識
章

の上）は「iOS 12.0」が太字になっており明示的に指定されています。
一方、アプリ側の iOS Deployment Target（図 A の下）は太字になっておらず、
プロジェクト全体の設定を継承しているということになります。

Androidの最低サポートOSバージョンを設定する

Android アプリの最低サポート OS バージョンはアプリのビルド構成ファイ
ル android/app/build.gradle に記述します。android フォルダにも android/
build.gradle が存在しますが、こちらはプロジェクト全体の構成ファイルな
ので間違えないように注意してください。android エントリ、defaultConfig
内の minSdkVersion が最低サポート OS バージョンになります。
必要な部分だけを抜粋すると以下のようになります。
./android/app/build.gradle

android {
defaultConfig {
minSdkVersion 26
}
}

ビルドSDKバージョン
ビルド SDK バージョンはその名のとおりビルド時に使用する SDK のバージ
ョンで、このバージョンを上げることで新しいネイティブ API を利用するこ
とができます。ただし、このバージョンを上げると古い OS で挙動が変わるこ
とがありますので注意が必要です。この挙動の変化は特に Android に多く見
られます。
iOSのビルドSDKバージョンの設定

iOS には実はビルド SDK バージョンという考え方はありません。Xcode の
バージョンによって使用できる API が変わります。Xcode のバージョン変更
により、Flutter アプリの挙動が大きく変わることはまれですが、バージョン
を上げる際は慎重に動作確認しましょう。
AndroidのビルドSDKバージョンの設定

Android のビルド SDK バージョンはアプリのビルド構成ファイル android/
310

ネイティブAPIのバージョンと最低サポートOSのバージョン

11.1

app/build.gradle に記述します。android エントリの compileSdkVersion が
該当します。

Android は gradle というビルドツールを使用しており、Android プロジェクト
を構成するために Android Gradle Plugin というプラグインを使用しています。

gradle のバージョン、Android Gradle Plugin のバージョン、compileSdkVersion
のそれぞれは互いに依存関係があります。compileSdkVersion のみを変更する
とビルドできないこともあります。
また、compileSdkVersion を変更する際は Android の公式ドキュメント注 2 を
参照し、動作の変更点をチェックしましょう。

ターゲットSDKバージョン
ターゲット SDK バージョンは Android のみに存在する概念です。アプリを
動作させたい SDK バージョンを指定します。SDK のバージョンによって見た
目や挙動が変わることがありますので、どのバージョンで動作させる想定な
のかを明示する設定になります。
この値は android/app/build.gradle に記述します。android エントリ、
defaultConfig 内の targetSdkVersion が該当します。必要な部分だけを抜粋
すると以下のようになります。
./android/app/build.gradle

android {
defaultConfig {
targetSdkVersion 30
}
}

Google Play Store では、この targetSdkVersion を毎年新しいバージョンに
引き上げることを必須要件として開発者に課しています。targetSdkVersion
を更新しなければ、アプリをアップデートできなくなったり、新しい OS の

Android からはストアでアプリを検索できなくなったりします。

注2

https://developer.android.com/about/versions?hl=ja

311

第

11 Flutterアプリ開発に必要なネイティブの知識
章

11.2
アプリの設定変更
ホーム画面に表示されるアプリの名前などアプリ設定に関わる内容を紹介
します。

アプリ名
ホーム画面に表示されるアプリ名は iOS/Android ネイティブ部分の設定にな
ります。
iOSのアプリ名を変更する

ios/Runner/Info.plist の CFBundleDisplayName を変更します。
./ios/Runner/Info.plist

<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/
PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
<key>CFBundleDisplayName</key>
<string>アプリ名</string>
<!-- 省略 -->
</dict>
</plist>

Androidのアプリ名を変更する

android/app/src/main/AndroidManifest.xml を編集します。マニフェストフ
ァイルと呼ばれ、アプリの情報を Android のビルドツールや OS に提供するため
のファイルです。アプリ名は application タグの android:label に設定します。
./android/app/src/main/AndroidManifest.xml

<manifest xmlns:android="http://schemas.android.com/apk/res/android"
package="com.example"><!-- packageの値は環境によって変わります -->
<application
android:label="アプリ名"
android:name="${applicationName}"
android:icon="@mipmap/ic_launcher">
<!-- 省略 -->
</application>

312

アプリの設定変更

11.2

</manifest>

アプリアイコン
アプリアイコンの設定方法について解説します。
iOSのアプリアイコンを変更する

iOS のアプリアイコンは Xcode のアセットカタログから設定します。Xcode
で ios/Runner.xcworkspace を開きます。左側のナビゲーターから
「Runner」
の
配下にある「Assets」を選択します。
（図 11.4）
。
「AppIcon」
をアプリ
「AppIcon」がアプリアイコンの設定箇所です
アイコンのアセットとして扱うことは Build Settings で設定されています。
図 11.4

AppIcon を選択した様子

デフォルトではさまざまなサイズのアイコン画像を要求されます。2x や 3x
などのバリエーションは、Flutter のアセットと同じくディスプレイの解像度
によって使い分けられます。大きな画像を 1 つ指定して自動的にリサイズさ
を選択します
（図 11.5）
。
せることも可能で、右側のインスペクタで「Single Size」
この場合、細かな線が消えてしまうこともあるので注意してください。

313

第

11 Flutterアプリ開発に必要なネイティブの知識
章

図 11.5

アイコンのインスペクタ

Androidのアプリアイコンを変更する

Android のアイコンはシンプルな画像のほか、バックグラウンドとフォアグ
ラウンドの 2 つのレイヤで構成されるアダプティブアイコンと呼ばれるもの
があります。アダプティブアイコンは OS バージョン 8.0 以降で導入され、

Android のモデルによってアイコンの表示が変わります。円形、角丸四角形、
操作によってアイコンだけが動いて見えるアニメーションが加わるなどさま
ざまです。
アダプティブアイコンの作成は必須ではありませんが、設定されていると
アプリのブランディングに役立ちます。サイズや余白のレギュレーションが
細かく定められているので、アダプティブアイコンを作成する場合は公式の
アダプティブアイコンの資料注 3 を参照してください。
アイコンの指定はマニフェストファイルで行います。application タグの
android:icon に設定します。
注3

314

https://developer.android.com/guide/practices/ui_guidelines/icon_design_adaptive

アプリの設定変更

11.2

./android/app/src/main/AndroidManifest.xml

<manifest xmlns:android="http://schemas.android.com/apk/res/android"

package="com.example"><!-- packageの値は環境によって変わります -->
<application
android:label="アプリ名"

android:name="${applicationName}"
android:icon="@mipmap/ic_launcher">
<!-- 省略 -->

</application>

デフォルト値の @mipmap/ic_launcher は android/app/src/main/res 配下に
ある mipmap から始まるフォルダの ic_launcher.png という名前の画像を指定
しています。mipmap から始まるフォルダは、mipmap-mdpi や mipmap-hdpi など
のようにサイズごとに分かれていて、こちらもディスプレイの解像度によっ
て使い分けられます。論理解像度に対して物理解像度の倍率で表現すると表
11.1 のようになります。
表 11.1

フォルダ名と倍率の対応表

フォルダ名

倍率

mipmap-mdpi

1.0

mipmap-hdpi

1.5

mipmap-xhdpi

2.0

mipmap-xxhdpi

3.0

mipmap-xxxhdpi

4.0

アプリアイコンを手軽に生成するパッケージ

iOS と Android それぞれにアプリアイコンファイルを作成し、設定するのは
手間がかかります。そこで、アプリアイコンを手軽に生成するパッケージを
紹介します。flutter_launcher_icons というパッケージです。

flutter_launcher_icons の導入は pub コマンドで行います。アプリの実行に必
要なコードではないので、--dev オプションを付けてインストールします。
$ flutter pub add --dev flutter_launcher_icons

アプリアイコンの設定情報は pubspec.yaml または任意の YAML ファイルに
記述します。以下はその一例です。
./pubspec.yaml

# 省略
flutter_launcher_icons:

315

第

11 Flutterアプリ開発に必要なネイティブの知識
章

image_path: "icon.png" # アイコン画像のパス

ios: true # iOSのアイコンを生成し、デフォルトのものと置き換えるか
android: true # Androidのアイコンを生成し、デフォルトのものと置き換えるか

pubspec.yaml に設定を記述したら、以下のコマンドを実行します。
$ flutter pub run flutter_launcher_icons

もし、任意の YAML ファイルに設定を記述した場合は、-f オプションでフ
ァイルを指定します。
$ flutter pub run flutter_launcher_icons -f path/to/config.yaml

以上の操作を行うことで、iOS と Android それぞれにアイコンが設定されま
す。flutter_launcher_icons の詳細な設定項目などは pub.dev 注 4 をご覧ください。

スプラッシュ画面
スプラッシュ画面とは、アプリ起動時に一瞬表示される画面のことです。
iOSとAndroidで異なるスプラッシュ画面の位置付け

スプラッシュ画面は iOS と Android で位置付けが異なります。

iOS はアプリがすばやく起動することが重視されています。アプリの最初
の画面と似たスプラッシュ画面を表示することで、すばやく起動したように
感じさせることが推奨されています。表示時間をコントロールすることはで
きません。表現やブランディングの機会ではなく、文字を含めることは避け
るようにガイドラインで定められています。
一方、Android のスプラッシュ画面はアプリアイコンを中央に表示する標準
レイアウトが提供され、ブランディングを意識して、アニメーションや色をカ
スタマイズ可能となっています。表示時間をコントロールすることも可能です。
iOSのスプラッシュ画面

iOS のスプラッシュ画面は Storyboard という XML 形式のファイルで作成しま
す。使用する Storyboard は ios/Runner/Info.plist の UILaunchStoryboardName
に設定します。
注4

316

https://pub.dev/packages/flutter_launcher_icons

アプリの設定変更

11.2

./ios/Runner/Info.plist

<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/
PropertyList-1.0.dtd">
<plist version="1.0">

<dict>
<key>UILaunchStoryboardName</key>
<string>LaunchScreen</string>

</dict>
</plist>

デフォルトでは LaunchScreen となっており、ios/Runner/Base.lproj/
LaunchScreen.storyboard を指しています。
この Storyboard を編集することでスプラッシュ画面をカスタマイズできま
す。Storyboard は Xcode で編集します。さまざまなデバイスサイズに対応さ
せるには Auto Layout という制約でレイアウトを計算するしくみが不可欠で
す。本書では Auto Layout の解説は割愛しますが、筆者の印象では Auto Layout
の習得難易度はやや高めです。
Androidのスプラッシュ画面

Android では OS バージョン 12 を境に標準のスプラッシュ画像が導入されま
した。アプリを実行する Android が OS バージョン 12 以上であれば、アプリア
イコンが中央に表示されるスプラッシュ画面が自動的に表示されます。OS バ
ージョン 12 未満の場合は、androidx.core:core-splashscreen という下位互
換ライブラリを使用することで同様のスプラッシュ画面を実現できます。

Android のスプラッシュ画面は、中央のアイコン、背景色、終了アニメーシ
ョンなどをカスタマイズできます。本書で詳細な実現方法は割愛します。詳
しくは Android の公式ドキュメント注 5 を参照してください。
スプラッシュ画面を手軽に実現するパッケージ

iOS と Android でスプラッシュ画面の位置付けが異なること、また実現方法
もまったくバラバラであることを解説しました。それぞれのプラットフォー
ムに合わせてスプラッシュ画面を実装するのは骨の折れる作業です。Flutter
のパッケージで iOS と Android のスプラッシュ画面を自動生成する flutter_

native_splash というパッケージがありますので、強いこだわりがなければこ
注5

https://developer.android.com/about/versions/12/features/splash-screen?hl=ja

317

第

11 Flutterアプリ開発に必要なネイティブの知識
章

のパッケージを使用するのが手軽でよいと筆者は考えています。
このパッケージは iOS であればスプラッシュ画面に相当する Storyboard を自動
生成します。Android の場合は OS バージョン 12 以上であれば標準のスプラッシ
ュ画面を使用し、OS バージョン 12 未満は独自にスプラッシュ画面を生成します。
プロジェクトのディレクトリで、ターミナルから以下のコマンドを実行し
てください。
# flutter_native_splashパッケージを導入
$ flutter pub add flutter_native_splash

スプラッシュ画像に関する設定は pubspec.yaml または任意の YAML ファイ
ルに記述します。以下はその一例です。
./pubspec.yaml

# 省略

flutter_native_splash:
color: "#00FFFF" # スプラッシュ画面の背景色
image: icon.png # スプラッシュ画面の中央に表示する画像
android_12: # Android 12以上の標準スプラッシュ画面の設定
color: "#FF00FF"
android_gravity: left # Androidのアイコンの画像の位置
ios_content_mode: left # iOSのアイコンの画像の位置

pubspec.yaml に設定を記述したら、以下のコマンドを実行します。
$ dart run flutter_native_splash:create

もし、任意の YAML ファイルに設定を記述した場合は、--path オプション
でファイルを指定します。
$ dart run flutter_native_splash:create --path=path/to/config.yaml

iOS に関しては Storyboard を自動生成するので、アイコン画像や背景のほか、
アイコンの位置などもカスタム可能となっています。一方、Android に関しては

OS バージョン 12 以上であれば標準のスプラッシュ機能を使用するので、設定項
目が分かれています。上記の例ですと、Android12 未満の場合は背景色は#00FFFF
が採用され、アイコンの位置は左寄せになります。Android12 以上の場合は背景
色は#FF00FFが採用され、アイコンの位置は変更不可のため中央になります。

318

アプリの設定変更

11.2

flutter_native_splash のより詳細な使い方は pub.dev 注 6 を参照してください。

アプリのID
iOS も Android もそれぞれアプリを一意に識別する ID があります。iOS は
Bundle ID、Android は Application ID と呼ばれます。この ID は他のアプリと
重複しないように、自分が所有するドメインを逆順にしたものを使用するの
が一般的です。たとえば、筆者が所有するドメインが example.com であれば、
com.example.myapp のようになります。
プログラムがまったく同じアプリでもアプリ ID が異なると別のアプリとし
て扱われます。これを逆手にとり、検証環境のサーバに接続するアプリと本
番環境のサーバに接続するアプリを 1 台の端末に共存させることができます。
iOSのアプリIDを設定する

iOS のアプリ ID はプロジェクトファイルに記述されています。Xcode で編集
するのが無難です。ios/Runner.xcworkspace を Xcode で開き、TARGETS の
「Build Settings」のタブを開きます（❷）
。
「bundle
「Runner」を選択して（❶）

identifier」でフィルタをかけると
（❸）
、すぐに設定項目が見つかります
（図 11.6）
。
図 11.6

bundle identifier の設定の様子
❷

❸

❶

注6

https://pub.dev/packages/flutter_native_splash

319

第

11 Flutterアプリ開発に必要なネイティブの知識
章

AndroidのアプリIDを設定する

Android のアプリ ID はアプリのビルド構成ファイル android/app/build.
gradle に記述します。android エントリ内 defaultConfig の applicationId に
設定します。
./android/app/build.gradle

android {

defaultConfig {
applicationId "com.example.myapp"

}

}

11.3
アプリの配布とコード署名
App Store や Google Play Store でアプリを配布するには、アプリにデジタル
署名をする必要があります。筆者の考えるモバイルアプリの鬼門はこのコー
ド署名です。
コード署名とは、アプリの開発元が正しく、配布されたアプリが改ざんさ
れていないことを証明するしくみです。秘密鍵を使ってアプリに署名し、そ
の秘密鍵とペアになる公開鍵の証明書をアプリの中に埋め込みます。こうす
ることで、アプリが改ざんされていないか検証することができるのです。iOS
と Android とで証明書の取り扱いがまったく異なり、Flutter エンジニアにと
っては敷居が高いものとなっています。
本節では、iOS と Android のコード署名のしくみ、App Store や Google Play

Store でアプリを配布するための署名の方法を解説します。なお、Apple と
Google の開発者アカウントが必要となりますが、これらを事前に取得してい
ることを前提として解説します。Apple の開発者アカウントと Google の開発
者アカウントはそれぞれ以下から登録できます。
・https://developer.apple.com/jp/programs/
・https://developer.android.com/distribute/console

料金が発生しますのでよく確認してから登録してください。
また、本章で利用するアカウントは Apple Developer Program に個人登録し
た Apple ID を想定しています。組織登録した場合や Apple Developer Enterprise
320

アプリの配布とコード署名

11.3

Program に登録した場合などではアカウントがアプリの登録、アプリ ID
（AppID）やプロビジョニングプロファイルの作成、証明書の作成に必要な権
限を付与されている必要があります。

iOSのコード署名
iOS のコード署名と検証のプロセスには、プロビジョニングプロファイル
というファイルが関わってきます。プロビジョニングプロファイルはアプリ

ID と証明書が含まれたファイルです。アプリ ID と証明書は Apple の開発者ア
カウントに紐付いています。

Xcode プロジェクトは以下の 4 つの設定項目があり、すべてが正しく設定
されていなければ、アプリの署名は成功しません。
・Apple の開発者アカウント
（Team ID）
・アプリ ID
・証明書
・プロビジョニングプロファイル

管理の難しい秘密鍵

iOS のコード署名で管理が難しいのが秘密鍵です。証明書を発行した Mac
にのみ秘密鍵が存在し、他の Mac に移す際は証明書とともにエクスポートす
る必要があります。秘密鍵を紛失した場合は、証明書を再発行する必要があ
ります。また、証明書には有効期限があり、有効期限が切れた場合もまた再
発行する必要があります。
これらの管理の手間を軽減する手段としてクラウド管理対象証明書という
しくみが導入されました。秘密鍵や証明書は Apple が管理し、ビルド環境に
は必要ありません。任意の環境でビルドしたアプリのハッシュ値を Apple に
送信し、署名情報を取得してアプリに署名するというしくみです（図 11.7）
。

321

第

11 Flutterアプリ開発に必要なネイティブの知識
章

図 11.7

クラウド管理対象証明書のしくみ

Hash

クラウド管理対象証明書を使うかどうかは選択可能です。本書ではこのし
くみを使ってアプリを署名する方法を解説します。
アプリに署名する

それでは、クラウド管理対象証明書を使ってアプリに署名する手順を解説
します。ios/Runner.xcworkspace を Xcode で開きます。図 11.8 のようにナビ
ゲーションペインの「Runner」を選択し（❶）、TARGETS の「Runner」を選択し
ます
（❷）
。
図 11.8

「Signing & Capabilities」のタブを表示

❸

❶

❷

❹

続いて、
「Signing & Capabilities」のタブを選択します（❸）
。
のボタンをクリックする
（❹）とログイン画面が表示されま
「Add Account...」
。
すので、Apple の開発者アカウントでログインします（図 11.9）
322

アプリの配布とコード署名

図 11.9

11.3

ログインダイアログ

ログインが完了したら設定画面を閉じます。
図 11.10 の画面が表示されたら、まず「Automatically manage signing」のチェ
のドロッ
ックボックスがオンになっていることを確認します
（❶）
。次に
「Team」
。最後にアプ
プダウンリストから Apple の開発者アカウントを選択します（❷）
7
。アプリ ID の変更は
「iOS のアプリ ID を設定する」
の
リ ID を設定します注（❸）

のタブからも行えます。
項で解説した方法か、この
「Signing & Capabilities」
図 11.10

Team、アプリ ID の設定の様子

❶
❷
❸

クラウド管理対象証明書を使う場合、設定は以上です。
いよいよアプリの署名を開始します。ビルド対象を「Any iOS Device」に設

注7

図ではアプリ ID が「com.example...」となっていますが、アプリ ID としては無効な文字列です。検
証される際は有効なアプリ ID を設定してください。

323

第

11 Flutterアプリ開発に必要なネイティブの知識
章

定します
（図 11.11）
。
図 11.11

ビルド対象の選択

Xcode のメニューから「Product」➡「Archive」を選択します。アーカイブと
は、アプリの成果物をひとまとめにしたバンドルを作成することです。
完了するとオーガナイザーが開きます。通常、先ほどの操作で作成したア
をクリックしま
ーカイブが選択されていますので、そのまま「Distribute App」
す（図 11.12）
。
図 11.12

オーガナイザーウィンドウ

配布先の選択画面が表示されますので、「TestFlight & App Store」を選択し
ます
（図 11.13）
。
324

アプリの配布とコード署名

図 11.13

11.3

配布先の選択画面

App Store Connect にアプリが登録されていない場合は、アプリ情報を入力す
は App Store に表示されるアプリ名です。
るダイアログが表示されます。
「Name:」
「SKU:」はアプリを一意に識別するための ID です。デフォルトでは Bundle ID と
同じ値が設定されていて、そのままで問題ありません。日本語にのみ対応するア
は
「Japanese」
に設定しましょう。最後に
「Bundle
プリの場合は
「Primary Language:」

Identifier」
に誤りがないことを確認して
「Next」
をクリックします
（図11.14）
。
図 11.14

アプリ情報の入力画面

325

第

11 Flutterアプリ開発に必要なネイティブの知識
章

するとアプリの署名と App Store Connect へのアップロードが開始されま
す。完了すると図 11.15 の画面が表示されます。
図 11.15

アップロード完了画面

画面左下の「Export」ボタンをクリックし、任意のディレクトリに出力する
とアプリの要約が確認できます。DistributionSummary.plist というファイ
ルが出力されますので、テキストエディタで開いてみましょう。
./DistributionSummary.plist

<!-- 省略 -->
<key>certificate</key>
<dict>
<key>SHA1</key>
<string>ハッシュ値</string>
<key>dateExpires</key>
<string>有効期限</string>
<key>type</key>
<string>Cloud Managed Apple Distribution</string>
</dict>

キーcertificate の type が「Cloud Managed Apple Distribution」になってお
り、クラウド管理対象証明書で署名されていることがわかります。

Androidのコード署名
Android では秘密鍵と公開鍵証明書を格納したキーストアというファイルを使用
します。iOS と同様に、Android も証明書をクラウドで管理するしくみがあり、Google

Play Console ではこの方法を推奨しています。その手順は以下のとおりです。
326

アプリの配布とコード署名

11.3

❶開発者がキーストアを作成する
❷開発者が❶のキーストアを使い、アプリに署名をする
❸署名済みの❷のアプリを Google Play Console にアップロードする
❹ Google Play Console がアプリの署名を検証する
❺ Google Play Console が生成・管理するキーストアでアプリを再署名する
❻再署名済みのアプリを Google Play Store に配布する

❶で作成したキーストアの秘密鍵をアップロード鍵、❺で Google Play

Console が生成・管理するキーストアの秘密鍵をアプリ署名鍵と呼びます。
Android はアプリをアップデート（新しいバージョンのアプリを上書きイン
ストール）する際に、同じ証明書で署名されている必要があります。証明書を
紛失してしまうと、アプリのアップデートができなくなってしまいます。そ
のため、ユーザーの手もとで検証される証明書を Google Play Console がクラ
ウド上で管理することで、リスクを軽減しているのです。
手順が非常に多いように見えますが、実際には Android Studio の GUI を使
って簡単に行うことができます。

apkファイルとaabファイル
Android のプロジェクトは、apk ファイルと aab ファイルの 2 種類のファイ
ルを生成することができます。インストール可能なアプリのファイル形式は

apk ファイルです。aab は Android App Bundle の略で、そのままではインスト
ールできません。aab はコンパイル済みのコードとリソースをすべて内包し
たファイルで、インストールする端末向けに aab から最適化した apk ファイル
を生成することができます。

Google Play で公開するアプリは、aab の形式でのアップロードしかサポー
トされていません。Google Play Console が aab ファイルを apk ファイルに変
換、その際にアプリ署名鍵で署名を行い、ユーザーの端末にインストールさ
れるのです。
アプリに署名する

それでは、アップロード鍵の生成とアプリへの署名手順を解説します。

Android Studio を使うと簡単に行えます。
プロジェクトルート直下の android ディレクトリを Android Studio で開きま
327

第

11 Flutterアプリ開発に必要なネイティブの知識
章

す。アプリケーションメニューの「Build」➡「Generate Signed Bundle/APK」を
選択します。
をクリックします（図
ダイアログで
「Android App Bundle」を選択し、「Next」
11.16）
。
図 11.16

ファイル形式の選択ダイアログ

次の画面で「Create new...」を選択し、アップロード鍵を生成します（図
11.17）
。
図 11.17

328

署名設定のダイアログ

アプリの配布とコード署名

11.3

図 11.18 のダイアログの上部から、「Key store path:」
にはキーストアの保存
「Password:」と
先を指定します。ファイルの拡張子は「.jks」を指定します。
にはキーストアのパスワードを入力します。
「Alias:」
には鍵を識別
「Confirm:」
と
「Confirm:」
には先ほど
する任意の名前を入力します。その下の「Password:」
のキーストアのパスワードと同じものを入力します。
「Validity (years):」は鍵
「Certificate」には
の有効期限を指定します。25 年以上が推奨されています。
証明書の所有者情報を入力します。ストアで公開されることはありませんが、
証明書の情報としてアプリに組み込まれます。
をクリックすると、キーストアが生成されます。
「OK」
図 11.18

キーストア作成ダイアログ

もとのダイアログ（図 11.17）に戻ったら「Next」
をクリックします。
をクリックします
（図 11.19）
。
次の画面では
「release」を選択し、「Create」
ビルドが完了すると、android/app/release ディレクトリに aab ファイルが
生成されます。

329

第

11 Flutterアプリ開発に必要なネイティブの知識
章

図 11.19

ビルドバリアントの選択ダイアログ

aabファイルをアップロードする

実際に aab ファイルを Google Play Console にアップロードし、処理される様子
を見てみましょう。aab ファイルをアップロードするために、Google Play Console
でアプリの情報登録などの操作が必要になりますが、その操作については駆け足
で説明します。本項はアプリの署名にフォーカスした内容のためご容赦ください。

Google Play Console にログインし、右上の「アプリを作成」をクリックしま
す
（図 11.20）
。
図 11.20

330

Google Play Console のトップ画面

アプリの配布とコード署名

11.3

アプリの必要情報を入力し、「アプリを作成」
をクリックします
（図 11.21）
。
図 11.21

Google Play Console のアプリ作成画面

左側のメニューに「製品版」のほか、「テスト」
の配下に
「オープンテスト」
や
。
「クローズド テスト」などがあります（図 11.22）

331

第

11 Flutterアプリ開発に必要なネイティブの知識
章

図 11.22

Google Play Console のダッシュボード画面

「製品版」
は Google Play で公開中のバージョンを管理する画面です。アプリ
を
「製品版」
として公開する前にテスターに配布するなどの用途で「テスト」
以
下の項目を使います。今回はアップロードの動作を見ることを目的に「内部テ
スト」
を選択します。「内部テスト」をクリックし、右上の「新しいリリースを
作成」
をクリックします
（図 11.23）。

332

アプリの配布とコード署名

図 11.23

11.3

Google Play Console の内部テスト画面

図 11.24 の画面で「署名鍵を選択」をクリックすると、署名鍵の選択ダイア
を選択します。
ログが表示されます（図 11.25）。「Google 生成の鍵を使用」
図 11.24

Google Play Console のリリース作成画面

333

第

11 Flutterアプリ開発に必要なネイティブの知識
章

図 11.25

署名鍵の選択ダイアログ

図 11.24 の画面に戻ったら「アップロード」をクリックすると、ファイル選
択ダイアログが表示されますので、先ほど生成した aab ファイルを選択しま
す。続いて「リリースの詳細」に必要事項を入力し、「次へ」
をクリックします。
右下の
「保存して公開」をクリックすると、内部テストのリリースが作成さ
れます。

aab ファイルのアップロードが完了しました。これで先ほどアプリをビル
ドする際に作成したキーストアがアップロード鍵として自動的に登録されま
す。次回以降のアップロードでは、同じキーストアを使ってビルドしなけれ
ばアップロード時にエラーとなります。

11.4
まとめ
Flutter アプリを開発するうえで欠かせない iOS、Android ネイティブの知識
を解説しました。Swift や Kotlin に触れずとも Flutter アプリを開発することは
可能ですが、本章で紹介したアプリ ID や最低サポート OS バージョンの設定
などは、欠かすことのできない知識です。
また、アプリの署名に関しては、時にはネイティブアプリエンジニアも苦
戦することのある難しいものと筆者は感じています。本章の内容が、みなさ
んの Flutter アプリをリリースする一助になれば幸いです。
334

参考Web情報
・「Flutter documentation」
https://docs.flutter.dev/
・「Dart programming language」
https://dart.dev/language
・mono.「InheritedWidget を完全に理解する」. Medium.
https://medium.com/flutter-jp/inherited-widget-37495200d965
・mono.「Flutter の Widget ツリーの裏側で起こっていること」. Medium.
https://medium.com/flutter-jp/dive-into-flutter-4add38741d07
・mono.「Stateful Widget のパフォーマンスを考慮した正しい扱い方」. Medium.
https://medium.com/flutter-jp/state-performance-7a5f67d62edd
・村松龍之介「
. Flutter x Riverpod でアプリ開発！ 実践入門」. Zenn.
https://zenn.dev/riscait/books/flutter-riverpod-practical-introduction

著者プロフィール

渡部 陽太（わたなべ ようた）
新卒で SIer に入社しアプリケーション開発の経験を積む。
その後、事業会社への転職を機にモバイルアプリ開発に
軸足を移す。新規サービス立ち上げを複数経験。

2020 年に iOS/Android テックリードとして株式会社ゆめ
みに入社。複数のプロジェクトを支援する傍ら、新人研
修の作成や新技術推進を行う。

2022 年より技術担当取締役に就任。
所属：株式会社ゆめみ

X（旧 Twitter）：@yohta_watanave
GitHub：watanavex

335

索引

記号

Appleの開発者アカウント
（Team ID）

! .......................................................... 49, 55

.. ........................................................... 321

$ ............................................................... 28

Application ID. . ..................................... 319

${} ............................................................ 28

App Store.......................... 9, 121, 194, 320

&& .. .......................................................... 44

arbファイル. . ........................... 121, 122, 125

.. ............................................................... 37

as...................................................... 49, 201

/* */ .. ....................................................... 54

asBroadcastStream. . ............................. 87

/** .. .......................................................... 54

assert....................................................... 52

// ............................................................. 54

Assets.................................................... 134

/// .. .......................................................... 54

async.......................................... 79, 81, 227

? ......................................................... 49, 55

async*...................................................... 82

?. .............................................................. 55

AsyncValue........................................... 227

?? ............................................................. 56

await........................................................ 79

??= .......................................................... 56

await for.................................................. 81

@@locale............................................... 128

base. . .................................................. 72, 73

@override................................................ 65

bool.. ............................... 29, 39, 45, 52, 138

@riverpod..................... 225, 226, 232, 255

break.................................................. 40, 43

@Riverpod............................................. 232

Brightness.dark.................................... 147

_ ......................................................... 50, 57

build_runner.. ................................ 133, 185

|| .............................................................. 44

build............................... 217, 264, 273, 287

+ .............................................................. 28

BuildContext......................................... 264

== .. .................................................... 37, 44

Bundle ID.............................................. 319

A

bundle identifier. . ................................. 319

abstract....................................... 72, 73, 76

cancel.. ..................................................... 81

add.. .............................................. 29, 30, 86

cancelOnError........................................ 85

addError. . ................................................. 86

catch........................................................ 51

Align....................................................... 290

catchError............................................... 79

Android Studio.. .................................. 7, 12

Center...................................................... 95

androidx.core:core-splashscreen..... 317

CFBundleDisplayName...................... 312

aabファイル............................................ 327

336

B

@JsonSerializable................................ 249

C

any.......................................................... 111

CFBundleLocalizations. . ..................... 121

apkファイル............................................ 327

CLDR（Common Locale Data

app_localizations.dart......................... 123

....................................... 128
Repository）

AppBar................................................... 157

CocoaPods.......................................... 9, 10

Apple Developer Program.................. 320

ColoredBox.. .......................................... 274

索引

Column............................................ 97, 289

Exception.. ............................................... 51

compileSdkVersion. . ............................ 311

extends.............................................. 65, 72

const........................................................ 25

extensions............................................. 149

constantコンストラクタ.. ......................... 63

F

ConsumerState.................................... 261

factoryコンストラクタ. . ............................ 64

ConsumerStatefulWidget................... 261

FieldRename.snake............................. 249

ConsumerWidget................................. 218

fieldRename. . ........................................ 249

Container. . ............................................... 95

final........................................ 25, 71, 72, 76

continue. . ........................................... 40, 43

finally....................................................... 52

copyWith.. .............................................. 144

findAncestorWidgetOfExactType...... 265

createState................................... 103, 271

FloatingActionButton.......................... 221

CupertinoApp....................................... 152

. . ......................... 5
flutter doctor
（コマンド）

CupertinoThemeData......................... 152

Flutter Favorite Program.................... 108

custom_lint................................... 223, 241

Flutter SDK......................................... 4, 13

D

flutterコマンド......................................... 15

dart:convert.. ......................................... 253

flutter/foundation.dart. . ...................... 200

dart-define-from-file. . ................. 137, 251

flutter_gen. . ................................... 133, 185

DartPad................................................... 94

flutter_gen_runner....................... 133, 185

dartコマンド. . ........................................... 15

flutter_hooks.. ....................................... 222

Dartプラグイン. . ....................................... 12

flutter_launcher_icons........................ 315

DateFormat................................... 115, 119

flutter_localizations..................... 115, 118

DateTime. . ..................................... 115, 192

flutter_native_splash.. .................. 317, 319

debugビルド............................................ 52

flutter_riverpod.. ................................... 221

decodeImage........................................ 201

flutter_svg..................................... 134, 185

default. . .................................................... 40

FlutterError.onError............................... 53

dependencies....................................... 109

Flutterプラグイン. . ................................... 12

dependOnInheritedWidgetOfExactType

for................................................. 38, 42, 43

.. ........................................................... 283

forEach.................................................... 42

description............................................ 123

for-in.................................................. 42, 48

dev_dependencies. . ............................. 109

Form....................................................... 244

dispose.......................................... 248, 272

FormField.............................................. 244

double...................................................... 27

fromEnvironment................................. 138

do-while.. ................................................. 43

Future.. ............................................. 78, 227

dynamic................................................... 33

fvm. . .................................................... 13, 15

E

G

Element................................. 154, 264, 286

GestureDetector.................................. 101

ElevatedButton.. ................................... 154

get.. ........................................................... 62

else........................................................... 39

git. . ........................................................ 5, 17

enum........................................................ 70

GlobalCupertinoLocalizations.delegate

Error......................................................... 51

.. ........................................................... 118

337

GlobalKey.............................................. 281

Intl.defaultLocale. . ............................... 119

GlobalMaterialLocalizations.delegate

Iterable.................................................... 42

.. ........................................................... 118

GlobalWidgetsLocalizations.delegate
.. ........................................................... 118

json_annotation.dart........................... 249

go_router........................................ 167, 175

json_serializable.......................... 240, 249

go............................................ 170, 175, 180

jsonDecode........................................... 253

Google Play Console................... 326, 330

jsonEncode........................................... 253

Google Play Store........................ 311, 320

JSONの取り扱い................................... 236

GoRoute. . ....................................... 168, 170

K

GoRouter....................................... 168, 170

keepAlive............................................... 232

H

Key........................................... 99, 275, 281

hasListener............................................. 86
Homebrew. . ....................................... 10, 13

key-value................................................. 30
L

hooks_riverpod. . ................................... 221

L10n.localizationsDelegates. . ............ 124

http......................................................... 240

l10n.yaml............................................... 122

I

late.. .......................................................... 26

IANA（Internet Assigned Numbers

lerp......................................................... 148

Authority）言語サブタグレジストリ. . . 118

List.. .............................................. 29, 38, 46

IconButton............................................ 204

listen........................................................ 81

ICU（International Components for

ListView. . ............................................... 288

.. .......................................... 127
Unicode）

Locale.................................................... 118

if.......................................................... 38, 39

Localizations.. ....................................... 120

if-case.......................................... 39, 44, 46

localizationsDelegates. . ...................... 118

image............................................. 183, 185

M

image/image.dart................................ 200

Map.................................. 30, 34, 38, 46, 48

image_picker................................ 183, 185

map.......................................................... 88

image_picker/image_picker.dart.. ..... 200

markNeedsPaint.................................. 275

Image（ウィジェット）.............................. 130

Material Design 3................................ 146

Image（クラス）....................................... 200

MaterialApp.................................. 114, 266

ImagePicker.................................. 199, 201

MaterialPageRoute.. ............................ 156

implements............................................. 67

minSdkVersion..................................... 310

import.. ..................................................... 57

mipmap. . ................................................ 315

index.. ....................................................... 72

mixin. . ........................................... 69, 73, 77

Info.plist.. ............................................... 121

338

J

json_annotation................................... 240

N

InheritedWidget................................... 282

name........................................................ 72

initState................................................. 211

Navigator 1.0........................ 153, 155, 185

int.. .................................................... 27, 138

Navigator 2.0........................ 153, 155, 167

interface............................................ 72, 75

Navigator.of.. ................................. 265, 287

intl.. .................................. 115, 119, 121, 185

Navigator............................................... 153

索引

NavigatorState............................. 156, 287

required................................................... 58

Notifier. . ................................................. 219

resume..................................................... 82

NotifierProvider. . .................................. 220

rethrow.................................................... 52

NSPhotoLibraryUsageDescription... 199

return................................................. 40, 64

null. . .............................................. 24, 49, 55

Riverpod........................ 216, 221, 236, 300

num.......................................................... 27

riverpod.. ................................................ 221

O

riverpod_annotation............................ 222

Object................................................ 33, 61

riverpod_generator.............................. 222

ObjectKey.. ............................................ 281

riverpod_lint.......................................... 223

on. . ...................................................... 51, 68

Rosetta 2................................................... 4

onDone.................................................... 83

Route. . ............................................ 153, 154

onError..................................................... 80

Router............................................ 153, 167

onPressed............................................. 231

RouterConfig.. ....................................... 168

output-class.. ........................................ 124

routerConfig. . ........................................ 168

P

Row........................................................ 289

Padding.. ................................................ 242

runApp..................................................... 95

Page....................................................... 153

runZonedGuarded.. ................................ 89

part......................................................... 225

S

pause....................................................... 82

Scaffold.. ................................................ 114

PlatformDispatcher............................... 53

sealed........................................ 72, 77, 254

plural...................................................... 127

select..................................................... 231

PNG形式................................................ 129

Set................................................ 30, 38, 42

pop.. ................................................. 157, 175

set. . ........................................................... 62

Provider......................... 218, 221, 224, 289

setState................................. 103, 216, 289

ProviderScope...................................... 259

ShellRoute. . ........................................... 175

pub get. . ................................................. 109

SizedBox. . ...................................... 242, 243

pub................................................. 108, 111

State. . .............. 103, 213, 216, 217, 271, 273

pub.dev.................................................. 108

StatefulWidget.................... 100, 216, 268,

pubspec.lock. . .................................. 17, 111

272, 273, 287

pubspec.yaml.................................. 17, 108

StatelessWidget..................... 96, 283, 287

push....................................... 156, 175, 178

static........................................................ 45

pushNamed.. ......................................... 166

Storyboard.. ........................................... 316

R

Stream.periodic. . .................................... 84

Raw........................................................ 230

Stream............................................. 81, 227

read........................................................ 230

StreamController................................... 85

Record.. ........................................ 31, 46, 48

String.. .............................................. 27, 138

Ref.......................................................... 218

super........................................................ 65

refresh................................................... 232

supportedLocales................................ 118

RenderObject............................... 273, 275

SVG形式................................................ 134

RenderObjectElement.. ....................... 273

switch.. ................................... 40, 41, 44, 46

339

T

take.......................................................... 88
targetSdkVersion................................. 311

あ

Text. . ......................................................... 95

アイソレート.............................................. 90

TextEditingController.......................... 246

アセット................................................... 129

TextField........................................ 114, 242

アダプティブアイコン. . ............................ 314

TextFormField. . ..................................... 245

アップロード鍵.. ...................................... 327

textTheme............................................. 143

アプリアイコン........................................ 313

Theme.of....................................... 149, 282

アプリ署名鍵.......................................... 327

Theme. . .......................................... 149, 282

アプリ名.................................................. 312

ThemeData........................... 143, 149, 282

アロー演算子（=>）.................................. 59

ThemeExtension.................................. 148

位置フィールド. . ........................................ 32

then.......................................................... 79

インタフェース.. ......................................... 67

throw.................................................. 40, 50

ウィジェット
（Widget）. . ............................. 95

try-catch...................................... 50, 80, 85

エレメント
（Element参照）

U

オーバーライド. . ........................................ 65

Unicode CLDR. . .................................... 128

................. 95
階層構造（ウィジェットツリー）

UniqueKey.. ........................................... 281

. . ........................... 65
拡張（Extend a class）

Uint8List. . .............................................. 200

か

unmount................................................ 271

....... 65
拡張メソッド
（Extension methods）

useMaterial3. . ....................................... 146

カスケード記法. . ....................................... 37

V

型推論. . ..................................................... 24

validate.................................................. 246

型注釈. . ..................................................... 24

ValueKey....................................... 280, 281

可変長と固定長. . ...................................... 30

valueOrNull........................................... 229

画面遷移. . ............................................... 152

values. . ..................................................... 72

環境変数. . ............................................... 137

W

340

Z

Zone......................................................... 88

関数ベースのProvider.......................... 224

watch............................................. 221, 230

キーストア............................................... 326

Web APIのリクエスト............................ 236

クックブック. . ............................................... 3

WebView.. .................................................. 3

クラウド管理対象証明書............... 321, 322

when.. ......................................... 40, 49, 228

クラス........................................................ 61

where....................................................... 88

クラスの依存関係.. ................................. 217

while. . ....................................................... 43

クラスベースのProvider........................ 225

WidgetRef.. .................................... 218, 230

クラス修飾子............................................ 72

write......................................................... 37

クロージャ................................................. 60

X

計算量. . ........................................... 264, 283

Xcode......................................... 9, 308, 310

継承. . ......................................................... 65

Y

コードジェネレータ. . ............................... 121

yield.......................................................... 83

コードと設定を分離する........................ 137

yield*........................................................ 83

コードラボ. . ................................................. 3

索引

コード署名.............................. 320, 321, 326

は

コールバック............................................. 53

パターン構文............................................ 44

公開鍵. . ........................................... 320, 326

パッケージ......................................... 17, 108

コンパイル.. ................................................. 3

パッケージ管理ツール............... 10, 13, 108

コンパイル時定数. . ..................... 25, 63, 291

パフォーマンス..... 3, 63, 216, 273, 287, 303

さ

バリデーション. . ...................................... 244

最低サポートOS..................................... 306

秘密鍵. . ................................... 320, 321, 326

最適化. . ................................... 154, 264, 286

ビルドSDK. . ............................................ 310

ジェネリクス. . ............................................ 34

フォールスルー......................................... 40

ジェネリック型.......................................... 34

プラグイン......................................... 12, 108

ジェネリック関数...................................... 35

プレースホルダ................................ 50, 125

省略可能引数........................................... 58

ブロードキャスト....................................... 87

証明書. . ................................... 320, 321, 326

プロビジョニングプロファイル............... 321

省略記法. . ................................................. 59

分解宣言. . ........................................... 44, 48

状態管理. . ....................................... 216, 283

ベクタ画像...................................... 132, 134

スプラッシュ画面. . .................................. 316

ヘルパメソッド.. ...................................... 296

静的解析. . ......................................... 17, 223

ヘルパ関数............................................... 68

静的型付け言語....................................... 24

ホットリロード. . ........................... 3, 143, 223

宣言的UI......................................... 217, 273
た

ま

マッチング. . ......................................... 44, 46

ダークモード........................................... 146

マテリアルデザイン.......................... 95, 146

ターゲットSDK....................................... 311

マニフェストファイル.............................. 312

タイププロモーション............................... 56

マルチプラットフォーム.............................. 2

多重継承. . ................................................. 69

ミックスイン
（mixin参照）

タプル型. . .................................................. 31

文字入力. . ............................................... 236

ディープリンク. . ....................................... 166

ら

ディスプレイ解像度................................ 131

ライフサイクル......... 211, 213, 217, 231, 268

テーマ..................................................... 142

ライブラリ.................................... 17, 57, 108

デバッグ................................................ 2, 12

列挙型. . ..................................................... 70

糖衣構文. . ........................................... 61, 67

連想配列. . ................................................. 30

ドキュメントコメント................................. 54

レンダリング............................................... 2

匿名関数. . ................................................. 59
な

名前付きコンストラクタ.. .......................... 64
名前付き引数................................... 58, 100
名前付きフィールド............................ 32, 46
名前付きルート. . ............................. 161, 166
日本向けのローカライズ........................ 113
ネイティブUI............................................... 2
ネイティブコード................................. 3, 108

341

装丁・本文デザイン .................. 西岡 裕二

レイアウト ............................... 酒徳 葉子（技術評論社）
本文図版 .................................. スタジオ・キャロット
編集 ........................................ 菊池 猛

ウェブディービー

プレス

プラス

WEB+DB PRESS plus シリーズ
フラッター

じっ

せん

かい

はつ

Flutter実践開発
アイフォーン

アンドロイド

りょう たい おう

かい はつ

iPhone／Android両対応アプリ開発のテクニック
2024 年 3 月 20 日 初版 第 1 刷発行
2025 年 3 月 13 日 初版 第 2 刷発行

わたなべ よう た

著者 ........................................ 渡部 陽太
発行者 ..................................... 片岡 巌
発行所 ..................................... 株式会社技術評論社

東京都新宿区市谷左内町 21-13
電話 03-3513-6150 販売促進部
03-3513-6175 第 5 編集部

印刷／製本 ............................... 日経印刷株式会社

定価はカバーに表示してあります。
本書の一部または全部を著作権法の
定める範囲を超え、無断で複写、複
製、転載、あるいはファイルに落と
すことを禁じます。
造本には細心の注意を払っておりま
すが、万一、乱丁（ページの乱れ）や
落丁（ページの抜け）がございました
ら、小社販売促進部までお送りくだ
さい。送料小社負担にてお取り替え
いたします。

©2024 渡部陽太
ISBN 978-4-297-13993-3 C3055
Printed in Japan

お問い合わせ
本書の内容に関するご質問につきましては、下記の宛先まで書
面にてお送りいただくか、小社 Web サイトのお問い合わせフォー
ムからお願いいたします。お電話によるご質問、および本書に記
載されている内容以外のご質問には、一切お答えできません。あ
らかじめご了承ください。
また、ご質問の際には
「書名」と「該当ページ番号」
、
「お客様のパ
ソコンなどの動作環境」、「お名前とご連絡先」を明記してください。
〒 162‒0846
東京都新宿区市谷左内町 21‒13
株式会社技術評論社 第 5 編集部
『Flutter 実践開発』質問係
URL https://gihyo.jp/book（技術評論社 Web サイト）
お送りいただきましたご質問には、できる限り迅速にお答えす
るよう努力しておりますが、ご質問の内容によってはお答えする
までに、お時間をいただくこともございます。回答の期日をご指
定いただいても、ご希望にお応えできかねる場合もありますので、
あらかじめご了承ください。
なお、ご質問の際に記載いただいた個人情報は質問の返答以外
の目的には使用いたしません。また、質問の返答後は速やかに破
棄いたします。

