                                                                       Keyは何に使うのか   9.3

図 9.11     State のインデックスが変化しない様子




                             FroatingActionButton
                                   をタップ

                                                          Stateのインデックスが
                                                          変化していない




  ウィジェットのインデックスを表示するための情報はウィジェット
（ListItem）が保持しています。ウィジェットは build メソッドが実行される
たびに作りなおされます。一方で、State のインデックスを表示するための情
報は State が保持しています。そして、State は Element が参照を保持してい
るのでした。
  Element が再利用される条件に、ウィジェットの型が同じかつ Key が同じと
いうものがありました。今回は ListItem ウィジェットのインスタンスは同じ
ですし、Key も特に指定していない（null どうしを比較して一致した）ため
Element は上から順番に再利用されたのです（図 9.12）。

図 9.12     Element が上から順に再利用されたイメージ図


         Widget (index 1), Key (null)               Element (index 0), Key (null)
                                         型もKeyも
                                        一致している
         Widget (index 2), Key (null)               Element (index 1), Key (null)


         Widget (index 3), Key (null)               Element (index 2), Key (null)


         Widget (index 4), Key (null)               Element (index 3), Key (null)


         Widget (index 0), Key (null)               Element (index 4), Key (null)




Keyを利用したElementの再利用
  先ほどのサンプル、State のインデックスを並べ替えるには Key を利用しま

                                                                                    279
第
    9 フレームワークによるパフォーマンスの最適化
          章
              BuildContext、Key




              す。ListItem ウィジェットのコンストラクタに Key を渡します。

               ./lib/main.dart
              // 省略
                       body: Column(
                         children: list.map((element) {
                            return ListItem(
                              key: ValueKey(element),     ❶
                              widgetIndex: element,
                           );
                         }).toList(),
                       ),
              // 省略


                ValueKey とは、コンストラクタ引数に与えられた値で識別する Key です。
              これを実行すると、State のインデックスも並べ替えられることが確認できま
              （図 9.13）
              す       。

              図 9.13    State のインデックスが並び替えられる様子




                                         FroatingActionButton
                                               をタップ

                                                                Stateのインデックスが
                                                                変化する




                Element のツリー構造から Key が一致する Element を探し出します。このと
              き Key は❶に与えられた ValueKey です。ValueKey はウィジェットのインデッ
              クスで一意に識別されます。この ValueKey が一致するように Element を再利
              用するので、State のインデックスも一緒に並べ替えられるのです（図 9.14）。




    280
                                                                 Keyは何に使うのか   9.3

図 9.14    Key によって Element が並び替えられるイメージ図

                                     Keyが一致しない
         Widget (index 1), Key (1)               Element (index 0), Key (0)
                                     Keyが
                                         一致
         Widget (index 2), Key (2)          する   Element (index 1), Key (1)


         Widget (index 3), Key (3)               Element (index 2), Key (2)


         Widget (index 4), Key (4)               Element (index 3), Key (3)


         Widget (index 0), Key (0)               Element (index 4), Key (4)



  以上のように、Element の再利用により意図しないウィジェットと紐付い
てしまうケースなどに Key を利用します。



  Keyの種類
  Key にはいくつか種類があります。表 9.1 に代表的なものを 4 つ紹介します。

表 9.1     代表的な Key の種類

Key の種類          特徴
ValueKey         コンストラクタ引数に与えられた値で識別する Key
ObjectKey        コンストラクタ引数に与えられたオブジェクトで識別する Key
UniqueKey        インスタンスごとに一意に識別する Key
GlobalKey        ウィジェットの階層を越えて一意に識別する Key



  前項の例では int 型のインデックスで一意に識別するため、ValueKey を利
用しました。ObjectKey はコンストラクタ引数に与えられたオブジェクトで
一意に識別します。引数を取らない UniqueKey はインスタンスごとに一意に
識別します。これら 3 つの Key は同一階層のウィジェットから一致する Key を
探します。前項の例のようにリストの要素などを識別するのに利用します。
  GlobalKey はウィジェットの階層を越えて一意に識別します。異なる画面
で特定のウィジェットの状態を一致させる場合や、アニメーションなどに利
用します。




                                                                              281
第
    9 フレームワークによるパフォーマンスの最適化
          章
              BuildContext、Key




                  9.4
                  局所的にWidgetを更新するしくみ ── InheritedWidget

                  フレームワークが持つ最適化のしくみの一つとして、InheritedWidget につ
              いても触れておきます。
                  InheritedWidget は階層を越えてデータを渡すことのできるウィジェットで
              す。身近な例では Theme ウィジェットが内部で生成している _InheritedTheme
              ウィジェットが InheritedWidget です。MaterialApp ウィジェットの配下であ
              れば、Theme.of メソッドから階層のどこからでも ThemeData を取得できるの
              でした。

               ./lib/main.dart
              import 'package:flutter/material.dart';

              void main() {
                runApp(const MaterialApp(
                  home: HomeScreen(),
                ));
              }

              class HomeScreen extends StatelessWidget {
                const HomeScreen({super.key});

                  @override
                  Widget build(BuildContext context) {
                    final theme = Theme.of(context); // ThemeDataを取得
                    return Scaffold(
                       backgroundColor: theme.backgroundColor,
                       appBar: AppBar(
                          title: const Text('Home Screen'),
                       ),
                       body: const Center(
                          child: Text('Home Screen'),
                       ),
                    );
                  }
              }



                  先ほど、祖先のウィジェットを検索するBuildContext の API を紹介しました。

              T? findAncestorWidgetOfExactType<T extends Widget>();



    282
                                          局所的にWidgetを更新するしくみ ── InheritedWidget   9.4

 これに対して、祖先の InheritedWidget を検索する API も提供されており、
2 つの特徴を持っています。
T? dependOnInheritedWidgetOfExactType<T extends InheritedWidget>();


 まず 1 つ目は計算量です。InheritedWidget を検索する API は、O(1) 注 2 の計
算量です。フレームワークが提供するウィジェットの多くは ThemeData を参
照していますが、計算量が小さいので大きな問題にはなりません。
 も う 一 つ は InheritedWidget の 更 新 を 購 読 す る 効 果 が あ る こ と で す。
InheritedWidget は、提供するデータが更新されたことを子孫に通知すること
ができます。dependOnInheritedWidgetOfExactType を呼び出したウィジェッ
トは、通知を受けると build メソッドが呼び出されます。Theme ウィジェット
の例で言えば、ThemeData が更新されると ThemeData を参照するウィジェット
が再構築され、新しい ThemeData に合わせて UI が更新されます。このしくみ
を用いると、StatelessWidget であっても build メソッドが複数回呼ばれる可
能性があります。
 InheritedWidget の機能をまとめると、

・InheritedWidget はウィジェットの階層を越えてデータを提供することができる
・階層を越えてウィジェットの再構築をトリガすることができる

となります。第 7 章で解説した状態管理の概念と一致していますよね。
InheritedWidget はフレームワークが提供する状態管理のしくみの一つです。
 Theme ウィジェットのように上位に配置されるウィジェットが StatefulWidget
として実装されていたとしたら、ThemeData が更新されるとその配下すべて
を再構築する必要があります。一方、InheritedWidget は情報を必要とするウ
ィジェットを局所的に再構築することができ、パフォーマンスへの影響を抑
えることができるのです。




注2   ウィジェットの階層が深くなっても、計算時間が一定であることを意味します。


                                                                                  283
第
    9 フレームワークによるパフォーマンスの最適化
          章
              BuildContext、Key




               9.5
                まとめ

                Element を起点に、フレームワークが内部で行っている最適化について解
              説しました。Element はウィジェットよりもライフサイクルが長く（なる場合
                 、その Element は RenderObject を管理しています。この RenderObject
              がある）
              はレイアウト計算や描画といったコストの高い処理を行います。また、
              RenderObject は状態を持ち、更新が不要な場合はスキップするしくみになっ
              ています。この RenderObject を管理する Element の再利用は、このコストの
              高い処理をスキップする可能性をあげることにつながります。
                また、Element 再利用の条件には、Key というクラスが密接に関わっている
              ことを解説しました。Element の再利用は、時として意図しない表示結果の
              原因につながることがあり、Key を利用することで解決することができます。
                最 後 に、フ レ ー ム ワ ー ク が 提 供 す る 最 適 化 の し く み の 一 つ で あ る
              InheritedWidget にも触れました。
                本章ではフレームワークの最適化により、アプリのパフォーマンスが高め
              られていることがわかりました。次章では私たちエンジニアがパフォーマン
              スを意識してどのようにコーディングすべきかを解説します。




    284
        第



   高速で保守性の高い
            10   章




アプリを開発するためのコツ




                     285
第
    10 高速で保守性の高いアプリを開発するためのコツ
          章




               第 9 章ではフレームワークが内部で行っているパフォーマンスの最適化を
              解説しました。本章も同じくパフォーマンスをテーマに、コードを書く際に
              考慮すべきポイントを紹介します。



              10.1
               パフォーマンスと保守性、
                          どちらを優先すべきか

               一般に、高速な（パフォーマンスを最優先した）実装と、保守性を意識した
              実装は、相反する場合があります。Flutter のパフォーマンスを最大限に引き
              出す実装は、時にソースコードの可読性や保守性を低下させます。
               では、パフォーマンスと保守性はどのようなバランスでアプリを開発すれ
              ばよいのでしょうか。基本的には保守性を第一に実装を進めるのが良いと筆
              者は考えます。前章で解説したとおり、Flutter にはパフォーマンスを意識し
              た Element の再利用など、最適化のしくみがあります。それらのしくみによ
              り、パフォーマンスに深刻な問題が起こることは多くないからです。
               上記の前提はありますが、パフォーマンスを意識した実装と、保守性を意
              識した実装が必ずしも両立しないわけではありません。本章では、パフォー
              マンスに寄与しつつも保守性が高まるような実装の考え方を紹介します。意
              識すべきポイントとして、常に頭の片隅に置いておいてください。



               高速でないアプリとは
               前項では
                  「高速な」                「高速な」
                      という言葉を使いましたが、本章で示す   アプリとは
              表示がカクカクしないアプリ、画面がフリーズしないアプリのことを指します。
               Flutter は 60fps（毎秒 60 フレーム）または対応デバイスでは 120fps で描画を
              行うことを目標にしています。毎秒 60 フレームの場合ですと 1 フレームあた
              り約 16 ミリ秒、この間に次のフレームの準備が整わなければ、表示がカクカ
              クしたり、画面がフリーズしたように見えたりします。



               高速だが保守性が低い実装
               パフォーマンスを優先した結果、保守性が下がる実装の一例を紹介しまし

    286
