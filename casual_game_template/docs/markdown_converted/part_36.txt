 フレームワークによる
             第
                 9   章




パフォーマンスの最適化
      BuildContext、Key




                         263
第
    9 フレームワークによるパフォーマンスの最適化
          章
              BuildContext、Key




                ウィジェットの build メソッドの引数に渡される BuildContext や、ウィジェ
              ットのコンストラクタに渡される Key について、ここまで詳しい解説をしてき
              ませんでした。本章ではいよいよ BuildContextと Key の役割を明らかにし、そ
              れがアプリのパフォーマンス最適化につながっていることを解説します。



               9.1
                BuildContextは何者なのか ── Element

                ウィジェットの build メソッドの引数には必ず BuildContext が渡されます。
              この BuildContext は何者なのでしょうか。先に結論を言うと、Element（エ
              レメント）というクラスです。



                祖先の情報にアクセスできるBuildContext
                通常のアプリ開発で使う場面は少ないですが、BuildContext には興味深い
              API が用意されています。
              T? findAncestorWidgetOfExactType<T extends Widget>();


                ウィジェットの親をたどり、ツリーの中で最も近い位置にある T 型のウィ
              ジェットを探して返却するメソッドです。計算量は O(n) 注 1 です。実際に動作
              を確認してみましょう。

               ./lib/main.dart
              import 'package:flutter/material.dart';

              void main() {
                runApp(const MaterialApp(
                  home: HomeScreen(),
                ));
              }

              class HomeScreen extends StatelessWidget {
                const HomeScreen({super.key});


                @override
                Widget build(BuildContext context) {


              注1    ウィジェットの階層が深くなると、計算時間が線形に増えていくことを意味します。


    264
                                                       BuildContextは何者なのか ── Element    9.1

        final materialApp = context.findAncestorWidgetOfExactType<MaterialApp>();   ❶
        print(materialApp);
        // => MaterialApp
        return Scaffold(
          appBar: AppBar(
            title: const Text('Home Screen'),
          ),
          body: const Center(
            child: Text('Home Screen'),
          ),
        );
    }
}


    ❶ で findAncestorWidgetOfExactType メ ソ ッ ド を 呼 び 出 し、親 の
MaterialApp ウィジェットが取得できることが確認できます。
    ウィジェットは親や子にアクセスする API を持ちませんし、内部でもその
情報は持っていません。しかし、BuildContext（Element）は親子関係をツリ
ー構造で管理しているので、このような API が実現できるのです。
    ちなみに、似た API として、直近の祖先の State を取得する API があります。

T? findAncestorStateOfType<T extends State<StatefulWidget>>()


    BuildContext を引数に NavigatorState を取得する Navigator.of メソッド
は、この API を使って実現されています。


Elementがツリーを構成していく工程
    Flutter フレームワークの内部で Element がツリーを構成していく様子を図
で表します。次のように MaterialApp ウィジェット、その子に HomeScreen と
いうウィジェットがあるような状況を想定します。

./lib/main.dart
void main() {
  runApp(
     MaterialApp(
        home: HomeScreen()
     ),
  );
}


    main 関数では runApp 関数が呼び出され、引数には MaterialApp ウィジェッ
トが渡されます。このとき、runApp 関数の内部では、ルートになる Element

                                                                                        265
第
    9 フレームワークによるパフォーマンスの最適化
          章
              BuildContext、Key




              とウィジェットが生成されます（図 9.1 の❶）。ルートの Element は MaterialApp
              の Element 生成を命令します（図 9.1 の❷、❸）。

              図 9.1    MaterialApp の Element が生成される様子


                                 Frameworkが作る    ❶
                                 ルートのElement
                                                        createElement ❷


                                  MaterialAppの
                                                               MaterialApp
                                    Element           ❸



                MaterialApp の Element がツリーの一部として構成されます（図 9.2 の❶）。

              図 9.2    MaterialApp の Element がツリーの一部として構成される様子


                                 Frameworkが作る
                                 ルートのElement

                                         ❶

                                  MaterialAppの
                                                               MaterialApp
                                    Element



                                                                      （図
                MaterialApp の Element が MaterialApp の build メソッドを呼び出します
              9.3 の❶）
                    。

              図 9.3    MaterialApp の build メソッドが呼ばれる様子

                                 Frameworkが作る
                                 ルートのElement




                                  MaterialAppの        ❶
                                                               MaterialApp
                                    Element
                                                     build



                MaterialApp の build メソッドで、HomeScreen ウィジェットが返却されます
              （図 9.4 の❶）
                       。




    266
                                              BuildContextは何者なのか ── Element   9.1

図 9.4   HomeScreen が生成される様子


               Frameworkが作る
               ルートのElement




                MaterialAppの
                                              MaterialApp
                  Element
                                      build
                                                    ❶


                                              HomeScreen



  MaterialApp の Element が HomeScreen の Element 生成を命令します（図 9.5
  。
の❶）

図 9.5   HomeScreen の Element が生成される様子

               Frameworkが作る
               ルートのElement




                MaterialAppの
                                              MaterialApp
                  Element


                      createElement

                HomeScreenの
                                              HomeScreen
                  Element
                                       ❶



  HomeScreen の Element がツリーの一部として構成されます（図 9.6 の❶）。




                                                                              267
第
    9 フレームワークによるパフォーマンスの最適化
          章
              BuildContext、Key




              図 9.6    HomeScreen の Element がツリーの一部として構成される様子

                                 Frameworkが作る
                                 ルートのElement




                                   MaterialAppの
                                                               MaterialApp
                                     Element

                                            ❶

                                   HomeScreenの
                                                               HomeScreen
                                     Element


                  以上を末端のウィジェットまで繰り返し、Element のツリーを構成してい
              きます。



                  StatefulWidgetの状態を保持する役割
                  次は別の視点から BuildContext を見てみましょう。StatefulWidget の State
              は、誰が管理しているのでしょうか？ライフサイクルは StatefulWidget と同じ
              でしょうか？
                  StatefulWidget を入れ子構造にしたサンプルを用意しました。
               ./lib/main.dart
              import 'package:flutter/material.dart';

              void main() {
                runApp(
                   MaterialApp(
                      home: HomeScreen(),
                   ),
                );
              }

              // HomeScreenはStatefulWidget
              class HomeScreen extends StatefulWidget {
                HomeScreen({super.key}) {
                  debugPrint('HomeScreen constructor');
                }


                  @override
                  State createState() => _HomeScreenState();
              }


    268
                                                         BuildContextは何者なのか ── Element   9.1


class _HomeScreenState extends State<HomeScreen> {
  int _counter = 0;    ❶


    @override
    Widget build(BuildContext context) {
      debugPrint('CounterButton build');
        return Scaffold(
          appBar: AppBar(
            title: const Text('Home Screen'),
          ),
          body: Center(
             child: Column(
               mainAxisAlignment: MainAxisAlignment.center,
               children: [
                 // ボタンをタップするとカウントアップする
                  ElevatedButton(
                    child: Text('Home Screen Count: ($_counter)'),   ❷
                    onPressed: () {
                      setState(() {
                        _counter++;    ❸
                      });
                    },
                  ),
                  CounterButton(),    ❹
               ],
             ),
          ),
        );
    }
}

// CounterButtonはStatefulWidget
class CounterButton extends StatefulWidget {
  CounterButton({super.key}) {
    debugPrint('CounterButton constructor');
  }

    @override
    State createState() => _CounterButtonState();
}

class _CounterButtonState extends State<CounterButton> {
  int _counter = 0;    ❺


    @override
    Widget build(BuildContext context) {


                                                                                         269
第
    9 フレームワークによるパフォーマンスの最適化
          章
              BuildContext、Key




                      debugPrint('CounterButton build');
                      // ボタンをタップするとカウントアップする
                      return ElevatedButton(
                        onPressed: () {
                            setState(() {
                              _counter++;   ❻
                            });
                        },
                        child: Text('Counter Button Count: ($_counter)'),   ❼
                      );
                  }
              }



                  HomeScreen 画面は StatefulWidget です。内部でカウンタを持っており（❶）、
              ボタンをタップするとカウントアップします（❷、❸）。さらに、CounterButton
              という StatefulWidget を並べました（❹）。CounterButton ウィジェットも同様
              にカウンタを持っており（❺）、ボタンをタップするとカウントアップします
              （❻、❼）。
                  アプリを実行し、それぞれのボタンをタップするとカウンタがインクリメ
              ントされ、期待どおりに動作します。しかし、不思議なところはないでしょ
              うか？ HomeScreen 画面のカウンタをインクリメントする、すなわち setState
              メソッドを呼び出すと、build メソッドが呼ばれ CounterButton ウィジェット
              が新しく作られるハズです。なのに、CounterButton ウィジェットのカウン
              タはリセットされずに状態を保持しています。

              図 9.7        「Home Screen Count」ボタンの押下前後




                                                      Home Screen Count
                                                        ボタンをタップ




    270
