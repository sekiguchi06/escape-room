                                     ナビゲーションとルーティング ── 画面遷移を実現する3つの手法              5.2

import 'package:flutter/material.dart';

void main() {
    runApp(const MaterialApp(
      home: FirstScreen(),
    ));
}

// アプリ起動時に表示されるFirstScreenウィジェット
class FirstScreen extends StatefulWidget {
  const FirstScreen({super.key});


    @override
    State<StatefulWidget> createState() => _FirstScreenState();
}

class _FirstScreenState extends State<FirstScreen> {
  int _number = 0;    ❶


    @override
    Widget build(BuildContext context) {
      return Scaffold(
        appBar: AppBar(
           title: const Text('FirstScreen'),
        ),
        body: Center(
           child: Column(
             mainAxisAlignment: MainAxisAlignment.center,
             children: [
               Text(
                  'number = $_number',      ❷
               ),
               ElevatedButton(
                  onPressed: () async {
                    final newNumber = await Navigator.of(context).push<int>(
                       MaterialPageRoute(
                          builder: (_) => SecondScreen(number: _number),       ❸
                       ),
                    );
                    setState(() {
                       if (newNumber != null) {
                          _number = newNumber;       ❹
                       }
                     });
                  },
                  child: const Text('Secondへ'),
                ),


                                                                                   159
第
    5 テーマとルーティング
          章




                             ],
                           ),
                        ),
                      );
                  }
              }

                  _FirstScreenState クラスは _number というフィールドを持ち（❶）、Text ウ
                        （❷）。ボタンをタップすると SecondScreen 画面へ遷
              ィジェットで表示します
              移します。このとき、_number の値を引数として渡します（❸）。
                  続いて SecondScreen 画面を見てみましょう。

              class SecondScreen extends StatelessWidget {
                  const SecondScreen({super.key, required this.number});

                  final int number;      ❺


                  @override
                  Widget build(BuildContext context) {
                    return Scaffold(
                       appBar: AppBar(
                          title: const Text('IncrementScreen'),
                       ),
                       body: Center(
                          child: Column(
                             mainAxisAlignment: MainAxisAlignment.center,
                             children: [
                                ElevatedButton(
                                   child: const Text('Increment'),
                                   onPressed: () {
                                      Navigator.of(context).pop(number + 1);   ❻
                                   },
                                ),
                                ElevatedButton(
                                   child: const Text('Decrement'),
                                   onPressed: () {
                                      Navigator.of(context).pop(number - 1);   ❼
                                   },
                                ),
                             ],
                          ),
                       ),
                    );
                  }
              }

                  SecondScreen 画面は引数で渡された数値をフィールドで保持します（❺）。

    160
                                   ナビゲーションとルーティング ── 画面遷移を実現する3つの手法   5.2

ボタンをタップすると数値を増減させて FirstScreen 画面へ戻ります
                                     （❻、❼）。
NavigatorState クラスの pop メソッドの引数が、遷移元の画面に渡ります。
  再び FirstScreen 画面の❸に注目してください。push メソッドへ型パラメ
ータを指定しています。これは遷移先からの戻り値の型を指定しています。
また、push メソッドの戻り値は Future クラスなので、await キーワードで戻
り値を待つ実装となっています。戻ってきた数値で状態を更新して、このサ
ンプルは完了です（❹）。



  名前付きルートによる画面遷移 ── Navigator 1.0（非推奨）
  名前付きルートは、遷移先の画面に任意の名前を付けて名前で画面遷移す
る方法です。画面遷移に関わるコードを一ヵ所に集約したり、ボイラープレ
ートを削減することができます。ただし、名前付きルートは後述の制限事項
により現在は推奨されていません。本書では次項の Router ウィジェットとの
比較のため解説します。
  サンプルコードを見てみましょう。First、Second、Third の 3 つの画面を行
き来できるアプリです（図 5.7）。

図 5.7   名前付きルートサンプルの画面遷移イメージ


              First                    Second          Third
             Screen                    Screen         Screen




  3 つの画面はそれぞれ以下のように用意します。
// アプリ起動時に表示されるFirstScreenウィジェット
class FirstScreen extends StatelessWidget {
  const FirstScreen({super.key});

   @override
   Widget build(BuildContext context) {
     return Scaffold(
       appBar: AppBar(
          title: const Text('FirstScreen'),
       ),
       body: Center(
          child: Column(

                                                                      161
第
    5 テーマとルーティング
          章




                             mainAxisAlignment: MainAxisAlignment.center,
                             children: [
                               ElevatedButton(
                                  child: const Text('FirstからSecondへ'),
                                  onPressed: () {
                                  },
                                ),
                                ElevatedButton(
                                  child: const Text('FirstからThirdへ'),
                                  onPressed: () {
                                  },
                                ),
                             ],
                           ),
                        ),
                      );
                  }
              }


              // 画面遷移先として用意したSecondScreenウィジェット
              class SecondScreen extends StatelessWidget {
                const SecondScreen({super.key});

                  @override
                  Widget build(BuildContext context) {
                    return Scaffold(
                      appBar: AppBar(
                         title: const Text('SecondScreen'),
                      ),
                      body: Center(
                         child: Column(
                           mainAxisAlignment: MainAxisAlignment.center,
                           children: [
                              ElevatedButton(
                                 child: const Text('SecondからThirdへ'),
                                 onPressed: () {
                                 },
                              ),
                              ElevatedButton(
                                 child: const Text('戻る'),
                                 onPressed: () {
                                    Navigator.of(context).pop();
                                 },
                              ),
                           ],
                           ),
                        ),


    162
                                         ナビゲーションとルーティング ── 画面遷移を実現する3つの手法   5.2

        );
    }
}


// 画面遷移先として用意したThirdScreenウィジェット
class ThirdScreen extends StatelessWidget {
    const ThirdScreen({super.key});

    @override
    Widget build(BuildContext context) {
      return Scaffold(
          appBar: AppBar(
             title: const Text('ThirdScreen'),
          ),
          body: Center(
             child: Column(
               mainAxisAlignment: MainAxisAlignment.center,
               children: [
                  ElevatedButton(
                     child: const Text('戻る'),
                     onPressed: () {
                        Navigator.of(context).pop();
                     },
                  ),
               ],
             ),
          ),
        );
    }
}


    画面の遷移先と名前のマッピングは MaterialApp ウィジェットの引数で指
定します。
void main() {
  runApp(
     MaterialApp(
        initialRoute: '/',     ❶
        routes: {
           '/': (context) => const FirstScreen(),
           '/second': (context) => const SecondScreen(),        ❷
           '/second/third': (context) => const ThirdScreen(),
        },
     ),
  );
}

               （❷）は Map 型の引数でキーには String を、バリューには
    routes パラメータ

                                                                            163
第
    5 テーマとルーティング
          章




              ウィジェットを戻り値とする関数型を渡します。このキーの文字列を画面遷
              移先として指定することができます。initialRoute パラメータ（❶）は最初に
              表示する画面を指定します。
                  続いて、名前付きルートで画面遷移するコードを追加しましょう。
              class FirstScreen extends StatelessWidget {
                  const FirstScreen({super.key});

                  @override
                  Widget build(BuildContext context) {
                    return Scaffold(
                        appBar: AppBar(
                           title: const Text('FirstScreen'),
                        ),
                        body: Center(
                          child: Column(
                             mainAxisAlignment: MainAxisAlignment.center,
                             children: [
                                ElevatedButton(
                                   child: const Text('FirstからSecondへ'),
                                   onPressed: () {
                                      Navigator.of(context).pushNamed('/second');    ❶
                                   },
                                ),
                                ElevatedButton(
                                   child: const Text('FirstからThirdへ'),
                                   onPressed: () {
                                      Navigator.of(context).pushNamed('/second/third');   ❷
                                   },
                                ),
                             ],
                           ),
                        ),
                      );
                  }
              }

              class SecondScreen extends StatelessWidget {
                const SecondScreen({super.key});

                  @override
                  Widget build(BuildContext context) {
                    return Scaffold(
                      appBar: AppBar(
                           title: const Text('SecondScreen'),
                        ),
                        body: Center(

    164
                                        ナビゲーションとルーティング ── 画面遷移を実現する3つの手法       5.2

             child: Column(
               mainAxisAlignment: MainAxisAlignment.center,
               children: [
                  ElevatedButton(
                    child: const Text('SecondからThirdへ'),
                    onPressed: () {
                       Navigator.of(context).pushNamed('/second/third');   ❸
                    },
                  ),
                  ElevatedButton(
                    child: const Text('戻る'),
                    onPressed: () {
                       Navigator.of(context).pop();
                    },
                  ),
               ],
             ),
          ),
        );
    }
}

class ThirdScreen extends StatelessWidget {
  const ThirdScreen({super.key});

    @override
    Widget build(BuildContext context) {
      return Scaffold(
         appBar: AppBar(
            title: const Text('ThirdScreen'),
         ),
         body: Center(
            child: Column(
               mainAxisAlignment: MainAxisAlignment.center,
               children: [
                  ElevatedButton(
                     child: const Text('戻る'),
                     onPressed: () {
                        Navigator.of(context).pop();
                     },
                  ),
               ],
            ),
         ),
      );
    }
}


                                                                               165
第
    5 テーマとルーティング
          章




                  NavigatorState クラスの pushNamed メソッドで画面遷移します。遷移先は
              MaterialApp ウィジェットの routes パラメータに渡した Map のキーで指定し
               （❶〜❸）
              ます   。
                  MaterialApp ウィジェットの initialRoute パラメータは、デフォルト値が
              / となっています。initialRoute に渡された名前の画面が存在しない場合は
              デフォルト値が採用されます。
                  先ほどのサンプルを以下のように変更してみましょう。
              void main() {
                  runApp(
                    MaterialApp(
                       initialRoute: '/second/third',    ❶
                       routes: {
                         '/': (context) => const FirstScreen(),
                         '/second': (context) => const SecondScreen(),
                         '/second/third': (context) => const ThirdScreen(),
                       },
                    ),
                  );
              }

                                                         （❶）
                  initialRoute パラメータに /second/third を指定します 。アプリを起動
              するとThirdScreen 画面が表示され、
                                    「戻る」
                                       ボタンを押すとSecondScreen 画面
              が表示されます。さらに「戻る」ボタンを押すとFirstScreen 画面が表示されま
              す。このように、initialRoute に指定した画面の中間の画面も生成されます。
                  一方で、FirstScreen 画面から ThirdScreen 画面へ pushNamed 関数で遷移し
              た場合は中間の SecondScreen 画面は生成されません。この違いに注意してく
              ださい。

              ElevatedButton(
                 child: const Text('FirstからThirdへ'),
                 onPressed: () {
                    // 中間のSecondScreenは生成されない
                    Navigator.of(context).pushNamed('/second/third');
                 },
              ),


              名前付きルートの制限事項
                  / から始まるルートはディープリンクとして扱われる特徴があります。ディ
              ープリンクとは、ブラウザなどからアプリ内の特定の画面に遷移させるしくみ
              です。名前付きルートをディープリンクとして利用した場合、常に同じ動作と
                    「ログイン状態によって遷移先を変える」
              なり、たとえば                 といったカスタマイズ

    166
