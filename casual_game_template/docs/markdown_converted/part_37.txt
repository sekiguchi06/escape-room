                                                         BuildContextは何者なのか ── Element   9.1


  図 9.7 は「Home Screen Count」をタップする前後の様子です。「Home Screen
Count」は 2 から 3 に変化しました。これは HomeScreen 画面の build メソッド
が呼ばれたことを意味します。しかし、「Counter Button Count」は 1 の状態を
維持しています。この動きから、StatefulWidget の State は、StatefulWidget
よりも長いライフサイクルを持っていることがわかります（図 9.8）。

図 9.8   State のライフサイクルが Widget のライフサイクルよりも長いイメージ図


                       StatefulWidget                    State




                       StatefulWidget




  続いて StatefulWidget が生成する Element
                                 （StatefulElement）のソースコード
を一部見てみましょう。

 ./flutter/packages/flutter/lib/src/widgets/framework.dart
class StatefulElement extends ComponentElement {
  StatefulElement(StatefulWidget widget)
      : _state = widget.createState(),
        super(widget) {


  このように Element のコンストラクタで StatefulWidget の createState メソ
ッドを呼び出しています。また別のコードも見てみましょう。以下は Element
が破棄されるときに呼ばれる unmount メソッドです。

 ./flutter/packages/flutter/lib/src/widgets/framework.dart
void unmount() {
    super.unmount();
    state.dispose();


                                                                                         271
第
    9 フレームワークによるパフォーマンスの最適化
          章
              BuildContext、Key




                      // 省略
                      state._element = null;
                      _state = null;
                 }


                Element が破棄されるときに、State クラスの dispose メソッドが呼ばれて
              います。これらのコードから Element と State はライフサイクルが一致して
              いることがわかります。
                これまでわかったことを振り返ってみます。

              ・StatefulWidget の State は StatefulWidget よりもライフサイクルが長い
              ・State は Element とライフサイクルが一致している

                つまり、StatefulWidget よりも Element のほうがライフサイクルが長いこと
                  （図 9.9）
              になります      。

              図 9.9      Element のライフサイクルが Widget のライフサイクルよりも長いイメージ図


                                      StatefulWidget   Element




                                      StatefulWidget




                また一方で、先ほど Element がツリーを構成していく過程を解説しました。
              StatefulWidget よりも Element のほうがライフサイクルが長いことを念頭に、
              この過程を再度見てみます。

              ❶ Element から build メソッドが呼ばれ、子ウィジェットのインスタンスが作ら
               れる
              ❷子ウィジェットから子 Element が作られ、ツリーに組み込まれる



    272
                                     Elementの再利用とパフォーマンス ── RenderObject   9.2

❸子 Element から子 build メソッドが呼ばれ、孫ウィジェットのインスタンスが
 作られる
❹孫ウィジェットから孫 Element が作られ、ツリーに組み込まれる

 StatefulWidget で setState メソッドを呼び出した場合に当てはめてみまし
ょう。ウィジェットの build メソッドが呼び出され、その中で新しい子ウィ
ジェットのインスタンスが作られます（❶）。次の工程（❷）で子ウィジェット
が子 Element を作ってしまうと、ウィジェットと Element のライフサイクル
が同じになってしまい、辻褄が合いません。
 実はフレームワークの内部で、Element を再利用するしくみがあり、常に
新しい Element を作るわけではないのです。これまで解説してきたことをあ
らためて整理します。

・StatefulWidget よりも Element のほうがライフサイクルが長い
・Element は再利用されるしくみがある




 Tips 宣言的UIとElementの再利用
   第 7 章で状態管理の解説をする際に、宣言的 UI について触れました。

  UI = f(State)

   右 辺 の f は ウ ィ ジ ェ ッ ト の build メ ソ ッ ド で し た。そ し て、先 ほ ど
  StatefulWidget の State を管理しているのは Element だということを解説しま
 した。つまり、Flutter は次のような式ととらえることもできそうです。

  UI = Widget.build(Element.state)

   UI の設計図を提供するウィジェットと、それを実体化するための状態を持つ
  Element、責務を分けることで宣言的 UI を実現していると言えます。




 9.2
 Elementの再利用とパフォーマンス ── RenderObject

 Element の中には RenderObjectElement というクラスがあり、RenderObject
というクラスを管理しています。この RenderObject は Element と同様に独自
のツリー構造を持ちます。

                                                                           273
第
    9 フレームワークによるパフォーマンスの最適化
          章
              BuildContext、Key




                RenderObjectは高コストな計算を行う
                RenderObject はウィジェットのレイアウト計算を行います。RenderObject
              の親から子へ、サイズ制約を渡し、子のサイズが決まったら自身とのオフセ
              ット量を計算します。この操作をツリーの末端まで繰り返します。この処理
              はコストの高いものになります。
                レ イ ア ウ ト が 決 定 し た の ち、RenderObject は 描 画 処 理 を 行 い ま す。
              RenderObject は描画命令を発行し Flutter フレームワークよりも下層の Flutter
              Engine に対して描画を依頼します。この描画処理もまた、ツリーの末端まで
              繰り返すことになり、やはりコストの高いものになります。



                RenderObjectは状態を持つ
                RenderObject は描画に必要な状態を保持します。色のついた矩形を表現す
              る ColoredBox ウィジェットを例にとってみましょう。ColoredBox ウィジェッ
              トは、color というプロパティを持ちます。
                以下は、ColoredBox ウィジェットの実装を簡略化したものです。

               ./flutter/packages/flutter/lib/src/widgets/basic.dart
              class ColoredBox extends SingleChildRenderObjectWidget {
                const ColoredBox({ required this.color, super.child, super.key })

                final Color color;


                ColoredBox ウィジェットは、RenderObjectWidget を継承しており、_
              RenderColoredBox という RenderObject を生成します。_RenderColoredBox も
              また、color というプロパティを持ちます。
                以下は _RenderColoredBox の実装を簡略化したものです。

               ./flutter/packages/flutter/lib/src/widgets/basic.dart
              class _RenderColoredBox extends RenderProxyBoxWithHitTestBehavior {
                _RenderColoredBox({ required Color color })
                  : _color = color;


                Color _color;

                そして、_color のカスタムセッタが重要な役割を果たします。

               ./flutter/packages/flutter/lib/src/widgets/basic.dart
                Color get color => _color;


    274
                                        Keyは何に使うのか   9.3

 set color(Color value) {
     if (_color == value)
       return;
     _color = value;
     markNeedsPaint();
 }

 新しい color が現在の color と一致する場合は何もせずに終了します。一致
しない場合は、_color に新しい値をセットし、markNeedsPaint() を呼び出し
ます。この markNeedsPaint() は、次の描画タイミングで自身が再描画を行う
ようにフレームワークに予約するメソッドです。このように RenderObject は
描画に必要な状態を保持し、コストの高い処理をスキップするかどうかの判
断を行っているのです。



 Elementの再利用はパフォーマンスに影響する
 ここまでの RenderObject についての解説をまとめます。


・RenderObject は Element によって管理されており、Element の再利用は
 RenderObject の再利用につながる
・RenderObject はレイアウト計算や描画といったコストの高い処理を行う
・RenderObject はレイアウト計算や描画に必要な情報を保持しており、更新が不
 要な場合はスキップする


 つまりは、Element の再利用は RenderObject が行うコストが高い処理をス
キップする可能性をあげることにつながります。



 9.3
 Keyは何に使うのか

 BuildContext に加えて、掘り下げてこなかったものに Key クラスがありま
す。ウィジェットのコンストラクタ引数には、いつも Key がありますよね。こ
の Key は何者で、何に使われるのでしょうか。




                                                     275
第
    9 フレームワークによるパフォーマンスの最適化
          章
              BuildContext、Key




                Elementが再利用される条件
                先ほど Element は適宜再利用されると説明しました。この Element の再利
              用と Key は密接な関係があります。ここで Element が再利用される条件を列
              挙します。

              ❶ウィジェットのインスタンスが同じ
              ❷ウィジェットの型が同じかつ Key が同じ
              ❸ GlobalKey が同じ

                これだけだとイメージしづらいので、Key を利用して Element を再利用する
              例を見てみましょう。



                Elementが再利用される様子を見てみよう
                先ほど Element が再利用される条件に、ウィジェットの型が同じかつ Key が
              同じというものがありました。この動作を確認するために、以下のようなサ
              ンプルを用意しました。再利用の様子を確認するために、少々強引なコード
              になっていますが、ご容赦ください。
                5 つの要素を並べたリストを並べ替えるサンプルです。FloatingActionButton
                                        （図 9.10）
              ウィジェットをタップすると先頭の要素が末尾に移動します      。

              図 9.10   リストを並べ替えるサンプル




                                                        先頭のアイテムが
                                                        末尾に移動
                                 FroatingActionButton
                                       をタップ




    276
                                                                   Keyは何に使うのか   9.3

./lib/main.dart
import 'package:flutter/material.dart';

void main() {
    runApp(
        const MaterialApp(
          home: HomeScreen(),
        ),
    );
}

class HomeScreen extends StatefulWidget {
    const HomeScreen({super.key});


    @override
    State createState() => _HomeScreenState();
}

class _HomeScreenState extends State<HomeScreen> {
  final list = List.generate(5, (index) => index);             ❶


    @override
    Widget build(BuildContext context) {
      return Scaffold(
         appBar: AppBar(
            title: const Text('Home Screen'),
         ),
         body: Column(
            children: list.map((element) {
               return ListItem(
                  widgetIndex: element,    ❷
               );
            }).toList(),
         ),
         floatingActionButton: FloatingActionButton(
            onPressed: () {
               setState(() {
                  debugPrint('Swap first and last element');
                  final value = list.removeAt(0);
                                                     ❸
                  list.add(value);
               });
            },
            child: const Icon(Icons.swap_vert),
         ),
      );
    }
}


                                                                                277
第
    9 フレームワークによるパフォーマンスの最適化
          章
              BuildContext、Key




              class ListItem extends StatefulWidget {
                  const ListItem({super.key, required this.widgetIndex});

                  final int widgetIndex;    ❹


                  @override
                  State createState() => _ListItemState();
              }

              class _ListItemState extends State<ListItem> {
                static int counter = 0;


                  final int _stateIndex = counter++;    ❺


                  @override
                  Widget build(BuildContext context) {
                    return ListTile(
                      title: Text(
                        'Widget index ${widget.widgetIndex}, '    ❻
                            'State index $_stateIndex',    ❼
                        ),
                      );
                  }
              }



                  ❶では、0 から 4 までの整数を要素とするリストを作成しています。リスト
              の要素を❷で並べて表示しています。このリストを❸で並べ替えています。
              FloadingActionButton ウィジェットをタップすると、リストの先頭の要素を
              末尾に移動させます。この操作は setState 引数の中で行っているので表示は
              更新されます。
                  リストの要素は独自に実装した ListItem ウィジェットです。ListItem ウィ
              ジェットは widgetIndex というプロパティ（❹）を持ち、❶のインデックスが
              渡ります。また、State（_ListItemState クラス）は _stateIndex というプロパ
              ティを持ち（❺）
                     、こちらは State のインスタンスが作られた順にインデックス
              を保持します。それぞれ❻と❼でウィジェットのインデックス、State のイン
              デックスとして表示しています。
                  このサンプルを実行し FloatingActionButton ウィジェットをタップすると、
              ウィジェットのインデックスは変化しますが State のインデックスは変化しま
               （図 9.11）
              せん       。



    278
